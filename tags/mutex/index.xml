<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mutex on subond&#39;s blog</title>
    <link>http://www.subond.com/tags/mutex/</link>
    <description>Recent content in mutex on subond&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 29 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://www.subond.com/tags/mutex/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>互斥锁与读写锁的性能对比</title>
      <link>http://www.subond.com/post/005_golang_mutex/</link>
      <pubDate>Thu, 29 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/005_golang_mutex/</guid>
      <description>互斥锁与读写锁 Go 语言标准包 sync 中提供了两种锁，互斥锁 Mutex 和读写锁 RWMutex ，那两者有什么样的区别和差异呢？
互斥锁（sync.Mutex) 互斥意味着加锁的多个代码块不可能同时执行。只有抢到锁的 goroutine 才可以执行，其他 goroutine 只能等待（阻塞在 Lock()方法）锁释放后，获得互斥锁才能继续执行。
互斥锁提供了两种操作：
Lock()，即上锁 Unlock()，即解锁 通常我们将Unlock() 放到 defer函数中执行，确保退出代码块时一定会解锁。
读写锁（sync.RWMutex） 读写锁是为了解决这样的场景：只要保证写操作安全就可，读操作可以并行执行，从而提高读的效率。
读写锁也称为 多读单写锁，它包括读锁和写锁，读写可以同时执行，但是写锁是互斥的。通常有下面三中场景：
在没有写锁的情况下，读锁是不互斥的，允许多个同时执行 写锁之间是互斥的，只能一个写锁工作，其他写锁阻塞 读锁和写锁是互斥的，如果存在读锁，写锁阻塞；如果存在写锁，读锁阻塞 从这三种场景可以看到，读写锁主要是为了解决读多写少的性能问题。</description>
    </item>
    
  </channel>
</rss>
