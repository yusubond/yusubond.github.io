<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on subond&#39;s blog</title>
    <link>http://www.subond.com/tags/linux/</link>
    <description>Recent content in linux on subond&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 19 Jun 2016 00:00:00 +0000</lastBuildDate><atom:link href="http://www.subond.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux中的线程管理</title>
      <link>http://www.subond.com/post/linux_process2/</link>
      <pubDate>Sun, 19 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/linux_process2/</guid>
      <description>1.线程 线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。
2.多线程模型 操作系统中有两种方法提供线程支持：用户层的 用户线程 和 内核层的 内核线程。用户线程受内核内核支持，而无需内核管理；内核线程由系统直接支持和管理。
1）多对一模型：多个用户线程映射到一个内核线程
特点：线程管理由线程库在用户空间进行，效率高；一个线程阻塞系统调用，整个进程阻塞；任意时刻，只有一个线程能访问内核(也就是，多线程不能并行运行在多处理器上)
2）一对一模型：每个用户线程映射到一个内核线程
特点：一个线程阻塞，其他线程不受影响，具有并发功能；允许多线程运行在多处理器上。
3）多对多模型：即多路复用，许多用户线程映射到同等数量或较少数量的内核线程
特点：结合多对一模型和一对一模型的优点，其对应的一个变形是 二级模型 (先允许一个用户线程绑定到一个内核线程上，然后，其他用户线程多路复用)
3.线程库 线程库为程序员提供创建和管理线程的API函数，主要有两种方法来实现线程库：系统调用和非系统调用
1）在用户空间提供没有内核支持的库，称为 非系统调用；
2）由系统支持的内核级库，称为 系统调用
系统调用fork()和exec()
exec():如果一个线程调用exec()，则其指定的程序替换整个进程，包括所有线程。
fork(): 1）fork()之后立即调用exec()，则没有必要替换所有线程，因为exec()会替换所有线程；2）fork()之后没有调用exec()，则另一个进程复制所有线程。
4.线程取消 线程取消是在线程完成之前来终止线程的任务。要取消的线程称为 目标线程。目标线程可以在两种情况下发生：
1）异步取消: 一个线程立即终止目标线程。 (所有线程共享进程的数据，因为异步取消并不会使系统资源空闲)</description>
    </item>
    
    <item>
      <title>Linux中的进程管理</title>
      <link>http://www.subond.com/post/linux_process/</link>
      <pubDate>Fri, 17 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/linux_process/</guid>
      <description>1.进程 进程是执行中的程序，是大多数系统的工作单元，是 活动实体。一般，进程具有以下几种状态：新的，运行，等待，就绪，终止。每个进程在操作系统中用进程控制块(PCB)表示，其包含许多与一个特定进程相关的信息(进程状态，程序计数器，CPU寄存器，CPU调度信息，内存管理信息，记账信息，I/O状态信息等)。
进程调度
进程调度是指选择一个可用的进程到CPU上执行的过程，由相应的 调度程序 来执行。进程进入系统后，进入 作业队列 (包含系统中的所有队列)；驻留在内存中就绪，等待执行的进程位于 就绪队列。就绪队列通常用链表实现，其头节点指向链表的第一个和最后一个PCB块的指针；每个PCB包括一个指向就绪队列的下一个的PCB的指针域。
调度程序分为 长期调度程序, 中期调度程序 和 短期调度程序。长期调度(高级调度)，又称为 作业调度，是指从池中选择进程，并装入内存准备执行，其使用频率比较低，主要用来控制内存中进程的数量；中期调度(中级调度)，又称为 交换调度，是指将进程中内存或CPU竞争中移出，从而降低多道程序设计的程度，之后进程被重新装入内存；短期调度(低级调度)，又称为 进程调度，是指按照一定的策略和算法，将CPU分配给一个处于就绪的进程，分为 抢占式 和 非抢占式。
上下文切换
将CPU切换找另一个进程需要保存当前进程的状态，并恢复另一个进程的状态，这个过程称为上下文切换。
2.进程操作 进程创建 和 进程终止
进程创建新进程时，有两种执行可能：
1）父进程与子进程并发执行；2）父进程等待，直到某个子进程或全部子进程执行完毕。
同样，新进程的地址空间也有两种可能：</description>
    </item>
    
    <item>
      <title>Linux中的线程函数</title>
      <link>http://www.subond.com/post/linux_pthread/</link>
      <pubDate>Tue, 14 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/linux_pthread/</guid>
      <description>线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。以下内容，主要介绍5个基本线程函数。
1.pthread_create()函数 当一个程序由exec启动执行时，称为初始线程或主线程的单个线程就创建了。其余线程则由pthread_create函数创建。
#include &amp;lt;pthread.h&amp;gt; int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg); //返回：成功为0，出错为正的Exxx值 tid:一个进程内的每个线程都有一个线程ID标识，其数据类型为pthread_t(unsigned long int,即％lu)。如果新的线程创建成功，其ID通过tid指针返回。
attr:属性，每个线程都有许多属性（优先级，初始栈大小，是否成为一个守护线程等等）。若采用默认设置，可置attr参数为空指针（NULL）。
创建一个线程时最后指定的参数就是由该线程执行的函数func及其参数arg。注意 func和arg的声明。func所指函数作为参数接受一个通用指针 (void *)，又作为返回值返回一个通用指针(void *)。另外该函数的唯一调用参数是指针arg，如果需要给函数传递多个参数，可以打包成一个结构，然后将结构的地址作为单个参数传递给函数。
2.pthread_join()函数 #include &amp;lt;pthread.h&amp;gt; int pthread_join(pthread_t *tid, void **status); //返回：成功为0，出错为正的Exxx值。 该函数的功能是等待一个给定线程终止</description>
    </item>
    
  </channel>
</rss>
