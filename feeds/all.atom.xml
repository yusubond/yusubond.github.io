<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Milestone</title><link href="www.subond.com/" rel="alternate"></link><link href="www.subond.com/feeds/all.atom.xml" rel="self"></link><id>www.subond.com/</id><updated>2017-04-09T00:00:00+08:00</updated><entry><title>Dynamo分布式键值系统</title><link href="www.subond.com/pages/2017/04/09/dynamo-distributed-systems.html" rel="alternate"></link><published>2017-04-09T00:00:00+08:00</published><updated>2017-04-09T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-09:www.subond.com/pages/2017/04/09/dynamo-distributed-systems.html</id><summary type="html">&lt;p&gt;分布式键值模型是分布式表格模型的一种特例，一般只支持单个key-value的“增、删、查、改”操作，因此适用 &lt;strong&gt;哈希分布算法&lt;/strong&gt;。Amazon Dynamo是分布式键值系统，学习Dynamo的设计思想，设计原则，对理解分布式系统理论很有帮助。&lt;/p&gt;</summary><content type="html">&lt;p&gt;分布式键值模型是分布式表格模型的一种特例，一般只支持单个key-value的“增、删、查、改”操作，因此适用 &lt;strong&gt;哈希分布算法&lt;/strong&gt;。Amazon Dynamo是分布式键值系统，学习Dynamo的设计思想，设计原则，对理解分布式系统理论很有帮助。&lt;/p&gt;
&lt;h3&gt;Amazon Dynamo&lt;/h3&gt;
&lt;p&gt;Dynamo以简单的键值方式存储数据，且存储的是数据的原始形式，不解析数据的内容。以下是Dynamo设计中面临的问题及解决方案，接下来依次查看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Dynamo设计" src="http://on64c9tla.bkt.clouddn.com/Comput/dynamo.png"&gt;&lt;/p&gt;
&lt;h4&gt;数据分布&lt;/h4&gt;
&lt;p&gt;改进的一致性哈希算法(也称为一致性哈希表，简称DHT)的思想是：每一个物理节点根据其性能的差异分配多个token，&lt;strong&gt;每个token对应一个“虚拟节点”&lt;/strong&gt;。每个虚拟节点的处理能力相当，并 &lt;strong&gt;随机分布&lt;/strong&gt; 在哈希空间中，存储时，数据根据哈希值落在某个虚拟节点的负责的区域中，然后被存储在该虚拟节点对应的物理节点上。&lt;/p&gt;
&lt;p&gt;&lt;img alt="改进的哈希一致性算法" src="http://on64c9tla.bkt.clouddn.com/Comput/dynamo_hash.png"&gt;&lt;/p&gt;
&lt;p&gt;为了找到数据所属的节点，Dynamo系统中 &lt;strong&gt;每个节点维护整个集群的信息&lt;/strong&gt;，客户端也缓存整个集群的信息。与此同时，为了保证每个节点缓存是Dynamo系统中最新的集群信息，&lt;strong&gt;所有节点每隔固定时间&lt;/strong&gt; 通过 &lt;strong&gt;Gossip协议&lt;/strong&gt; 从其他节点中任意一个与之通信的节点。如果连接成功，&lt;strong&gt;双方交换各自保存的集群信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;【补充】：Gossip协议&lt;/p&gt;
&lt;p&gt;Gossip协议用于P2P系统中自洽的节点协调对整个集群的认识，比如集群的节点，负载情况等。一个简单的例子是这样的(集群中节点A和节点B交换对集群的认识)。&lt;/p&gt;
&lt;p&gt;1）A告诉B其管理的所有节点的版本（包括Down状态和Up状态的节点）&lt;br&gt;
2）B告诉A哪些版本比较旧，哪些版本它有最新的，然后把那些最新的版本发给A（处于Down状态下的版本由于没有更新，所有不会被关注）&lt;br&gt;
3）A将B中比较旧的版本发给B，同时将B发来的最新节点信息做本地更新&lt;br&gt;
4）B收到A发来的最新节点信息，然后做本地更新  &lt;/p&gt;
&lt;h4&gt;一致性和复制&lt;/h4&gt;
&lt;p&gt;Dynamo系统中对副本的管理思想是：假设数据存储N份，DHT定位到数据存储所属的节点K，则将数据存储在节点K, K+1, ..., K+N-1。如果第k+i(0&amp;lt;=i&amp;lt;=N-1)台机器，则往后找一台机器K+N临时替代。如果K+i台机器重启，临时替代的机器K+N能够通过Gossip协议发现，并把临时数据归还K+i，这个过程称为“&lt;strong&gt;消息回传&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;Dynamo中的NWR机制，其中N表示副本数，R表示成功读取操作的最少节点数，W表示成功写操作的最少节点数。只要满足W+R&amp;gt;N，可以保证当存在不超过一台机器故障时，至少能够读到一份有效的数据。由于每个节点存储的集群信息有所不同，可能出现同一条记录被多个节点同时更新，但不能多个节点之间的更新顺序。因此，Dynmao利用 &lt;strong&gt;向量时钟&lt;/strong&gt; 技术了解决冲突。&lt;/p&gt;
&lt;p&gt;向量时钟机制如下：&lt;/p&gt;
&lt;p&gt;[nodes, counter]：其中nodes表示节点，counter表示计数器，初始为0，节点每次更新操作加1。&lt;/p&gt;
&lt;p&gt;&lt;img alt="向量时钟" src="http://on64c9tla.bkt.clouddn.com/Comput/vectorclock.png"&gt;&lt;/p&gt;
&lt;h4&gt;容错&lt;/h4&gt;
&lt;p&gt;Dynamo中异常分为两种：临时性异常和永久性异常。Dynamo中的容错机制包括：&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;数据回传&lt;/strong&gt;。&lt;br&gt;
2）&lt;strong&gt;Merkle树同步&lt;/strong&gt;。当出现永久性异常时，利用Merkle树机制从其他副本进行数据同步。其原理是，每个非叶子节点对应多个文件(为其所有节点值组合以后的哈希值)；叶子节点对应单个数据文件(为文件内容的哈希值)。因此，&lt;strong&gt;任何一个数据文件不匹配都将导致从该文件对应的叶子节点到根节点的所有节点值不同&lt;/strong&gt;。每台机器对每一段范围的数据维护一棵Merkle树，机器同步时首先传输Merkle树信息，并且只需要同步从根到叶子的所有节点值均不同的文件。&lt;br&gt;
3）&lt;strong&gt;读取故障&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;负载均衡&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Dynamo的负载均衡取决于如何给每个机器分配虚拟节点号，即token&lt;/strong&gt;。一般有两种方法，如下所述。&lt;/p&gt;
&lt;p&gt;第一种，&lt;strong&gt;随机分配&lt;/strong&gt;。每台物理节点加入时根据其配置情况随机分配S个Token。优缺点是：可控性差，新节点加入/删除时，集群中的原有节点都需要扫描所有的数据从而找出属于新节点的数据，Merkle树也需要全部更新。&lt;/p&gt;
&lt;p&gt;第二种，&lt;strong&gt;数据范围等分+随机分配&lt;/strong&gt;。其思想是将数据额哈希空间等分为Q = N x S份(N = 机器数，S = 每台机器的虚拟节点数)，然后每台机器随机选取S个分割点作为Token。优缺点：每台机器都可以对属于每个范围的数据维护一棵逻辑上的Merkle树，新节点加入/删除，只需要扫描部分数据进行同步，并更新这部分数据对应的逻辑Merkle树。&lt;/p&gt;
&lt;h4&gt;读写流程&lt;/h4&gt;
&lt;p&gt;Dynamo的读写流程如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="写操作流程" src="http://on64c9tla.bkt.clouddn.com/Comput/dynamowrite.png"&gt;&lt;/p&gt;
&lt;p&gt;1) 根据一致性哈希算法计算出每个副本所在的存储节点，然后选取一个副本作为协调者。&lt;/p&gt;
&lt;p&gt;2）协调者 &lt;strong&gt;并发&lt;/strong&gt; 地往所有其他副本发送写请求，并将数据写入本地；如果发送写请求失败，协调者将它加入重试列表并不断重试。&lt;/p&gt;
&lt;p&gt;3）当副本接收到数据后，成功写入本地，并回复协调者&lt;/p&gt;
&lt;p&gt;4）等到W-1(协调者写入成功)个副本回复写入成功后，协调者恢复客户端写入成功；并继续等待或重试，直到所有副本写入成功。&lt;/p&gt;
&lt;p&gt;&lt;img alt="读操作流程" src="http://on64c9tla.bkt.clouddn.com/Comput/dynamoread.png"&gt;&lt;/p&gt;
&lt;p&gt;1）根据一致性哈希算法计算出每个副本所在的存储节点，然后选取一个副本作为协调者&lt;/p&gt;
&lt;p&gt;2）协调者根据负载策略选择R个副本，&lt;strong&gt;并发&lt;/strong&gt; 地向它们发送请求，并读取本地数据。&lt;/p&gt;
&lt;p&gt;3）每个副本读取本地数据，回复协调者读取结果。&lt;/p&gt;
&lt;p&gt;4）等到R-1个副本读取成功后，回复客户端。分两种情况，一种是，R个副本返回的数据一致，则将读取结果回复客户端；另一种是根据 &lt;strong&gt;冲突处理机制&lt;/strong&gt; （根据修改的时间戳选择最新数据）合并多个副本的读取结果，然后回复客户端。&lt;/p&gt;</content><category term="Amazon"></category><category term="Distributed Systems"></category></entry><entry><title>GFS分布式文件系统</title><link href="www.subond.com/pages/2017/04/06/gfs-distributed-systems.html" rel="alternate"></link><published>2017-04-06T00:00:00+08:00</published><updated>2017-04-06T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-06:www.subond.com/pages/2017/04/06/gfs-distributed-systems.html</id><summary type="html">&lt;p&gt;分布式文件系统主要有两个功能：一个是存储文档，图像，视频之类的Blob类数据；一个是作为分布式表格系统的持久化层。分布式文件系统中最著名的就是Google File System(GFS)，因此，本章通过介绍GFS的内部实现机制来学习分布式文件系统的知识与设计。&lt;/p&gt;</summary><content type="html">&lt;p&gt;分布式文件系统主要有两个功能：一个是存储文档，图像，视频之类的Blob类数据；一个是作为分布式表格系统的持久化层。分布式文件系统中最著名的就是Google File System(GFS)，因此，本章通过介绍GFS的内部实现机制来学习分布式文件系统的知识与设计。&lt;/p&gt;
&lt;h3&gt;1 整体架构&lt;/h3&gt;
&lt;p&gt;&lt;img alt="GFS整体架构" src="http://on64c9tla.bkt.clouddn.com/Comput/gfs-architecture.png"&gt;&lt;/p&gt;
&lt;p&gt;一个GFS系统中的节点有三种角色：&lt;strong&gt;GFS主控服务器(GFS Master)，GFS数据块服务器(GFS ChunkServer)和GFS客户端&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;GFS存储系统中的文件被分割成固定大小的数据块(chunk)，在chunk创建时，Master服务器给每个chunk分配一个全局唯一的chunk句柄。数据块服务器(ChunkServer,CS)把chunk以linux文件的形式存储到磁盘中，并根据指定的chunk句柄和字节范围来读写数据。为了保证可靠性，chunk在不同的服务器中复制多个副本，默认是三份。&lt;/p&gt;
&lt;p&gt;主控服务器维护系统的元数据，包括文件，chunk命名空间，文件到chunk之间的映射关系，chunk位置信息。同时，也负责整个系统的全局控制，如chunk租约管理，垃圾回收无用的chunk，chunk复制等。主控服务器 &lt;strong&gt;周期地&lt;/strong&gt; 与CS服务器通过 &lt;strong&gt;心跳的方式&lt;/strong&gt; 交换信息。&lt;/p&gt;
&lt;p&gt;客户端是GFS提供给应用程序的访问接口，它是一组专用接口，不遵循POSIX规范，以库文件的形式提供。客户端访问GFS时，首先访问主控服务器节点，获取与之交互的CS信息，然后直接访问这些CS，完成数据存取工作。值得注意的是，GFS客户端不缓存文件数据，只缓存主控服务器中获取的元数据。&lt;/p&gt;
&lt;h3&gt;2 关键问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1租约机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GFS系统中通过租约机制将chunk写操作授权给ChunkServer，从而减轻Master的负载。拥有租约授权的ChunkServer称为主ChunkServer，其他副本所在的ChunkServer称为备ChunkServer。主ChunkServer可以不断向Master请求延长租约的有效期直到整个chunk写满。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2一致性模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GFS系统主要是为了追加(append)而不是改写(overwrite)而设计的。如果不发生异常，追加成功的记录在GFS的各个副本中是确定并且严格一致的；如果出现异常，客户端将追究重试，直至成功（所有副本中至少成功追加一次）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3追加流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;追加流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gfs-append" src="http://on64c9tla.bkt.clouddn.com/Comput/gfs-append.png"&gt;&lt;/p&gt;
&lt;p&gt;1）客户端向Master请求chunk每个副本所在的ChunkServer，其中主ChunkServer持有修改租约。如果没有ChunkServer持有租约，说明该chunk最近没有写操作，Master会发起一个任务，按照一定的策略将chunk的租约授权给其中的一台ChunkServer。&lt;/p&gt;
&lt;p&gt;2）Master返回给客户端主副本和备副本所在的chunk的位置信息，客户端将缓存这些信息供以后使用。如果不出现故障，客户端以后读写该chunk都不需要再次请求Master。&lt;/p&gt;
&lt;p&gt;3）客户端将追加的记录发送到每一个副本中，每一个ChunkServer会在内部的LRU结构中缓存这些数据。GFS中采用数据流和控制流分流的方法，从而能够基于网络拓扑结构更好地调度数据流的传输。&lt;/p&gt;
&lt;p&gt;4）当所有副本都确认收到了数据，客户端发起一个写请求控制命令给主副本。由于主副本可能收到多个客户端对同一个chunk的并发追加操作，主副本将确定这些操作的顺序写入本地。&lt;/p&gt;
&lt;p&gt;5）主副本把写请求提交给所有的副本。每一个备副本会根据主副本确定的顺序执行写操作。&lt;/p&gt;
&lt;p&gt;6）备副本成功完成后应答主副本。&lt;/p&gt;
&lt;p&gt;7）主副本应答客户端，如果有副本发生错误，将出现主副本写成功但某些备副本不成功的情况，客户端将重试。&lt;/p&gt;
&lt;p&gt;GFS追加有两个特色：流水线及分离数据流和控制流。流水线操作可以减少延时。分离数据流和控制流主要为了优化数据传输，每一台机器都是把数据发送给网络拓扑图上”最近“的尚未收到数据的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4容错机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）Master容错&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Master容错通过操作日志加checkpoint的方式进行，并有一台称为“Shadow Master”的实时热备&lt;/em&gt;。Master的修改操作总是先记录操作日志，然后修改内存。当Master发生故障重启时，可以通过磁盘中的操作日志恢复内存中的数据结构。与此同时，为了减少Mater宕机的恢复时间，Master定期将内存中的数据以checkpoint文件的形式转储到磁盘中，从而减少回放的日志量。为了进一步提供Master的可靠性和可用性，所有的元数据修改操作都必须保证发送到实时热备才算成功。&lt;/p&gt;
&lt;p&gt;补充知识：&lt;strong&gt;元数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主控服务器存储三种主要类型的元数据：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件和chunk命名空间&lt;/strong&gt;，也就是整个文件系统的目录结构以及chunk基本信息；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件和chunk的映射关系&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个chunk副本的位置信息&lt;/strong&gt;，默认情况下，每个chunk有三个副本。&lt;/p&gt;
&lt;p&gt;所有的元数据都保存在Master服务器的内存中。同时，前两种类型的元数据（文件和chunk命名空间，文件和chunk映射关系）也会以记录的方式记录在操作系统的系统日志中，并存储在持久化介质上，另外，日志会复制到其他远程的主控服务器上进行热备。这样做的目的是，提供简单的可靠性，保证主控服务器崩溃的情况下数据的一致性。&lt;/p&gt;
&lt;p&gt;每个chunk的元数据不超过64字节。那么1PB数据的chunk元数据大小不超过1PB x 3 / 64MB x 64 = 3GB。&lt;/p&gt;
&lt;p&gt;2）ChunkServer容错&lt;/p&gt;
&lt;p&gt;简单来讲，ChunkServer容错包括 &lt;strong&gt;副本&lt;/strong&gt; 和 &lt;strong&gt;校验和&lt;/strong&gt; 两种方式。GFS采用复制多个chunk副本的方式实现ChunkServer容错，每个chunk的多个存储副本分别存储在不同的ChunkServer上。对于每个chunk，必须将所有的chunk副本全部写入成功，才视为成功写入。若出现某个副本丢失或者不可恢复时，Master自动将副本复制到其他ChunkServer，确保副本保持一定的个数。ChunkServer会对存储的数据维持校验和。每个64MB大小的chunk以Blok单位进行划分，Block大小为64KB，每个Block对应一个32位的校验和。若读取一个chunk副本时，ChunkServer通过读取数据和校验和进行比较，如果不匹配，则返回错误，客户端将选择其他ChunkServer上的副本。&lt;/p&gt;
&lt;h3&gt;3 Master设计&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;3.1名称空间和锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在逻辑上，GFS的名称空间是一个全路径和元数据映射关系的查找表(前缀压缩)。在存储名称空间的树型结构上，每个节点都有一个关联的读写锁。例如，一个操作设计/d1/d2/.../dn/leaf，那么操作首先获得目录/d1, /d1/d2, ..., /d1/d2/.../dn的读锁，以及/d1/d2/.../dn/leaf的读写锁。&lt;/p&gt;
&lt;p&gt;演示：/home/user被快照到/save/user，如何防止创建文件/home/user/foo&lt;/p&gt;
&lt;p&gt;1)快照操作获取/home和/save的读取锁，以及/home/user和/save/user的写入锁&lt;/p&gt;
&lt;p&gt;2）文件创建操作获取/home和/home/user的读取锁，以及/home/user/foo的写入锁&lt;/p&gt;
&lt;p&gt;两个操作要顺序执行，因为它们试图获取的/home/user的锁是相互冲突的。文件创建操作不需要获取父目录的写入锁，文件名的读取锁足以防止父目录被删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：支持同一目录的并行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;chunk副本位置选择的策略服务于两个目标：最大化数据可用性和可靠性，最大化网络带宽利用率。&lt;strong&gt;多个机架间分布存储chunk副本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;系统中需要创建chunk副本的三种情况：chunk创建，chunk复制以及负载均衡。&lt;/p&gt;
&lt;p&gt;当Master创建一个chunk，它会根据一下策略选择chunk副本的位置：1）用ChunkServer的磁盘利用率较低(比如低于平均水平)存储新的副本；2）限制每个ChunkServer“最近”创建的数量；3）每个chunk的所有副本不能在同一个机架上。关于第二点，如果不限制”最近“创建的数量，当一台空的ChunkServer上线时，由于磁盘利用率低，会造成大量的数据迁移。&lt;/p&gt;
&lt;p&gt;最后，Master会定期扫描当前的副本的分布情况，当出现磁盘使用量或负载不均衡时，将执行重新负载均衡操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3垃圾回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GFS采用延迟删除机制，即当删除文件后，GFS并不要求立即归还可用的物理存储，而是在元数据中将文件改为一个隐藏的名字，并且包含一个删除时间戳。Master定期检查，如果发现文件删除超过一定的时间(默认三天)，那么它会把文件从内存元数据中删除。之后，在ChunkServer和Master的心跳信息中，每一个ChunkServer都将报告自己的chunk集合，Master回复在元数据中已经不存在的chunk信息，进而ChunkServer释放chunk副本空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.4快照&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快照(Snapshot)操作是对源文件/目录进行一个”快照“操作，生成该时刻源文件/目录的一个瞬间状态存放在目标文件/目录中。GFS中使用标准的写时复制机制生成快照，即只是增加GFS中chunk的引用计数。对某个文件执行快照的大致如下：&lt;/p&gt;
&lt;p&gt;1）通过租约机制回收对文件的每个chunk的写权限，停止对文件的写服务；&lt;/p&gt;
&lt;p&gt;2）Master拷贝文件名等元数据生成一个新的文件快照；&lt;/p&gt;
&lt;p&gt;3）对执行快照的文件的所有chunk增加引用计数。&lt;/p&gt;
&lt;h3&gt;4 ChunkServer的设计&lt;/h3&gt;
&lt;p&gt;ChunkServer管理大小为64MB的chunk，存储的时候需要保证chunk尽可能均匀地分布在不同的磁盘中。&lt;/p&gt;
&lt;h3&gt;基本知识点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;chunk尺寸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GFS系统中chunk的大小是64MB。每个chunk的副本都以普通Linux文件的形式保存在CS服务器中。采用较大的chunk尺寸具有以下优点：1）可以减少客户端与主控服务器的请求次数。只需要一次与主控服务器的交互就可以获取chunk的位置信息，然后缓存到客户端，之后就可以对同一个chunk进行多次读写操作。2）因为客户端能够对一个chunk进行多次操作，客户端与数据块服务器保持较长时间的TCP连接，可以减少网络负载。3）一定程度上减少了主控服务器中需要保存的元数据的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;chunk位置信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主控服务器并不持久化保存数据块服务器中的chunk信息，而是在启动时轮询数据块服务器以获取这些信息，并且周期性地通过心跳信息监控数据块服务器的状态。这样做的目的是 &lt;strong&gt;在数据块服务器加入集群，离开集群，更名，失效，以及重启的时候，主控服务器可以保证与数据块服务器中chunk信息的一致性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主控服务器在日志增长到一定量时对系统状态做一次checkpoint，将所有的状态数据写入一个checkpoint文件。在灾难恢复的时候，主控服务器通过读取磁盘上的checkpoint文件，以及重演checkpoint之后的有限个日志文件就能够恢复系统。checkpoint文件以压缩B树的数据结构存储。&lt;/p&gt;</content><category term="Google"></category><category term="Distributed Systems"></category></entry><entry><title>深入理解Paxos算法</title><link href="www.subond.com/pages/2017/03/21/learn-paxos-in-distributed-system.html" rel="alternate"></link><published>2017-03-21T00:00:00+08:00</published><updated>2017-03-21T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-03-21:www.subond.com/pages/2017/03/21/learn-paxos-in-distributed-system.html</id><summary type="html">&lt;p&gt;Paxos算法是Leslie Lanmport(2013年获图灵奖)在1990年提出的一种基于消息传递的共识算法(也称为，一致性算法)，由于算法难以理解并没有被ACM TOCS发表。直到1998年，才引起人们的注意，Lanmport重新发表文章。为了便于人们通俗地理解Paxos算法，Lanmport于2001年简化原来的文章，发表了&lt;a href="http://on64c9tla.bkt.clouddn.com/2017A/paxos-simple-Copy.pdf"&gt;Paxos Made Simple&lt;/a&gt;，文章循序渐进地推导出了Paxos算法，并用数学归纳法进行了证明。在此基础上，本文结合Paxos Made Simple，与其他优秀的Paxos算法解读，重新描述Paxos协议，希望可以深入理解基本的Paxos算法理论。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.Paxos算法&lt;/h2&gt;
&lt;p&gt;Paxos算法是Leslie Lanmport(2013年获图灵奖)在1990年提出的一种基于消息传递的共识算法(也称为，一致性算法)，由于算法难以理解并没有被ACM TOCS发表。直到1998年，才引起人们的注意，Lanmport重新发表文章。为了便于人们通俗地理解Paxos算法，Lanmport于2001年简化原来的文章，发表了&lt;a href="http://on64c9tla.bkt.clouddn.com/2017A/paxos-simple-Copy.pdf"&gt;Paxos Made Simple&lt;/a&gt;，文章循序渐进地推导出了Paxos算法，并用数学归纳法进行了证明。在此基础上，本文结合Paxos Made Simple，与其他优秀的Paxos算法解读，重新描述Paxos协议，希望可以深入理解基本的Paxos算法理论。&lt;/p&gt;
&lt;p&gt;Paxos算法解决的问题是一个分布式系统中如何就某个值(或协议)达成一致。在一个分布式系统中，如果各节点的初始状态一致，每个节点都执行相同的操作，那么他们最后的得到的也是一个一致的状态。一个分布式系统中，通常包含一个主节点和多个备节点。为了保证每个节点执行相同的操作指令，需要每一条执行执行一个“一致性算法”来选举出主节点，进而保证每个节点得到的指令一致。这是一个分布式系统中的重要问题。&lt;/p&gt;
&lt;h2&gt;2.基本概念&lt;/h2&gt;
&lt;p&gt;Paxos算法中有三种角色：&lt;em&gt;Proposer&lt;/em&gt;, &lt;em&gt;Acceptor&lt;/em&gt;, &lt;em&gt;Learner&lt;/em&gt;。每个节点需要同时扮演 &lt;strong&gt;两种或两种以上的角色&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Proposal Value: 提议的值　　&lt;/li&gt;
&lt;li&gt;Proposal Number: 提议编号，并且要求提议编号不能冲突　　&lt;/li&gt;
&lt;li&gt;Proposal: 提议　=　提议编号 + 提议的值　　&lt;/li&gt;
&lt;li&gt;Proposer: 提议发起者　　&lt;/li&gt;
&lt;li&gt;Acceptors: 提议接受者　　&lt;/li&gt;
&lt;li&gt;Learners: 提议学习者　　&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，Proposer有两种行为，一个是向Acceptors发起Prepare请求，另一个是向Acceptors发起Accept请求。Acceptors则根据协议规则或(自身状态)对Proposers的请求做出应答。Learners根据Acceptors的状态，学习最终被确定的值。&lt;/p&gt;
&lt;h2&gt;3.两个原则&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1安全原则&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只能(而且必须)允许一个值被选定；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个节点只能学习已经被选定的值；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;2存活原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要多数节点存活，并且彼此可以通信，则会达成以下两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最终会选定某个提议的值　　&lt;/li&gt;
&lt;li&gt;一个被选定的值，其他节点最终会学习到这个值　　&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;4.算法过程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第一阶段A&lt;/strong&gt;，即Prepare阶段&lt;/p&gt;
&lt;p&gt;Proposer选择一个提议编号n，向所有的Acceptors发送(广播)Prepare(n)请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段B&lt;/strong&gt;，即Prepare阶段&lt;/p&gt;
&lt;p&gt;Acceptor接收到Prepare(n)请求后，若提议编号比之前接收的Prepare提议编号都要大，则做出如下承诺：即不会在接收比n小的提议，并携带之前Accept的提议中编号小于n的最大值的提议，否则不予理会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段A&lt;/strong&gt;，即Accept阶段&lt;/p&gt;
&lt;p&gt;Proposer接收到多数Acceptors的承诺后，如果没有一个Acceptor接受过这个值，则向所有的Acceptors的发起自己的值和提议编号，否则从接受过的值中选择对应的提议编号最大的那个值，作为提议的值，提议编号仍为n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段B&lt;/strong&gt;，即Accept阶段&lt;/p&gt;
&lt;p&gt;Acceptor接收到Accept请求后，如果该提议编号不违反自己的做过的承诺，则接受提议。&lt;/p&gt;
&lt;p&gt;&lt;img alt="paxos-protocolflow" src="http://on64c9tla.bkt.clouddn.com/2017A/paxos.png"&gt;&lt;/p&gt;
&lt;p&gt;需要说明是，Proposer发出Prepare请求后，得到多数派的应答，然后再选择一个多数派广播Accept请求，而不一定是将Accept请求发给有应答的Acceptor。这样做的原因是，Prepare阶段得到只是Proposal number 和 Proposal value，而一个值最终是否被选定，还需要Accept阶段的验证。&lt;/p&gt;
&lt;p&gt;当一个提议被多数接受后，这个提议的值就被选定choesn，一旦有一个值被选定，那么只有按协议的规则继续演进，后续被选定的值也是同一个值。这就是chosen的一致性问题。&lt;/p&gt;
&lt;h2&gt;5.算法证明&lt;/h2&gt;
&lt;p&gt;其实，Paxos算法是一个非常确定的数学问题，可以用数学语言表达，进而用严谨的数学逻辑进行证明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paxso算法原命题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个提议{n0,v0}被多数Acceptors所接受，那么不存在提议{n1,v1}被多数Acceptors接受，其中n0 &amp;lt; n1,v1 != v0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paxso算法原命题加强&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个提议{n0,v0}被多数Acceptors所接受，那么不存在Acceptors接受提议{n1,v1}，其中n0 &amp;lt; n1, v1 != v0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paxso算法原命题进一步加强&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个提议{n0,v0}被多数Acceptors所接受，那么不存在Proposer发出提议{n1,v1}，其中n0 &amp;lt; n1, v1 != v0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;归纳法证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设，提议{m, v}(简称m)被多数派接受，那么提议m到n(n &amp;gt;= m)，对应的值也是v。对n进行归纳假设。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;n = m时，显然结论成立。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设n = k时，结论成立，即如果提议(m, v)被多数派接受，则提议m到k对应的值为v。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当n = k + 1时，若提议k+1不存在，则结论成立。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，证明提议提议k+1不存问题。&lt;/p&gt;
&lt;p&gt;假设，提议k+1存在，对应的值为v1。因为提议m被多数派接受，又因为提议k+1的Prepare请求被承诺并返回结果。&lt;strong&gt;两个多数派必有交集&lt;/strong&gt;，那么提议k+1的第一阶段B必有提议带回来，那么v1就是从返回的提议中选择出来的，设v1对应的提议编号为t。根据第二阶段B可知，t是返回的提议编号最大的一个，因此t&amp;gt;=m。又因为第一阶段A，t&amp;lt;n。根据假设,t对应的值也是v，即v1 = v。所以，n=k成立时，n=k+1也成立。&lt;/p&gt;
&lt;h2&gt;6.示例演示&lt;/h2&gt;
&lt;p&gt;为了便于理解，记(n,v)为提议编号为n,提议的值为v的提议，(m,(n,v))为承诺了Prepare(m)请求，并接受了提议(n,v)。&lt;/p&gt;
&lt;p&gt;&lt;img alt="simple-paxos" src="http://on64c9tla.bkt.clouddn.com/2017A/simple-paxos.png"&gt;&lt;/p&gt;
&lt;h2&gt;7.小结&lt;/h2&gt;
&lt;p&gt;通过前面的讨论和学习，我们可以回顾一下协议的细节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为什么要被大多数接受？因为两个多数派必有交集，所以一般是奇数个(2n+1)Acceptors，然后允许最多n个Acceptors宕机，而保证算法仍然可以正常运行，最终得到一个确定的chosen值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么需要做一个承诺？首先，可以保证第二阶段A的Proposer的选择不受未来某个值的影响(因为对方已经给出了承诺)；其次，对于每一个Acceptors而言，承诺决定了它回应提议编号较大的Prepare请求，和接受提议编号较小的Accept请求的先后顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么第二阶段A要从返回的提议编号中选取最大的一个？这样选出来的提议编号一定不小于已经被多数派接受的提议编号，进而可以保证该提议编号对应的那个值是chosen的那个值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;"与其预测未来，不如限制未来"&lt;/strong&gt;,应该是Paxos协议的核心思想。——郑建军(微信工程师)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Leslie Lanmport:&lt;a href="http://on64c9tla.bkt.clouddn.com/2017A/paxos-simple-Copy.pdf"&gt;Paxos Made Simple&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Info架构师2017年1月刊:&lt;a href="http://www.infoq.com/cn/minibooks/architect-201701"&gt;微信PaxsoStore:深入浅出Paxos算法协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/zhengran/p/4212502.html"&gt;一步一步理解Paxos算法&lt;/a&gt;&lt;/p&gt;</content><category term="Algorithm"></category><category term="Distributed Systems"></category></entry><entry><title>初识Open Source MANO</title><link href="www.subond.com/pages/2016/12/03/introduction-about-osm.html" rel="alternate"></link><published>2016-12-03T00:00:00+08:00</published><updated>2016-12-03T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-12-03:www.subond.com/pages/2016/12/03/introduction-about-osm.html</id><summary type="html">&lt;p&gt;Open Source Management and Orchestration (MANO)，简称Open Source MANO,即OSM，是一个开源社区，旨在为NFV提供满足商用NFV网络需求的生产质量(production-quality)的MANO软件堆栈，具有创建商用公开发布信息的模型能力，适用于所有所有人，适用于所有的VNFs(虚拟网络功能)，而且更重要的是，小操作与VIM(Virtual Infrastructure Management,虚拟基础设施管理)无关。OSM与NFV ISG信息模型保持一致，同时能够根据其实施经验提供第一手的反馈。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.Open Source MANO&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://on64c9tla.bkt.clouddn.com/2016D/OSM-logo.png" align="left"&gt;Open Source Management and Orchestration (MANO)，简称Open Source MANO,即OSM，是一个开源社区，旨在为NFV提供满足商用NFV网络需求的生产质量(production-quality)的MANO软件堆栈，具有创建商用公开发布信息的模型能力，适用于所有所有人，适用于所有的VNFs(虚拟网络功能)，而且更重要的是，小操作与VIM(Virtual Infrastructure Management,虚拟基础设施管理)无关。OSM与NFV ISG信息模型保持一致，同时能够根据其实施经验提供第一手的反馈。&lt;/p&gt;
&lt;p&gt;MANO致力于“管理和编排”，是ETSI NFV定义的架构框架的功能模块的一部分。如图1-1所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="nfv-architecture" src="http://on64c9tla.bkt.clouddn.com/2016D/etsi_nfv_architecture.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;图1-1 ETSI NFV系统架构&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;如前所述，ETSI NFV架构框架的两个关键组件就是NFV Orchestrator和VNF Manager,称为NFV MANO。另外，对于管理人员来说，还需要其他层(比如服务编排)，才能够启动真正的NFV服务。开源软件可以促进ETSI对NFV架构的实现，向ETSI ISG NFV提供实用和基本的反馈，并增加NFV实现之间的互操作性和可能性。&lt;/p&gt;
&lt;p&gt;OSM Release ONE已经经过设计、测试和记录，可以实现快速安装，并创建一个可扩展和互操作的开放MANO环境。它极大地增强了与其他组件(VNFs,VIMs,SDN控制器)的互操作性，可以创建一个(plug-in)框架来进行平台维护和扩展，使得技术的提供和支持更加容易。此外，Release ONE提高了管理员和开发人员的在可用性和安装过程中体验，以及增强了NFV和网络服务的建模能力。为了符合OSI开源工程的目标，这种建模输出工作将会贡献到ETSI NFV中。Release ONE也提供了极其灵活的虚拟化网络功能(VNF)配置和高级网络管理，以及改进的故障排除功能和高级日志记录。白皮书中概括了OSM的主要框架，开发的新功能以及Release ONE部分开放内容。&lt;/p&gt;
&lt;p&gt;Open Source MANO白皮书地址&lt;a href="https://osm.etsi.org/images/OSM-Whitepaper-TechContent-ReleaseONE-FINAL.pdf"&gt;OSM-Whitepaper-TechContent-ReleaseONE-FINAL.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;安装OSM&lt;/h2&gt;
&lt;h3&gt;1.前期准备/系统要求&lt;/h3&gt;
&lt;p&gt;1) 8 CPUs, 16G RAM, 100GB硬盘以及可用的网络接口；&lt;br&gt;
2) Ubuntu 16.04系统，并配置LXD容器  &lt;/p&gt;
&lt;p&gt;LXD配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt update
sudo apt install zfs lxd
sudo newgrp lxd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来进行lxc初始化设置，使用命令&lt;code&gt;sudo lxd init&lt;/code&gt;,并进行如下设置：&lt;/p&gt;
&lt;p&gt;&lt;img alt="lxd_install" src="http://on64c9tla.bkt.clouddn.com/2016D/lxd_install.png"&gt;&lt;/p&gt;
&lt;p&gt;成功后，会出现以下信息。&lt;/p&gt;
&lt;p&gt;&lt;img alt="lxd_success" src="http://on64c9tla.bkt.clouddn.com/2016D/lxd_successfully.png"&gt;&lt;/p&gt;
&lt;h3&gt;2.从源安装OSM&lt;/h3&gt;
&lt;p&gt;安装之前，系统需要安装版本控制管理工具git，sudo apt install -y git；接下来，获取安装脚本，进行安装即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget https://osm-download.etsi.org/ftp/osm-1.0-one/install_from_source.sh
chmod +x install_from_source.sh
./install_from_source.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装过程中，需要进行LXD的相关配置，比较简单，可自行设置。我的部分设置如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="step3" src="http://on64c9tla.bkt.clouddn.com/2016D/step3.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step4" src="http://on64c9tla.bkt.clouddn.com/2016D/step4.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step5" src="http://on64c9tla.bkt.clouddn.com/2016D/step5.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step6" src="http://on64c9tla.bkt.clouddn.com/2016D/step6.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step7" src="http://on64c9tla.bkt.clouddn.com/2016D/step7.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step8" src="http://on64c9tla.bkt.clouddn.com/2016D/step8.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step9" src="http://on64c9tla.bkt.clouddn.com/2016D/step9.png"&gt;&lt;/p&gt;
&lt;p&gt;安装成功后，会出现如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt="osm-success" src="http://on64c9tla.bkt.clouddn.com/2016D/lxd_successfully.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://osm.etsi.org/wikipub/index.php/LXD_configuration_for_OSM_release_1"&gt;LXD configuration for OSM release 1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://osm.etsi.org/wikipub/index.php/OSM_Release_ONE"&gt;OSM Release ONE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="OSM架构框图" src="http://on64c9tla.bkt.clouddn.com/2016D/OSMconnectivity1.png"&gt;&lt;/p&gt;</content><category term="NFV"></category><category term="Orchestration"></category><category term="juju"></category></entry><entry><title>读书写作那点事儿</title><link href="www.subond.com/pages/2016/11/15/something-about-reading-and-writing.html" rel="alternate"></link><published>2016-11-15T00:00:00+08:00</published><updated>2016-11-15T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-11-15:www.subond.com/pages/2016/11/15/something-about-reading-and-writing.html</id><summary type="html">&lt;p&gt;知识就是力量，从来都不是一句空话。获取知识的途径有很多，读书无疑是有效的方式之一。那么，有哪些较好的读书路径值得我们参考呢？李笑来老师给出了以下几个方法：1) &lt;strong&gt;泛读，即广泛地阅读&lt;/strong&gt;。尤其是开始的时候，应尽得杂一点，漫无目的地读，慢慢地就会发现读书的乐趣，发现自己感兴趣的点，而后就可以着点而入，深入阅读。这是一个广散网，寻找点的过程。2) &lt;strong&gt;学会挑书，形成自己的书单&lt;/strong&gt;。总的来说，挑书应该有这样一个原则：能够帮助我们认清现实并思考未来，且具有 &lt;strong&gt;繁殖能力&lt;/strong&gt; 的书。能够帮组我们认清现实并有所思考的书多为非虚构类的书，这一类书可以往往能够就某一问题，或某一现象，甚至某个学科做较为深入的分析与探讨，是我们了解当下现实的基础，而书中关于这些问题的讨论有可以启发我们对未来的思考。具有繁殖能力的知识，往往是那些能够激发我们阅读欲望，探索问题解决之道；亦或与我们原有的知识形成冲突，或者形成补充的知识，这是一个不断发现其他点，形成星星之火的过程。3) &lt;strong&gt;建立检索书库，方便日后查询&lt;/strong&gt;。选择一款自己喜欢的笔记软件，不断地做好自己的阅读笔记。将阅读过程中发现的亮点和思考，以及相关的书目形成记录。如何做好阅读笔记，这是一个将点连接成线，进而形成一个面的过程。4) &lt;strong&gt;杂读，尽量涉及更多的领域和学科&lt;/strong&gt;。想要获得一些意外的收获，杂读就是一个很好的方法。用自己原有的专业知识及系统去接触一个相对陌生的领域和学科，往往可以碰撞出不一样的火花。这是一个发现其他面的过程，并产生面与面交集的过程。&lt;/p&gt;</summary><content type="html">&lt;p&gt;这是一篇关于读书写作的读书笔记，内容源自李笑来老师知乎Live的《我的读书经验》。&lt;/p&gt;
&lt;h3&gt;关于读书路径&lt;/h3&gt;
&lt;p&gt;知识就是力量，从来都不是一句空话。获取知识的途径有很多，读书无疑是有效的方式之一。那么，有哪些较好的读书路径值得我们参考呢？李笑来老师给出了以下几个方法：&lt;/p&gt;
&lt;p&gt;1) &lt;strong&gt;泛读，即广泛地阅读&lt;/strong&gt;。尤其是开始的时候，应尽得杂一点，漫无目的地读，慢慢地就会发现读书的乐趣，发现自己感兴趣的点，而后就可以着点而入，深入阅读。这是一个广散网，寻找点的过程。&lt;/p&gt;
&lt;p&gt;2) &lt;strong&gt;学会挑书，形成自己的书单&lt;/strong&gt;。总的来说，挑书应该有这样一个原则：能够帮助我们认清现实并思考未来，且具有 &lt;strong&gt;繁殖能力&lt;/strong&gt; 的书。能够帮组我们认清现实并有所思考的书多为非虚构类的书，这一类书可以往往能够就某一问题，或某一现象，甚至某个学科做较为深入的分析与探讨，是我们了解当下现实的基础，而书中关于这些问题的讨论有可以启发我们对未来的思考。具有繁殖能力的知识，往往是那些能够激发我们阅读欲望，探索问题解决之道；亦或与我们原有的知识形成冲突，或者形成补充的知识，这是一个不断发现其他点，形成星星之火的过程。&lt;/p&gt;
&lt;p&gt;3) &lt;strong&gt;建立检索书库，方便日后查询&lt;/strong&gt;。选择一款自己喜欢的笔记软件，不断地做好自己的阅读笔记。将阅读过程中发现的亮点和思考，以及相关的书目形成记录。如何做好阅读笔记，这是一个将点连接成线，进而形成一个面的过程。&lt;/p&gt;
&lt;p&gt;4) &lt;strong&gt;杂读，尽量涉及更多的领域和学科&lt;/strong&gt;。想要获得一些意外的收获，杂读就是一个很好的方法。用自己原有的专业知识及系统去接触一个相对陌生的领域和学科，往往可以碰撞出不一样的火花。这是一个发现其他面的过程，并产生面与面交集的过程。&lt;/p&gt;
&lt;h3&gt;读书的目的&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;读书，为了改变生活&lt;/strong&gt;。宋真宗赵恒在《励学篇》言道：安居不用架高楼，书中自有黄金屋；娶妻莫恨无良媒，书中自有颜如玉。虽说有些功利化，但读书就是可以改变我们的生活。这种改变往往并不是直接地改变我们一些什么，而是通过间接的方式。书，带给我们新的知识，新的思维，甚至新的思考方式；带给我们不曾认识或者不能正确认识的专业及领域，潜移默化地影响着我们的生活及工作，慢慢地某些东西就刻在了我们的骨子里，让我们终生受用。&lt;/p&gt;
&lt;h3&gt;升级阅读方法&lt;/h3&gt;
&lt;p&gt;通过前面的介绍，我们认识了读书路径，知道了读书的目的。那么，什么的阅读方法才算有效的阅读呢？关于这一点，以下原则值得参考：&lt;/p&gt;
&lt;p&gt;1) &lt;strong&gt;只字不差，反复阅读&lt;/strong&gt;。限于我们每个人不同的专业背景及知识阅历，也限于我们现有的水平，我们不太可能，甚至不可能了解所有的行业和学科，所以 &lt;strong&gt;一本书，只要必要，即便是读不懂，也要读完&lt;/strong&gt;。说不定哪一天，书中某个点就激发我们新的思考。&lt;/p&gt;
&lt;p&gt;2) &lt;strong&gt;翻看书评，以书会友&lt;/strong&gt;。莎士比亚曾言：There are a thousand Hamlets in a thousand people's eyes(一千个读者就有一千个哈姆雷特)。通过阅读他人关于一本书的思考，我们看到另一个角度的阐释。这份阐释也许跟我们自己的理解有所冲突，也许互为补充，也许高于我们的见识，也许低于我们的见识，这不正是读书的意义嘛。&lt;/p&gt;
&lt;p&gt;3) &lt;strong&gt;持续写作，有效输出&lt;/strong&gt;。写作，是提高阅读能力的有效工具。&lt;strong&gt;教，是最有效的学习&lt;/strong&gt;。当我们能够产生输出的时候，才算是内化到我们自己系统的东西。最初写作的时候，可能写得并不好，也没有那么完善，但是一定要保证它是完整的。之后，再通过不断地完善和补充，形成好的作品。另外，当我们写作的时候，才可以像作者一样阅读，明确自己的写作意图，梳理其中的逻辑关系，补充论据的支撑点。最后，还有更重要的一点：&lt;strong&gt;写作，目的只有一个——讲清楚一件事&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;关于现代阅读的&lt;/h3&gt;
&lt;p&gt;如何对待碎片化阅读？&lt;/p&gt;
&lt;p&gt;信息社会的发展，不断涌现的智能终端，几乎可以让我们随时随地地阅读；刷微博，刷微信，几乎也占据了我们大部分的闲暇时间，这样碎片化的信息对我们有多大意义呢？其实，意义不大。建议就是：&lt;strong&gt;形成固定的阅读时间&lt;/strong&gt;。在固定的时间里阅读，与书对话，充分享受思想的碰撞，知识的更新。&lt;/p&gt;
&lt;p&gt;读书带来的价值有多少？&lt;/p&gt;
&lt;p&gt;一个人的价值又有多大？李笑来给出这样一个公式：&lt;code&gt;一个人的价值＝有效集中注意力解决问题的时间×待解决问题被世界所需要的程度&lt;/code&gt;。其实，一本书的目的无非也是阐述一件事情而已。因此，我们可以大致用这样的一个公式来判断一本的价值：&lt;code&gt;一本书的价值＝有效解决问题的时间×对于待解决问题书中知识的重要程度&lt;/code&gt;。有效解决问题的时间可以理解成我们从书中获取有效知识或者方法，并进行有效应用的时间，所以查看阅读一些知识干货可以节省大量的时间，作为牺牲，我们也错失了从整体把握书的结构，系统，逻辑关系等等。书中知识的重要程度是指该类知识对于解决这类问题的有效程度。有这样一个事实我们不得不承认，那就是：&lt;strong&gt;对于某一特定的问题的解决方法不尽相同，所涉及的知识也不尽相同，那么找出其中至关重要的点，才是解决问题的根本。这些至关重要的点正是知识的重要程度&lt;/strong&gt;。一旦找到那个至关重要的点，问题也就迎刃而解了。&lt;/p&gt;
&lt;p&gt;那么，从工作实践的角度来讲，这种方法类似于采铜在《精进，如何成为一个很厉害的人》所讲的&lt;a href="G05.md"&gt;任务分解：让你的工作更高效&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;读书一定需要安静的地方吗？&lt;/p&gt;
&lt;p&gt;不是。阅读需要被锻炼的一个重要能力恰恰是：&lt;strong&gt;不被打扰的能力&lt;/strong&gt;。当处在嘈杂的环境时我们依然可以不被打扰的阅读，这样你就可以发现在火车上，在飞机上，在一切纷杂的地方依然可以保持自己的阅读。&lt;/p&gt;
&lt;p&gt;纸质书还是电子书？依据个人喜好，自行选择。&lt;/p&gt;
&lt;h3&gt;一点个人的分享&lt;/h3&gt;
&lt;p&gt;关于读书路径。&lt;strong&gt;可以适当地阅读自己感兴趣的书籍&lt;/strong&gt;。我第一次听到&lt;a href="http://baike.baidu.com/link?url=Rw3AuWewnKjf7ErRS6EHVrqjOn_HUVw5Y2u22jqxn4UOqnvIowi7hZhX_JSLpZkBhceAFGJpe0oULgLkmsCoFK-4u8dGwx7WysGjg9CX_URWjj5VUhVQjwyIU6FCkjFT"&gt;吴晓波&lt;/a&gt;的名字应该是在罗辑思维公众号，而恰巧自己对经济学也颇有兴趣。于是，利用寒假和开学的一段时间读完了吴晓波老师的《激荡三十年》，《历代经济变革得失》和《把生命浪费在美好的事物上》。其中的收获也很多，但是限于自己那个时候并没有良好的阅读写作习惯，没能及时梳理读书笔记，甚是遗憾，后续会整理出来。在我为数不多的阅读经历里，这算是一个有针对性的阅读体验，虽然跟自己本身的专业并不相关，但是读后的收获对一个人的帮助很大。去尝试那些跟自己不相关的领域，仅凭兴趣去阅读，就会发现不一样的世界。当你又一次类似的阅读体验时，你就会爱上它。真的。&lt;/p&gt;
&lt;p&gt;其次，&lt;strong&gt;适时地给自己一些随机性阅读&lt;/strong&gt;。2016年６月份，新世相(微信公众号：thefair2)发起了一场“新世相·图书馆”活动，其目的就是重拾阅读的乐趣。其活动规则是：一个月四本书，随机发送，读完并退回，退还押金。其中，给我印象最深的两本书是《股票大作手回忆录》和《黑客与画家》，让我深刻认识到原来钱还可以这么玩，黑客的精神一直都在。这次的随机阅读之旅也带来了意外的收获，有幸认识了一位优秀的博客作者&lt;a href="http://baike.baidu.com/link?url=PZ71FiEesaVkYuRGlUQwRqtQGhu0y6xqXI5LaXhuTXzpIR07c-Ho0qusoP0D_bxJ5SXbTLsFhSQK-UgNYquXh0M458T1jdz4qy3DPC185HODWbccJVE8PTqfYN9WBJSQ"&gt;池建强&lt;/a&gt;老师，并拜读了其所作的《MacTalk·人生元编程》和《MacTalk·跨越边界》，感受到技术与人文的魅力，也更加坚定了写作记录的想法。&lt;/p&gt;
&lt;p&gt;关于持续写作。从我最近的实践来看，写作确实可以很好地梳理文章的脉络，整理自己的思考。不过，初步写作也存在不少问题，主要集中在以下两点：&lt;em&gt;1) 用简洁的语言将一件事情说清楚并不是那么容易，能够准确地表达自己更不容易；2) 逻辑思维不够清晰&lt;/em&gt;。针对以上两点，我采取的策略是在读书的过程中多注意作者的语言组织及表述技巧，经常反复阅读自己的读书笔记，不断打磨。每一次读，你都会有不一样的发现&lt;/p&gt;
&lt;p&gt;一点的个人分享，从读书路径的角度来说，也只能说是入门而已，还有很长的路要走。&lt;/p&gt;</content><category term="Life"></category><category term="Writing"></category><category term="Reading"></category></entry><entry><title>云端服务管理工具:Juju</title><link href="www.subond.com/pages/2016/11/10/juju-charm-mechanism.html" rel="alternate"></link><published>2016-11-10T00:00:00+08:00</published><updated>2016-11-10T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-11-10:www.subond.com/pages/2016/11/10/juju-charm-mechanism.html</id><summary type="html">&lt;p&gt;Juju是Canonical公司提供的服务编排工具。它是Ubuntu云套件的一部分，与Ubuntu服务器、OpenStack、用于裸机配置的MAAS 、以及用于系统管理和监控的Landscape一起组成Ubuntu云套件。同时，Juju也是 开源的，向用户提供一种面向服务的架构(service oriented architecture)和面向应用的部署(application oriented deployments)的通用模型。Juju可以对云端的服务进行快速可靠的部署，包括拓展云端业务，因此管理员可以很容易地部署Wordpress博客系统，MongoDB大系统管理系统、Mysql数据系统等。目前Juju具有1.25(稳定版)和2.0(升级版)，用户可以自行选择。关于Juju的安装比较简单， 可以参考官网教程。Juju为用户提供了命令行和图形化界面两种方式来进行业务部署，其图形化界面称为"juju-gui"(可利用juju部署到本地系统,juju deploy juju-gui)。&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1.Juju介绍&lt;/h3&gt;
&lt;p&gt;Juju是Canonical公司提供的服务编排工具。它是Ubuntu云套件的一部分，与Ubuntu服务器、OpenStack、用于裸机配置的MAAS 、以及用于系统管理和监控的Landscape一起组成Ubuntu云套件。同时，Juju也是 开源的，向用户提供一种面向服务的架构(service oriented architecture)和面向应用的部署(application oriented deployments)的通用模型。Juju可以对云端的服务进行快速可靠的部署，包括拓展云端业务，因此管理员可以很容易地部署Wordpress博客系统，MongoDB大系统管理系统、Mysql数据系统等。目前Juju具有1.25(稳定版)和2.0(升级版)，用户可以自行选择。关于Juju的安装比较简单， 可以参考官网教程&lt;/p&gt;
&lt;p&gt;Juju为用户提供了命令行和图形化界面两种方式来进行业务部署，其图形化界面称为"juju-gui"(可利用juju部署到本地系统,juju deploy juju-gui)。&lt;/p&gt;
&lt;h3&gt;2.Juju的运作方式&lt;/h3&gt;
&lt;p&gt;Juju进行运作要具备以下三个因素：
1) &lt;strong&gt;Juju Client&lt;/strong&gt;
Juju Client端在不同的平台都有(Ubuntu/OXS/Windows)，以Ubuntu为例，Juju Client套件名为juju-core。
2) &lt;strong&gt;Ubuntu Image环境(也成为Ubuntu Server,可根据需求设定)&lt;/strong&gt;
一般的公有云都可以提供这样的环境，例如OpenStack,Amazon EC2,Microsoft Azure。当然，也可以搭配Ubuntu MAAS环境进行搭建。
3) &lt;strong&gt;SSH key pair&lt;/strong&gt;
SSH key pair是用来控制Ubuntu Server，可利用一对SSH key pair登入至Ubuntu Server环境，并进行Service Orchestration操作。&lt;/p&gt;
&lt;h3&gt;3.Juju本地环境配置&lt;/h3&gt;
&lt;p&gt;Juju是为云端服务提供管理工具，但是作为初学者我们更多是使用自己的本地环境来学习Juju的相关操作和Charm的编写。下面介绍如何搭建自己的Juju本地环境，以kvm虚拟机为例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装Juju&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-add-repository ppa:juju/stable
sudo apt-get update &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo apt-get -y install juju-core
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;安装本地支持文件以及KVM/libvrt软件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install juju-local qemu-kvm libvirt-bin bridge-utils virt-manager qemu-system uvtool-libvirt uvtool
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;生成配置文件：其路径为:~/.juju/environment.yaml&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju generate-config
juju switch kvm
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;修改配置：在environment.yaml中找到local，进行如下修改：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;local:
      type: &lt;span class="nb"&gt;local&lt;/span&gt;
  kvm:
      type: &lt;span class="nb"&gt;local&lt;/span&gt;
      container: kvm
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;执行，&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju bootstrap
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即可生成本地环境。可使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju status --format tabular
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看状态信息。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="juju_status" src="http://on64c9tla.bkt.clouddn.com/20161110juju_status.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于Juju环境的其他操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="c1"&gt;# 查看环境列表&lt;/span&gt;
  juju env --list
  juju env  // 可查看当前环境名称
  &lt;span class="c1"&gt;# 销毁环境&lt;/span&gt;
  juju destory-environment &lt;span class="o"&gt;[&lt;/span&gt;env_name&lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="c1"&gt;# 设定environment中的VM版本&lt;/span&gt;
  juju set-env &lt;span class="s2"&gt;&amp;quot;default-series=trusty&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设定bootstrap环境&lt;/p&gt;
&lt;p&gt;juju bootstrap用来生成可运行charm的juju环境，可利用-e指定环境名称，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju bootstrap -e my_env
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来，简单说明juju client/juju bootstrap node/cloud provider三者之间的关系。&lt;/p&gt;
&lt;p&gt;1) juju client通过bootstrap指令，在cloud provider上产生一个可用来部署juju charms的bootstrap实例，即juju环境。&lt;/p&gt;
&lt;p&gt;2) juju client通过juju deploy指令，在bootstrap实例上安装指定的charms到cloud provider的VM中。&lt;/p&gt;
&lt;p&gt;3) cloud provider中，既有bootstrap实例，也有charms的实例。&lt;/p&gt;
&lt;p&gt;因此，三者的交互过程具有如下关系：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;juju client &amp;lt; ---- &amp;gt; juju bootstrap instance &amp;lt; ---- &amp;gt; cloud provider&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4.Juju服务编排&lt;/h3&gt;
&lt;p&gt;Juju利用部署服务(Deploy Services)的方式进行服务编排(Service Orchestration)。接下来，说明如何利用juju进行服务部署工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 利用charm Store进行部署&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 利用charm store部署服务，以mysql为例&lt;/span&gt;
juju deploy mysql
&lt;span class="c1"&gt;# 指定serveice版本,格式为:/&lt;/span&gt;
juju deploy cs:precise/mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2) 利用本地charm(Local Charm Repository)部署&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# repository 指定本地charm路径，如/usr/mycharms&lt;/span&gt;
&lt;span class="c1"&gt;# repository name: local&lt;/span&gt;
&lt;span class="c1"&gt;# series: trusty&lt;/span&gt;
&lt;span class="c1"&gt;# service: mysql&lt;/span&gt;
juju deploy --repository&lt;span class="o"&gt;=&lt;/span&gt;/usr/mycharms local:trusty/mysql

&lt;span class="c1"&gt;# 如果预设juju repository的路径&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;JUJU_REPOSITORY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/mycharms/
juju deploy local:trusty/mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3) 利用配置文件进行多个service设定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Juju的配置文件以YAML格式进行撰写，可以在预先设定的配置文件中将charm的相关设定写好，再利用指定配置文件的方式，完成service的部署，从而避免部署指令过长。
例如，部署一个名称mywiki的服务，可预先进行如下设定(myconfig.yaml):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mywiki:
  name: jujuwiki
  skin: monobook
  admin: amdin:admin
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，使用如下指令进行部署：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju deploy --config myconfig.yaml mywiki
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3) 利用constraints个性化部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Juju指令中使用--constraints可在service部署时指定特定的VM规格(cpu, mem, etc)架构。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju deploy --constraints &lt;span class="s2"&gt;&amp;quot;cpu-cores=2 mem=4G&amp;quot;&lt;/span&gt; mysql
juju bootstrap --constraints &lt;span class="s2"&gt;&amp;quot;cpu-power=0 mem=512M&amp;quot;&lt;/span&gt;
juju bootstrap --constraints &lt;span class="s2"&gt;&amp;quot;arch=amd64&amp;quot;&lt;/span&gt;
juju set-constraints --service mysql &lt;span class="nv"&gt;mem&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2G cpu-cores&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;
&lt;span class="c1"&gt;# 获取constraints内容&lt;/span&gt;
juju get-constraints
juju get-constraints mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:每个由juju管理的node(无论实体，还是容器(container))都被视为unit。Unit之间的数据交互，可使用juju相关命令，常用的指令由如下几种：&lt;/p&gt;
&lt;p&gt;登录至某个特定的unit，可使用&lt;code&gt;juju ssh&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 通过unit id或者machine id进行登入&lt;/span&gt;
juju ssh mysql/2
&lt;span class="c1"&gt;# 直接查询某些信息或者执行某些脚本&lt;/span&gt;
juju ssh mysql/2 ifconfig
juju ssh mysql/2 bash /tmp/echo_ip.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件拷贝，可使用&lt;code&gt;juju scp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;juju scp&lt;/code&gt;可以将文件从service宿主的machine或者container中拷贝出来，也可以拷贝进去。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# juju scp中可使用service id，也可以使用machine id&lt;/span&gt;
&lt;span class="c1"&gt;# 将iptables.sh放到mysql服务中的/tmp路径下&lt;/span&gt;
juju scp iptables.sh mysql/2:/tmp
&lt;span class="c1"&gt;# 将mysql服务中的log拷贝至本机&lt;/span&gt;
juju scp -r mysql/2:/var/log/mysql/ mysql_log/
&lt;span class="c1"&gt;# 拷贝两个service中的文件，使用-v&lt;/span&gt;
juju scp -v ubuntu/0:/path/file1 ubuntu/1:/path/file2 backup/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行shell命令，可使用&lt;code&gt;juju run&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;juju run&lt;/code&gt;是以ssh的方式登入至service宿主中执行shell命令，但两者又有不同之处：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;juju run&lt;/strong&gt;:可以同时操控多台机器，可以通过指定machine/service/unit的方式指定机器，也可以使用--all参数指定所有机器或者container进行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;juju ssh&lt;/strong&gt;:可以通过指定machine/service的方式进行操作，但一次只能操作一台机器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 获取所有machine的kernel version&lt;/span&gt;
juju run &lt;span class="s2"&gt;&amp;quot;uname -a&amp;quot;&lt;/span&gt; --all
&lt;span class="c1"&gt;# 指定特定machine or service&lt;/span&gt;
juju run &lt;span class="s2"&gt;&amp;quot;uname -a&amp;quot;&lt;/span&gt; --machine&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;
juju run &lt;span class="s2"&gt;&amp;quot;uname -a&amp;quot;&lt;/span&gt; --service&lt;span class="o"&gt;=&lt;/span&gt;mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;5.Juju Charm的使用&lt;/h3&gt;
&lt;p&gt;Charm是Juju在部署服务/业务时所使用的工具，由一系列的脚本文件组成，用于部署服务单元以及建立服务单元之间的联系。对于用户而言，Charm是开源的，好多优秀的Charm都放在Charm Store上，一个 简单的命令&lt;code&gt;juju deploy mysql&lt;/code&gt;，就可以部署一个简单的数据库服务单元。当然，若是某些Charm不能够满足用户的特殊需求，用户也可以写自己的charm，写好后还可以放到charm Store供别人下载使用。&lt;/p&gt;
&lt;p&gt;Charm是事件驱动(event-driven)型脚本，通过读取/解析juju命令实现服务单元的建立，删除，关系建立等。一个完整的charm文件，包括文件：元数据(metadata.yaml),配置数据(config.yaml)以及与hooks相关的支持文件，如下图所示。&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;&lt;img src="http://on64c9tla.bkt.clouddn.com/20161110charm_tree.png" algin="left"&gt;&lt;/td&gt;
    &lt;td&gt;
      &lt;ul&gt;
        &lt;li&gt;/hooks&lt;/li&gt;
        &lt;p&gt;hooks是一个目录，里面包含可执行文件(脚本)，一般具有特定的名字(与metadata.yaml文件相关，后续介绍)。&lt;/p&gt;
        &lt;li&gt;/actions&lt;/li&gt;
        &lt;p&gt;actions是一个目录，里面包含可执行文件(脚本)，一般具有特定的名字(与juju系统调用相关)。&lt;/p&gt;
        &lt;li&gt;actions.yaml&lt;/li&gt;
        &lt;p&gt;actions.yaml是一个配置文件，当使用目录actions中的脚本时，需要配置actions.yaml文件。&lt;/p&gt;
        &lt;li&gt;config.yaml&lt;/li&gt;
        &lt;p&gt;config.yaml是一个配置文件，与服务配置相关(service/unit)。&lt;/p&gt;
        &lt;li&gt;icon.svg&lt;/li&gt;
        &lt;p&gt;icon.svg是GUI界面中用来识别charm的文件。&lt;/p&gt;
        &lt;li&gt;README&lt;/li&gt;
        &lt;p&gt;README文件主要介绍charm的主要功能，操作，用例等等。&lt;/p&gt;
      &lt;/ul&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;6.Charm之间的关联性&lt;/h3&gt;
&lt;p&gt;每个利用charm部署之后就是一个服务，而服务几乎没有独立运行的，需要不同服务之间的相互协作，建立联系。因此，charm之间的关联性尤为重要。&lt;/p&gt;
&lt;p&gt;juju使用juju add-relation建立服务之间的联系。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju add-relation mysql epc-hss
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至于，为何两个服务之间为何可以添加连接或者不可以添加连接，其实在charm中有所规定，详情可以参见下面的 &lt;em&gt;Charm文件详解&lt;/em&gt;。&lt;/p&gt;
&lt;h3&gt;7.Charm文件详解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;metadata.yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;metadata.yaml中定义了许多charm本身的元信息，位于charm的根目录，必须是有效的yaml文件，且至少要包含以下信息：&lt;/p&gt;
&lt;p&gt;&lt;font color="#ff000000"&gt;name&lt;/font&gt;:即charm的名字，用来标识一个特定的charm,方便从charm store中下载。name的命名只接受'a-z','0-9'以及'-',必须以'a-z'开头，不能以'-'结尾。&lt;/p&gt;
&lt;p&gt;&lt;font color="#ff000000"&gt;summary&lt;/font&gt;:即概要，用一句话描述自己的charm功能。&lt;/p&gt;
&lt;p&gt;&lt;font color="#ff000000"&gt;description&lt;/font&gt;:用来描述charm的功能，特性等，可在Juju GUI中显示。&lt;/p&gt;
&lt;p&gt;&lt;font color="#ff000000"&gt;tags&lt;/font&gt;:charm的标签，方便在charm store中搜索。&lt;/p&gt;
&lt;p&gt;&lt;img alt="metadata_yaml" src="http://on64c9tla.bkt.clouddn.com/20161110metadata_yaml.png"&gt;&lt;/p&gt;
&lt;h3&gt;8.常用功能&lt;/h3&gt;
&lt;p&gt;Juju具有服务扩展(Scaling Service)功能，尤其是在云端环境中，显得更加重要。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju add-unit -n &lt;span class="m"&gt;3&lt;/span&gt; mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;移除功能:不但可以移除servie，还可以移除machine，甚至是整个environment。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 移除service&lt;/span&gt;
juju remove-service
&lt;span class="c1"&gt;# 移除unit&lt;/span&gt;
juju remove-unit
&lt;span class="c1"&gt;# 移除machine&lt;/span&gt;
juju remove-machine
&lt;/pre&gt;&lt;/div&gt;</content><category term="Cloud"></category><category term="Orchestration"></category></entry><entry><title>Reply 1988: 人生是个迷啊</title><link href="www.subond.com/pages/2016/10/07/reply-1988.html" rel="alternate"></link><published>2016-10-07T00:00:00+08:00</published><updated>2016-10-07T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-10-07:www.subond.com/pages/2016/10/07/reply-1988.html</id><summary type="html">&lt;p&gt;人，之所以为人，是因为可以享受生命的意义，生活的乐趣。这是一篇关于韩剧《请回答1988》的观后感。这部剧发生在韩国首尔一个叫做“双门洞”的胡同，讲述了五家人的故事，细致生动地再现了80年代邻里街坊小市民的生活面貌。&lt;strong&gt;整部剧以生活为主线，贯穿亲情，友情，爱情以及邻里情，细致地刻画了那个永远回不去的青春岁月&lt;/strong&gt;。剧中的生活细节做的很足，处处都可以看到编剧和导演的良苦用心。其实，生活无非就是一日三餐，家长里短，却被演员们表现的淋漓尽致，主要集中在以下几个方面。&lt;/p&gt;</summary><content type="html">&lt;p&gt;人，之所以为人，是因为可以享受生命的意义，生活的乐趣。&lt;/p&gt;
&lt;p&gt;这是一篇关于韩剧《请回答1988》的观后感。&lt;/p&gt;
&lt;h2&gt;这部剧讲了啥？&lt;/h2&gt;
&lt;p&gt;&lt;img alt="reply-1988" src="http://on64c9tla.bkt.clouddn.com/2016D/TVN%27s_Reply_1988_poster.jpg"&gt;&lt;/p&gt;
&lt;p&gt;这部剧发生在韩国首尔一个叫做“双门洞”的胡同，讲述了五家人的故事，细致生动地再现了80年代邻里街坊小市民的生活面貌。&lt;strong&gt;整部剧以生活为主线，贯穿亲情，友情，爱情以及邻里情，细致地刻画了那个永远回不去的青春岁月&lt;/strong&gt;。剧中的生活细节做的很足，处处都可以看到编剧和导演的良苦用心。其实，生活无非就是一日三餐，家长里短，却被演员们表现的淋漓尽致，主要集中在以下几个方面：&lt;/p&gt;
&lt;h2&gt;关于亲情&lt;/h2&gt;
&lt;p&gt;剧中宝拉的父亲是一个善良，倔强，喜欢把话放在心里的父亲形象，像很多中国的父亲一样。在自己妈妈去世的那一段，宝拉的父亲白天笑脸招呼客人，晚上独自悲伤，静静地守在灵堂前。直到大哥回来，才好像找到了依靠，不必装作坚强，兄弟姐们四人终于忍不住哭了起来。”大人只是在忍，只是在忙着大人的事，只是在用故作坚强来承担年龄的重担。大人们，也会疼。”&lt;/p&gt;
&lt;p&gt;二十几岁的年龄，或多或少也开始意识并接触到周围亲人的年老，甚至离开。突然之间就发现，原来好多的称呼从此再也叫不出口，而关于那个人的记忆却永远地刻在记忆里。我的爷爷在我父亲18岁的时候，生病去世了。所以从小到大，我没有喊过一声"爷爷"，也从来没有体会过爷爷的爱是一种什么样的爱。小时候不懂事，还吵着向父亲母亲“要过”爷爷。现在想来，那时的父亲想必也是凄苦的。随着年龄的增长，那一声”所谓的称呼”也就越发显得弥足珍贵了，真是应了中国那句老话：喊一声，少一声。&lt;/p&gt;
&lt;p&gt;“上帝不能无处不在，因此他创造了母亲”是一句犹太谚语，是赞美母亲的。其实，父母真的就是子女的守护神。无论孩子在外面受了多大的委屈，只要回家就能感受到温暖，找到了依靠。挫折的时候，给我们鼓励与安慰；迷茫的时候，给我们指引与勇气；给我们追逐梦想的力量。每当我们取得一些成绩的时候，或是夸赞，或是小心翼翼地记录着我们的成长，像阿泽爸那样，把报纸上关于儿子的比赛报道一一剪下，做成册子，细数着儿子每一次的成绩。深沉的大地一样的爱，那是父亲的爱。&lt;/p&gt;
&lt;p&gt;剧中的三位母亲，也是那样的平凡而伟大。没有女儿的豹子夫人，却收获了比女儿还细心的"二女儿"金正焕。知道母亲不懂英文，细心地在母亲的护照上标上注音；知道母亲是操心的命，当发现母亲因为外出探亲而父子三人过得还不错而不免有些失落的时候，故意制造小麻烦，让母亲“回归”；知道父母的结婚照是合成的，精心地为二人准备婚礼。这些小小的细节，足见正焕的用心。90年代我国实行”计划生育”政策，导致我们90后这一代几乎都是独生女子，以至于作为儿子的我们，不得不又当儿子又当“闺女”。&lt;/p&gt;
&lt;p&gt;剧中印象很深的还有的阿泽爸爸和善宇妈妈，两人都有一个好儿子。作为单亲家庭的孩子都很懂事，两个儿子都知道父母亲的不容易，更明白人生的意义。&lt;strong&gt;人各有命，作为孩子尊重父亲，母亲的决定，作为父母也尊重孩子的想法&lt;/strong&gt;。渐渐地发现，生命中的每一个出现在身边的人都有存在的意义。有些话只能对固定的人讲，或者选择不说。丈夫，妻子，邻里，儿子，女儿，朋友···每个人扮演的角色不同，所承载的意义也不同。就像香港电台主持人梁继璋在给儿子的一封信中写到的那样：“亲人只有一次的缘分，无论这辈子我和你相处多久，也请好好珍惜共聚的时光，下辈子，无论爱与不爱，都不会再见”。&lt;strong&gt;今生有幸为家人是最大的幸福&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;关于爱情&lt;/h2&gt;
&lt;p&gt;剧中德善的爱情最引人关注。在不知道结局的时候，个人比较倾向于德善和阿泽这一对儿。原因很简单：&lt;strong&gt;没有所谓的时机，只有更恳切的心&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果今天，我没有被那该死的红绿灯拦住，我可能就会命运般站在她的面前。但是缘分，不是自动找上门的偶然，是带着恳切的盼望做出的无数选择。那家伙更恳切，搞怪的不是红绿灯，而是我数不清的犹豫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是正焕的独白，只可惜明白得太晚了。虽有些让人心疼，可是世事如此。既然喜欢，就要大大方方让对方知道。爱情里，没有尴尬。有些人，总是担心，本来是朋友说破了岂不是很尴尬。其实，今生若不能为爱人，为什么要保持那么亲密的朋友关系呢？为了爱人，失去一个好朋友又怎么样，何况还是异性。&lt;strong&gt;爱人，才是我们一生都要守护的那个人&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;关于友情&lt;/h2&gt;
&lt;p&gt;剧中正焕和阿泽同时喜欢德善，互为情敌。但是有一句台词我很喜欢：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然我和你爱着同一个女人，可是我仍然喜欢你，不愿意让任何不幸发生在你身上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没错，这就是友情。&lt;/p&gt;
&lt;h2&gt;关于人生&lt;/h2&gt;
&lt;p&gt;人生的话题好大，可是细说起来也就那么点。每个人都有自己的选择，都有需要自己独自去面对的时刻，为了不让我们孤单，才拥有了家人，朋友。人生更像是一场修行，能帮到你的也只有 &lt;strong&gt;我们自己&lt;/strong&gt;。善待生命中遇到的每一个人，他们看似无关，却与你有着千丝万缕的牵连，来到你的身边，请珍惜。&lt;/p&gt;
&lt;p&gt;剧中的正峰哥哥也是一个神奇的存在，说实话全剧95%的剧情中我都觉着这是一个多余，直到结尾才发现，这是导演的最后一步棋。正峰哥哥用了七年考大学，用了七年考司法考试，直到遇见真爱，才明白：活着，要做自己想做的事情。最终选择了做美食。&lt;strong&gt;一个人能够发现自己的擅长，并将其培养成自己的工作或者一生的事业，是多么的不容易！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人生最难的在于找到自己。&lt;/p&gt;</content><category term="Life"></category></entry><entry><title>工作中遇到的小技巧</title><link href="www.subond.com/pages/2016/07/12/tip-tools.html" rel="alternate"></link><published>2016-07-12T00:00:00+08:00</published><updated>2016-07-12T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-07-12:www.subond.com/pages/2016/07/12/tip-tools.html</id><summary type="html">&lt;h3&gt;Ubuntu彻底删除Mysql,重装Mysql&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 删除MySQL&lt;/span&gt;
sudo apt-get autoremove --purge mysql-server-5.0
sudo apt-get remove mysql-server
sudo apt-get autoremove mysql-server
sudo apt-get remove mysql-common  &lt;span class="c1"&gt;#很重要&lt;/span&gt;

&lt;span class="c1"&gt;# 清理残留数据&lt;/span&gt;
dpkg -l &lt;span class="p"&gt;|&lt;/span&gt; grep ^rc &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sudo xargs dpkg -P
&lt;span class="c1"&gt;# 安装mysql&lt;/span&gt;
sudo apt-get install mysql-server mysql-client php5-mysql
&lt;span class="c1"&gt;# 启动mysql&lt;/span&gt;
&lt;span class="c1"&gt;# sudo /etc/init.d/mysql restart&lt;/span&gt;
&lt;span class="c1"&gt;# 安装phpmyadmin&lt;/span&gt;
sudo …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h3&gt;Ubuntu彻底删除Mysql,重装Mysql&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 删除MySQL&lt;/span&gt;
sudo apt-get autoremove --purge mysql-server-5.0
sudo apt-get remove mysql-server
sudo apt-get autoremove mysql-server
sudo apt-get remove mysql-common  &lt;span class="c1"&gt;#很重要&lt;/span&gt;

&lt;span class="c1"&gt;# 清理残留数据&lt;/span&gt;
dpkg -l &lt;span class="p"&gt;|&lt;/span&gt; grep ^rc &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sudo xargs dpkg -P
&lt;span class="c1"&gt;# 安装mysql&lt;/span&gt;
sudo apt-get install mysql-server mysql-client php5-mysql
&lt;span class="c1"&gt;# 启动mysql&lt;/span&gt;
&lt;span class="c1"&gt;# sudo /etc/init.d/mysql restart&lt;/span&gt;
&lt;span class="c1"&gt;# 安装phpmyadmin&lt;/span&gt;
sudo apt-get install phpmyadmin
sudo ln -s /etc/phpmyadmin/apache.conf /etc/apache2.conf-available/phpmyadmin.conf
sudo a2enconf phpmyadmin
sudo /etc/init.d/apache2 reload
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Ubuntu启动问题以及Grub Rescue修复方法&lt;/h3&gt;
&lt;p&gt;在安装双系统时，或者不小心删除了启动引导项时，启动时系统将进入Grub Rescue模式。在rescue模式下，只用少量的命令可以使用，但是通过一定的操作可以让系统加载正常模块，然后进入正常启动模式，启动后修复grub启动项即可。&lt;/p&gt;
&lt;p&gt;rescue模式下可使用的命令有：set,ls(列出文件),insmod(插入启动模块),root(设置启动分区),prefix(设置启动路径)。&lt;/p&gt;
&lt;p&gt;解决方法如下：&lt;/p&gt;
&lt;pre&gt;
# 查看系统分区情况
grub rescue&gt;ls
# 罗列出所有的磁盘分区信息，比如说：
(hd0,msdos6) (hd0,msdos5) (hd0,msdos4) (hd0,msdos3)(hd0,msdos2)
# 查找曾经安装系统的磁盘分区，找到相应的grub
grub rescue&gt;ls (hd0,X)/        # 查看X磁盘分区/根路径的文件信息
grub rescue&gt;ls (hd0,X)/boot    # 查看X磁盘分区/boot路径的文件信息
grub rescue&gt;ls (hd0,X)/grub    # 查看X磁盘分区/grub路径的文件信息
# 假设找的(hd0,msdos3)时，显示了文件信息，则表明系统安装在这个分区，并记住相应的grub路径
# 接下来，设置系统的启动项，调用如下命令
grub rescue&gt;set root=(hd0,msdos3)
grub rescue&gt;set prefix=(hd0,msdos3)/grub  #这个路径为之前找到的启动项路径
grub rescue&gt;insmod normal
# 设置完成后，进行启动即可
grub rescue&gt;normal&lt;/pre&gt;

&lt;p&gt;经过以上操作，就可以显示丢失的grub菜单，然后进入自己想进入的系统即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果进行重启，问题依旧存在。所以最关键的一步就是对grub进行修复。&lt;/b&gt;进入系统后，使用以下命令对grub进行修复。&lt;/p&gt;
&lt;pre&gt;
sudo update-grub
sudo grub-install /dev/sda
# sda是磁盘号码，不是分区号码&lt;/pre&gt;

&lt;p&gt;grub修复成功后，重启测试即可。&lt;em&gt;说明一下，grub修复成功后，其启动项是由当前系统去引导另一系统启动。&lt;/em&gt;你也可以进入另一系统进行grub修复，修改启动引导顺序，或者修改文件/etc/default/grub设定默认启动项(GRUB_DEFAULT从0开始计算)。&lt;/p&gt;</content><category term="tools"></category></entry><entry><title>机器学习之Weka学习-Evaluation类介绍</title><link href="www.subond.com/pages/2016/07/03/machinelearning-about-weka-evaluation.html" rel="alternate"></link><published>2016-07-03T00:00:00+08:00</published><updated>2016-07-03T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-07-03:www.subond.com/pages/2016/07/03/machinelearning-about-weka-evaluation.html</id><summary type="html">&lt;p&gt;Evaluation类顾名思义，用来评价各种分类器（包括机器学习模型）的性能。Weka中有两个Evaluation类，分别位于weka.classifiers.evaluation.Evaluation和weka.classifiers.Evaluation 而且这两个类定义了同样的接口，其中evaluation包下的Evaluation类就是把所有的操作交给classifier包下的Evalution类来完成，也许为了能够适配旧版本已经编写的代码，就保留了classifier包下的 Evalution类，我们暂且不需要即可。下面我们就介绍weka.classifier.Evaluation类。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.Evalution类介绍&lt;/h2&gt;
&lt;p&gt;Evaluation类顾名思义，用来评价各种分类器（包括机器学习模型）的性能。Weka中有两个Evaluation类，分别位于weka.classifiers.evaluation.Evaluation和weka.classifiers.Evaluation 而且这两个类定义了同样的接口，其中evaluation包下的Evaluation类就是把所有的操作交给classifier包下的Evalution类来完成，也许为了能够适配旧版本已经编写的代码，就保留了classifier包下的 Evalution类，我们暂且不需要即可。下面我们就介绍weka.classifier.Evaluation类。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class　Evaluation
extends java.lang.Object
implemensts java.io.Serializable, Summarizable, RevisionHandler
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;2.构造函数&lt;/h2&gt;
&lt;p&gt;Evaluation类没有无参的构造函数，一般用Instances对象作为构造函数的参数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Evaluation eval = new Evaluation(data)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;data是训练集的数据，用来获取一些信息，并不用来评价分类器。&lt;/p&gt;
&lt;p&gt;&lt;img alt="evaluation-weka" src="http://on64c9tla.bkt.clouddn.com/2016C/Evaluation.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;3.主要成员变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;evaluationModel(Classifier classifier, Instances data)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果训练集和测试集是分开的，可以使用evaluationModel方法，方法中的参数为：第一个参数是训练过的分类器，第二个参数是测试集的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;crossValidationModel()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;crossValidationModel方法的四个参数为：第一个参数是分类器，第二个参数是测试集的数据，第三个参数是交叉检验的次数（比较常见的是10），第四个参数是一个随机数对象。&lt;/p&gt;
&lt;h2&gt;4.应用示例&lt;/h2&gt;
&lt;p&gt;下面这个小程序用同一数据测试了两类方法的评价结果，源码地址如下&lt;a href="https://github.com/yusubond/Machine-Learning/blob/master/Evaluation/Demo_evaluation.java"&gt;Demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="result-evaluationModel" src="http://on64c9tla.bkt.clouddn.com/2016C/evaluationModel.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="result-crossvalidateModel" src="http://on64c9tla.bkt.clouddn.com/2016C/crossvalidateModel.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官网资料：&lt;a href="http://10.103.14.28/weka-3-8-0/doc/"&gt;Instances类&lt;/a&gt;&lt;br&gt;
Weka开发[3]-Evaluation类：&lt;a href="http://quweiprotoss.blog.163.com/blog/static/408828832008103042734622/"&gt;http://quweiprotoss.blog.163.com/blog/static/408828832008103042734622/&lt;/a&gt;&lt;/p&gt;</content><category term="MachineLearning"></category><category term="AI"></category></entry><entry><title>机器学习之Weka学习-Instances类介绍</title><link href="www.subond.com/pages/2016/06/29/machinelearning-about-weka-instances.html" rel="alternate"></link><published>2016-06-29T00:00:00+08:00</published><updated>2016-06-29T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-29:www.subond.com/pages/2016/06/29/machinelearning-about-weka-instances.html</id><summary type="html">&lt;p&gt;Instances类是Weka中进行数据操作的对象，即需将所要处理的数据先存入并转化为Instances类的对象，然后进行其他操作。也就是说Instances类是继承AbstractList类而来，并实了Serializable,RevisionHandler接口。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.Intances类介绍&lt;/h2&gt;
&lt;p&gt;Instances类是Weka中进行数据操作的对象，即需将所要处理的数据先存入并转化为Instances类的对象，然后进行其他操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class Instances
extends java.util.AbstractList&amp;lt;Instace&amp;gt;
implemensts java.io.Serializable, RevisionHandler
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是说Instances类是继承AbstractList类而来，并实现了Serializable,RevisionHandler接口。&lt;/p&gt;
&lt;h2&gt;2.构造函数&lt;/h2&gt;
&lt;p&gt;&lt;img alt="weka-instances" src="http://on64c9tla.bkt.clouddn.com/2016B/20160629instances-gouzao.jpg"&gt;&lt;/p&gt;
&lt;p&gt;其构造函数可以实现实例的完整或部分拷贝，也可以创建新的实例，值得注意的是，其读入的数据格式为arff。关于arff的数据格式后续会有介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要成员变量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;numAttributes():返回属性总量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setClassIndex(int):设置用于分类的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;instance(int):返回具体的实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;firstInstance():返回第一个实例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.应用实例&lt;/h2&gt;
&lt;p&gt;1.导入数据，设置分类属性，输出实例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.lang.String&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.converters.ConverterUtils.DataSource&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;DataSource&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;DataSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;filename&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Instances&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getDataSet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.示例程序 程序源码地址：&lt;a href="https://github.com/yusubond/Machine-Learning/blob/master/Instances/Demo_Instances.java"&gt;Instances小实例&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;weka01&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.converters.ConverterUtils.DataSource&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.Instances&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Demo_Instances&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;testInstances&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;DataSource&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;DataSource&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/home/subond/subond/weka-3-8-0/data/weather.numeric.arff&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;Instances&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDataSet&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

            &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setClassIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numAttributes&lt;/span&gt;&lt;span class="o"&gt;()-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//System.out.println(ins);&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the number of attributes:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numAttributes&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the number of instances:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numInstances&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the first instance:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;firstInstance&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the 3rd instance:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the last instances:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lastInstance&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the name of relation:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;relationName&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="c1"&gt;//将第一个实例加入到总实例的最后&lt;/span&gt;
            &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;firstInstance&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;



        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Demo_Instances&lt;/span&gt; &lt;span class="n"&gt;testIns&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Demo_Instances&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;testIns&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;testInstances&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官网资料：&lt;a href="http://10.103.14.28/weka-3-8-0/doc/"&gt;Intances类&lt;/a&gt;&lt;/p&gt;</content><category term="MachineLearning"></category><category term="AI"></category></entry><entry><title>机器学习之Weka学习-简单分类器</title><link href="www.subond.com/pages/2016/06/28/machinelearning-about-weka-classifier.html" rel="alternate"></link><published>2016-06-28T00:00:00+08:00</published><updated>2016-06-28T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-28:www.subond.com/pages/2016/06/28/machinelearning-about-weka-classifier.html</id><summary type="html">&lt;p&gt;Weka的全名是怀卡托智能分析环境（Waikato Environment for Knowledge Analysis），是一款免费的，非商业化的，基于JAVA环境下开源的机器学习（machine learning）以及数据挖掘（data mining）工具。 它和它的源代码可在其&lt;a href="http://www.cs.waikato.ac.nz/ml/weka/"&gt;官方网站&lt;/a&gt;下载。&lt;/p&gt;</summary><content type="html">&lt;p&gt;WEKA作为一个公开的数据挖掘工作平台，集合了大量能承担数据挖掘任务的机器学习算法，包括对数据进行预处理， 分类，回归、聚类、关联规则以及在新的交互式界面上的可视化。&lt;/p&gt;
&lt;h2&gt;1.Weka介绍&lt;/h2&gt;
&lt;p&gt;Weka的全名是怀卡托智能分析环境（Waikato Environment for Knowledge Analysis），是一款免费的，非商业化的，基于JAVA环境下开源的机器学习（machine learning）以及数据挖掘（data mining）工具。 它和它的源代码可在其&lt;a href="http://www.cs.waikato.ac.nz/ml/weka/"&gt;官方网站&lt;/a&gt;下载。
WEKA作为一个公开的数据挖掘工作平台，集合了大量能承担数据挖掘任务的机器学习算法，包括对数据进行预处理， 分类，回归、聚类、关联规则以及在新的交互式界面上的可视化。&lt;/p&gt;
&lt;p&gt;机器学习可以概括为“为使用正确的特征来构建正确的模型，以完成既定的任务”。任务，模型及特征是机器学习的三大”原料“。其工作流程一般如下：&lt;/p&gt;
&lt;p&gt;1.学习问题，即由训练数据结合学习算法构建正确的模型&lt;br&gt;
2.构建特征，即将原始数据根据所需构建特征，形成模型所识别的数据格式&lt;br&gt;
3.完成任务，即借助正确的模型，对数据进行处理，得到输出。  &lt;/p&gt;
&lt;h2&gt;2.简单分类器实例&lt;/h2&gt;
&lt;p&gt;该分类器的数据处理过程如下：
1)读入训练数据&lt;br&gt;
2)初始化分类器&lt;br&gt;
3)使用训练数据训练分类器&lt;br&gt;
4)使用测试样本测试分类器的学习效果&lt;br&gt;
5)打印分类结果  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;weka01&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.File&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.classifiers.Classifier&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.classifiers.Evaluation&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.Instance&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.Instances&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.converters.ArffLoader&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SimpleCluster&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Instances&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Classifier&lt;/span&gt; &lt;span class="n"&gt;cfs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *读入训练数据&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
      &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/home/subond/subond/weka-3-8-0/data/weather.numeric.arff&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;ArffLoader&lt;/span&gt; &lt;span class="n"&gt;loader&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArffLoader&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;loader&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;ins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;loader&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDataSet&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *设置数据集的分类类别，即指定哪一列作为类别&lt;/span&gt;
&lt;span class="cm"&gt;      *注意：本例中设置最后一列作为类别&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setClassIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numAttributes&lt;/span&gt;&lt;span class="o"&gt;()-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *初始化分类器&lt;/span&gt;
&lt;span class="cm"&gt;      *具体使用哪一种特定的分类器可以在forName函数中指定&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;cfs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Classifier&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;forName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;weka.classifiers.bayes.NaiveBayes&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;newInstance&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *使用训练数据训练分类器&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;cfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;buildClassifier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *使用测试样本测试分类器的学习效果&lt;/span&gt;
&lt;span class="cm"&gt;      *注意：本实例中，为了方便将训练数据和测试数据置为同一个&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;Instance&lt;/span&gt; &lt;span class="n"&gt;testInst&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;Evaluation&lt;/span&gt; &lt;span class="n"&gt;testingEvaluation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Evaluation&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numInstances&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt;
            &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;        *将每个测试样本都用来测试分类器的效果&lt;/span&gt;
&lt;span class="cm"&gt;        */&lt;/span&gt;
                &lt;span class="n"&gt;testInst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;testingEvaluation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;evaluateModelOnceAndRecordPrediction&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cfs&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testInst&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *输出结果&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;分类器的正确率：&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;testingEvaluation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;errorRate&lt;/span&gt;&lt;span class="o"&gt;()));&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="MachineLearning"></category><category term="AI"></category></entry><entry><title>Linux中的线程管理</title><link href="www.subond.com/pages/2016/06/19/pthread2-management-in-linux.html" rel="alternate"></link><published>2016-06-19T00:00:00+08:00</published><updated>2016-06-19T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-19:www.subond.com/pages/2016/06/19/pthread2-management-in-linux.html</id><summary type="html">&lt;p&gt;线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1.线程&lt;/h3&gt;
&lt;p&gt;线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。&lt;/p&gt;
&lt;h3&gt;2.多线程模型&lt;/h3&gt;
&lt;p&gt;操作系统中有两种方法提供线程支持：用户层的 &lt;strong&gt;用户线程&lt;/strong&gt; 和 内核层的 &lt;strong&gt;内核线程&lt;/strong&gt;。用户线程受内核内核支持，而无需内核管理；内核线程由系统直接支持和管理。&lt;/p&gt;
&lt;p&gt;1）多对一模型：多个用户线程映射到一个内核线程&lt;/p&gt;
&lt;p&gt;特点：线程管理由线程库在用户空间进行，效率高；一个线程阻塞系统调用，整个进程阻塞；任意时刻，只有一个线程能访问内核(也就是，多线程不能并行运行在多处理器上)&lt;/p&gt;
&lt;p&gt;2）一对一模型：每个用户线程映射到一个内核线程&lt;/p&gt;
&lt;p&gt;特点：一个线程阻塞，其他线程不受影响，具有并发功能；允许多线程运行在多处理器上。&lt;/p&gt;
&lt;p&gt;3）多对多模型：即多路复用，许多用户线程映射到同等数量或较少数量的内核线程&lt;/p&gt;
&lt;p&gt;特点：结合多对一模型和一对一模型的优点，其对应的一个变形是 &lt;strong&gt;二级模型&lt;/strong&gt; (先允许一个用户线程绑定到一个内核线程上，然后，其他用户线程多路复用)&lt;/p&gt;
&lt;h3&gt;3.线程库&lt;/h3&gt;
&lt;p&gt;线程库为程序员提供创建和管理线程的API函数，主要有两种方法来实现线程库：&lt;b&gt;系统调用&lt;/b&gt;和&lt;b&gt;非系统调用&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;1）在用户空间提供没有内核支持的库，称为 &lt;strong&gt;非系统调用&lt;/strong&gt;；&lt;br&gt;
2）由系统支持的内核级库，称为 &lt;strong&gt;系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;系统调用fork()和exec()&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;exec():如果一个线程调用exec()，则其指定的程序替换整个进程，包括所有线程。&lt;br&gt;
fork(): 1）fork()之后立即调用exec()，则没有必要替换所有线程，因为exec()会替换所有线程；2）fork()之后没有调用exec()，则另一个进程复制所有线程。&lt;/p&gt;
&lt;h3&gt;4.线程取消&lt;/h3&gt;
&lt;p&gt;线程取消是在线程完成之前来终止线程的任务。要取消的线程称为 &lt;strong&gt;目标线程&lt;/strong&gt;。目标线程可以在两种情况下发生：&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;异步取消&lt;/strong&gt;: 一个线程立即终止目标线程。  (所有线程共享进程的数据，因为异步取消并不会使系统资源空闲)&lt;br&gt;
2）&lt;strong&gt;延迟取消&lt;/strong&gt;: 目标线程不断检查自己是否应该终止，让线程有机会有序结束自己。  (因为具有 &lt;strong&gt;取消点&lt;/strong&gt;，因此更安全)&lt;/p&gt;
&lt;h3&gt;5.信号处理&lt;/h3&gt;
&lt;p&gt;信号是用来通知进程某个事件已发生，可分为 &lt;strong&gt;异步接收&lt;/strong&gt; 和 &lt;strong&gt;同步接收&lt;/strong&gt;。所有的信号具有同样的模式：&lt;/p&gt;
&lt;p&gt;1）信号是由特定事件发生；2）信号发送至进程；3）一旦发送，信号必须加以处理。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步信号&lt;/strong&gt;: 指发送信号到执行操作的同一进程(例如，非法访问，被0除)&lt;br&gt;
&lt;strong&gt;异步信号&lt;/strong&gt;: 指信号由进程外事件产生，发送到另一个进程。(例如，特定键(ctrl+c))&lt;/p&gt;
&lt;p&gt;标准发送信号的函数:1) kill(pid_t id, int signal)指定信号的发送进程；2）pthread_kill(pthread_t id, int signal)允许信号被传送到一个指定的线程。&lt;/p&gt;
&lt;h3&gt;6.线程池&lt;/h3&gt;
&lt;p&gt;其思想是：进程开始时，创建一定数量的线程，放入线程池等待工作。其优点有，1）不必创建新线程，响应时间更快；2）可以限制线程数量，有效利用系统资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux系统中并不区分进程和线程，统称为 &lt;strong&gt;任务&lt;/strong&gt;。其系统调用包括：fork()和clone()。&lt;/p&gt;
&lt;p&gt;fork():传统复制进程——具备父任务的所有数据的副本&lt;br&gt;
clone()创建线程(子任务)——根据传递给clone()的标志位，子任务指向父任务的数据结构&lt;/p&gt;
&lt;h2&gt;线程小结&lt;/h2&gt;
&lt;p&gt;线程是进程内的控制流，多线程进程在同一地址空间内包括多个不同的控制流。用户线程对程序员是可见的，对内核来说却是未知的。操作系统支持和管理内核线程。有三种不同的模式将用户线程和内核线程关联起来：多对一模式，一对一模式和多对多模式。&lt;/p&gt;
&lt;h2&gt;一个小栗子&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;*Author:subond&lt;/span&gt;
&lt;span class="cm"&gt;* Time: 2016-06-19&lt;/span&gt;
&lt;span class="cm"&gt;* Function: 用户在命令行输入一个数字，然后创建一个独立线程来输出小于或等于输入数的所有素数&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;runner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;pthread_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enter a number(&amp;gt;= 0):&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;pthread_attr_t&lt;/span&gt; &lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;pthread_attr_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;runner&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Create pthread error&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;pthread_join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="process"></category><category term="pthread"></category></entry><entry><title>Linux中的进程管理</title><link href="www.subond.com/pages/2016/06/17/process-management-in-linux.html" rel="alternate"></link><published>2016-06-17T00:00:00+08:00</published><updated>2016-06-17T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-17:www.subond.com/pages/2016/06/17/process-management-in-linux.html</id><summary type="html">&lt;p&gt;进程是执行中的程序，是大多数系统的工作单元，是 &lt;strong&gt;活动实体&lt;/strong&gt;。一般，进程具有以下几种状态：新的，运行，等待，就绪，终止。每个进程在操作系统中用进程控制块(PCB)表示，其包含许多与一个特定进程相关的信息(进程状态，程序计数器，CPU寄存器，CPU调度信息，内存管理信息，记账信息，I/O状态信息等)。&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1.进程&lt;/h3&gt;
&lt;p&gt;进程是执行中的程序，是大多数系统的工作单元，是 &lt;strong&gt;活动实体&lt;/strong&gt;。一般，进程具有以下几种状态：新的，运行，等待，就绪，终止。每个进程在操作系统中用进程控制块(PCB)表示，其包含许多与一个特定进程相关的信息(进程状态，程序计数器，CPU寄存器，CPU调度信息，内存管理信息，记账信息，I/O状态信息等)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程调度是指选择一个可用的进程到CPU上执行的过程，由相应的 &lt;strong&gt;调度程序&lt;/strong&gt; 来执行。进程进入系统后，进入 &lt;strong&gt;作业队列&lt;/strong&gt; (包含系统中的所有队列)；驻留在内存中就绪，等待执行的进程位于 &lt;strong&gt;就绪队列&lt;/strong&gt;。就绪队列通常用链表实现，其头节点指向链表的第一个和最后一个PCB块的指针；每个PCB包括一个指向就绪队列的下一个的PCB的指针域。&lt;/p&gt;
&lt;p&gt;&lt;img alt="三种进程调度的区别" src="http://on64c9tla.bkt.clouddn.com/20160617process2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;调度程序分为 &lt;strong&gt;长期调度程序&lt;/strong&gt;, &lt;strong&gt;中期调度程序&lt;/strong&gt; 和 &lt;strong&gt;短期调度程序&lt;/strong&gt;。长期调度(高级调度)，又称为 &lt;strong&gt;作业调度&lt;/strong&gt;，是指从池中选择进程，并装入内存准备执行，其使用频率比较低，主要用来控制内存中进程的数量；中期调度(中级调度)，又称为 &lt;strong&gt;交换调度&lt;/strong&gt;，是指将进程中内存或CPU竞争中移出，从而降低多道程序设计的程度，之后进程被重新装入内存；短期调度(低级调度)，又称为 &lt;strong&gt;进程调度&lt;/strong&gt;，是指按照一定的策略和算法，将CPU分配给一个处于就绪的进程，分为 &lt;strong&gt;抢占式&lt;/strong&gt; 和 &lt;strong&gt;非抢占式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="三种进程调度的区别" src="http://on64c9tla.bkt.clouddn.com/20160617process.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文切换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将CPU切换找另一个进程需要保存当前进程的状态，并恢复另一个进程的状态，这个过程称为上下文切换。&lt;/p&gt;
&lt;h3&gt;2.进程操作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;进程创建&lt;/strong&gt; 和 &lt;strong&gt;进程终止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程创建新进程时，有两种执行可能：&lt;/p&gt;
&lt;p&gt;1）父进程与子进程并发执行；2）父进程等待，直到某个子进程或全部子进程执行完毕。&lt;/p&gt;
&lt;p&gt;同样，新进程的地址空间也有两种可能：&lt;/p&gt;
&lt;p&gt;1）子进程是父进程的复制品（具有父进程相同的程序和数据）；2）子进程装入一个新程序。&lt;/p&gt;
&lt;p&gt;在linux系统，使用fork()函数可以创建一个新进程，相关内容参考fork()函数。&lt;/p&gt;
&lt;p&gt;当进程完成执行最后的语句病使用系统调用exit()请求操作系统删除自身时，进程终止。进程终止时，可以返回状态值(整数)到父进程(通过系统调用wait())，所有进程资源将会被操作系统回收。&lt;/p&gt;
&lt;h3&gt;3.进程间通信&lt;/h3&gt;
&lt;p&gt;进程间通信(IPC)有两种基本模式：&lt;strong&gt;共享内存&lt;/strong&gt; 和 &lt;strong&gt;消息传递&lt;/strong&gt;。进程间通信可以调用send()和receive()来进行，其可分为 &lt;strong&gt;阻塞&lt;/strong&gt; 或 &lt;strong&gt;非阻塞&lt;/strong&gt;——也称为 &lt;strong&gt;同步&lt;/strong&gt; 和 &lt;strong&gt;异步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;阻塞send: 发送进程阻塞，直到消息被进程或邮箱所接收；&lt;br&gt;
非阻塞send: 发送进程发送消息并继续操作；&lt;br&gt;
阻塞receive: 接收进程阻塞，直到有消息可用；&lt;br&gt;
非阻塞receive: 接收进程接收到一个有用消息或空消息；&lt;/p&gt;
&lt;p&gt;值得注意的是，无论是直接通信还是间接通信，通信进程的消息的驻留在临时队列中。队列的实现有三种方式：零容量，有限容量，无限容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享内存实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建共享内存段shmget()&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//三个参数：标识符，字节数，读写模式&lt;/span&gt;
&lt;span class="c1"&gt;//函数返回整数标识值&lt;/span&gt;
&lt;span class="n"&gt;segment_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shmget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IPC_PRIVATE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;S_IRUSR&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;S_IWURS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//三个参数：共享内存段的ID，指针，读写模式&lt;/span&gt;
&lt;span class="c1"&gt;//返回初始位置的指针&lt;/span&gt;
&lt;span class="n"&gt;share_memory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;shmat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//删除共享内存段，释放指针&lt;/span&gt;
&lt;span class="n"&gt;shmdt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;share_memory&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;shmctl&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;消息传递&lt;/strong&gt;: Mach&lt;/p&gt;
&lt;p&gt;Mach系统主要为分布式系统设计。在Mach系统中，每个任务创建时，同时创建了两个特别的邮箱：&lt;strong&gt;内核邮箱&lt;/strong&gt; 和 &lt;strong&gt;通报邮箱&lt;/strong&gt;。内核使用内核邮箱与任务通信，使用通报邮箱发送事件发生的通知。&lt;/p&gt;
&lt;p&gt;消息传递使用三个系统调用：&lt;/p&gt;
&lt;p&gt;1）msg_send():发送数据；&lt;br&gt;
2）msg_receive():接收数据；&lt;br&gt;
3）msg_rpc():发送远程消息，并只等待来自发送者的一个返回消息；  &lt;/p&gt;
&lt;p&gt;值得注意的是，Mach可以确保来自同一个发送者额多个消息满足FIFO顺序排队，但不是绝对顺序。即两个发送者的消息可以任意排队。其次，Mach使用的是双重复制机制(发送者&amp;lt;--复制--&amp;gt;邮箱&amp;lt;--复制--&amp;gt;接收者)。若使用虚拟内存管理技术(即将发送者的地址空间映射到接收者的地址空间，但只适用与系统内部)，可以避免这种双重复制。&lt;/p&gt;
&lt;h2&gt;4.进程小结&lt;/h2&gt;
&lt;p&gt;进程是执行中的程序。随着程序的执行，它改变状态。进程状态由进程当前活动所定义。每个进程可处于：新的，就绪，执行，等待或终止状态。每个进程在操作系统内通过自己的进程控制块PCB来表示。当前不执行的进程放在某个等待队列中。操作系统有两种主要队列：&lt;strong&gt;I/O请求队列&lt;/strong&gt; 和 &lt;strong&gt;就绪队列&lt;/strong&gt;。就绪队列包括所有准备执行或等待CPU的进程。每个都有PCB，PCB链接起来就形成了就绪队列。长期调度通过选择进程来争用CPU。短期调度从就绪队列中选择进程。&lt;/p&gt;
&lt;p&gt;操作系统的执行进程可以是独立进程，也可以是协作进程。协作进程需要进程间有互相通信机制，主要有两种形式：共享内存和消息传递。&lt;strong&gt;共享内存&lt;/strong&gt; 方法通过要求通信进程共享一些变量，进程通过使用共享变量来交换信息；而 &lt;strong&gt;消息系统&lt;/strong&gt; 方法允许进程交换信息。&lt;/p&gt;</content><category term="linux"></category><category term="process"></category></entry><entry><title>Linux中的线程函数</title><link href="www.subond.com/pages/2016/06/14/pthread-management-in-linux.html" rel="alternate"></link><published>2016-06-14T00:00:00+08:00</published><updated>2016-06-14T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-14:www.subond.com/pages/2016/06/14/pthread-management-in-linux.html</id><summary type="html">&lt;p&gt;线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。本节主要介绍5个基本线程函数。&lt;/p&gt;</summary><content type="html">&lt;p&gt;线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。以下内容，主要介绍5个基本线程函数。&lt;/p&gt;
&lt;h3&gt;1.pthread_create()函数&lt;/h3&gt;
&lt;p&gt;当一个程序由exec启动执行时，称为初始线程或主线程的单个线程就创建了。其余线程则由pthread_create函数创建。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;pthread_attr_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回：成功为0，出错为正的Exxx值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;tid&lt;/strong&gt;:一个进程内的每个线程都有一个线程ID标识，其数据类型为pthread_t(unsigned long int,即％lu)。如果新的线程创建成功，其ID通过tid指针返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;attr&lt;/strong&gt;:属性，每个线程都有许多属性（优先级，初始栈大小，是否成为一个守护线程等等）。若采用默认设置，可置attr参数为空指针（NULL）。&lt;/p&gt;
&lt;p&gt;创建一个线程时最后指定的参数就是由该线程执行的函数func及其参数arg。&lt;strong&gt;注意&lt;/strong&gt; func和arg的声明。func所指函数作为参数接受一个通用指针 (void *)，又作为返回值返回一个通用指针(void *)。另外该函数的唯一调用参数是指针arg，如果需要给函数传递多个参数，可以打包成一个结构，然后将结构的地址作为单个参数传递给函数。&lt;/p&gt;
&lt;h3&gt;2.pthread_join()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;//返回：成功为0，出错为正的Exxx值。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该函数的功能是等待一个给定线程终止&lt;/p&gt;
&lt;h3&gt;3.pthread_self()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pthread_self&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//返回：调用线程的线程ID。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4.pthread_detach()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pthread_detach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//返回：成功返回0，出错为正的Exxx值。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个线程或是可汇合的(joinable,默认值)，或是脱离的(detached)。当一个可汇合的线程终止时，它的线程ID和退出状态将留存到另一个线程对它的调用pthread_join。脱离的线程却像守护进程，当它们终止时，所有相关的资源 都被释放，我们不能等待它们终止。pthread_detach函数就是把指定的线程转变为脱离状态。&lt;/p&gt;
&lt;h3&gt;5.pthread_exit()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pthread_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//不返回&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用pthread_exit函数可使线程终止。&lt;/p&gt;
&lt;h2&gt;一个栗子&lt;/h2&gt;
&lt;p&gt;利用线程的方法，重新编写基本UDP套接字编程&lt;/p&gt;
&lt;p&gt;其服务端源码地址：&lt;a href="https://github.com/yusubond/Socket-Programming/blob/master/udp_demo/serverv0.3.c"&gt;https://github.com/yusubond/Socket-Programming/blob/master/udp_demo/serverv0.3.c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="udp-socket" src="http://on64c9tla.bkt.clouddn.com/20160614pthread_udp.png"&gt;&lt;/p&gt;</content><category term="linux"></category><category term="pthread"></category><category term="process"></category></entry><entry><title>Socket编程之基本UDP编程</title><link href="www.subond.com/pages/2016/05/24/socket-bian-cheng-udp.html" rel="alternate"></link><published>2016-05-24T00:00:00+08:00</published><updated>2016-05-24T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-05-24:www.subond.com/pages/2016/05/24/socket-bian-cheng-udp.html</id><summary type="html">&lt;p&gt;UDP套接字编程模型。TCP编写的应用程序和UDP编写的应用程序之间存在本质的差别，其原因在于两者在传输层之间的差异：UDP是无连接不可靠的数据包协议，而不同于TCP提供的面向连接的可靠字节流。使用UDP编写的常见应用程序有：DNS(域名系统)， NFS(网络文件系统)和SNMP(简单网络管理协议)。典型的UDP客户/服务器程序的函数调用如下图1-1所示。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.UDP套接字编程模型&lt;/h2&gt;
&lt;p&gt;TCP编写的应用程序和UDP编写的应用程序之间存在本质的差别，其原因在于两者在传输层之间的差异：UDP是无连接不可靠的数据包协议，而不同于TCP提供的面向连接的可靠字节流。使用UDP编写的常见应用程序有：DNS(域名系统)， NFS(网络文件系统)和SNMP(简单网络管理协议)。典型的UDP客户/服务器程序的函数调用如下图1-1所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="udp-socket" src="http://on64c9tla.bkt.clouddn.com/20160514udp-bian-cheng-mo-xing.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1-1 UDP客户/服务器程序所用的套接字函数&lt;/p&gt;
&lt;h2&gt;2.recvfrom()和sendto()函数&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#include&amp;lt;sys/socket.h&amp;gt;
ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen);
ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen);
//均返回：若成功返回读或写的字节数，出错返回-1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前三个参数sockfd,buff和nbytes为：描述符、指向读入或写出的缓冲区的指针和读写字节数。
flags一般置为0。&lt;/p&gt;
&lt;p&gt;sendto的to参数指向一个含有数据包接收者的协议地址的套接字地址结构，其大小由addrlen参数指定。recvfrom的from参数指向一个将由该函数在返回时填写数据报发送者的协议地址的套接字地址结构， 而在该套接字地址结构中填写的字节数则放在addrlen参数所所指的整数中返回给调用者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:sendto的最后一个参数是一个整数值，而recvfrom的最后一个参数是一个指向整数值的指针（即值-结果参数）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:recvfrom的最后两个参数类似accept的最后两个参数：返回时其中套接字地址结构的内容告诉我们是谁发送了数据报（UDP）或是谁发起了连接（TCP）。sendto的最后两个参数类似connect的最后两个参数： 调用时其中套接字地址结构被我们填入数据报发往（UDP）或预制建立连接（TCP）的协议地址。&lt;/p&gt;
&lt;h2&gt;3.消息回传程序示例&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;服务端程序&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;socket_includes.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;listenfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;lenserv&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;lencli&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;lenserv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;lencli&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;//创建套接字&lt;/span&gt;
  &lt;span class="c1"&gt;//listenfd = socket(AF_INET,SOCK_DGRAM, 0);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;listenfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Create socket fail!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;//绑定套接字&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8888&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                &lt;span class="c1"&gt;//主机字节序转网络字节序&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htonl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INADDR_ANY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;//绑定主机的所有网卡&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listenfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lenserv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bind socket error.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;rv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;recvfrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listenfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lencli&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;recvfrom error.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;inet_ntop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;size of buf_client: %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;client buf:%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;client IP: %s, Port: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listenfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lencli&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lencli&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;客户端程序&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;socket_includes.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello UDP!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ser&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ser&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;//sockfd = socket(AF_INET,SOCK_DGRAM, 0);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Create socket fail!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8888&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;inet_pton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;10.103.14.28&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;rv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;recvfrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ser&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;recvfr0m error!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;server buf_back:%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中头文件均为socket_includes.h&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;netinet/in.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/shm.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;


&lt;span class="cp"&gt;#define MAX_LISTEN_QUE 5&lt;/span&gt;
&lt;span class="cp"&gt;#define SERV_PORT 8888&lt;/span&gt;
&lt;span class="cp"&gt;#define MAX_BUFFER_SIZE 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="socket"></category><category term="newtork programming"></category></entry><entry><title>Socket编程之函数学习篇</title><link href="www.subond.com/pages/2016/05/17/socket-bian-cheng-xue-xi.html" rel="alternate"></link><published>2016-05-17T00:00:00+08:00</published><updated>2016-05-17T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-05-17:www.subond.com/pages/2016/05/17/socket-bian-cheng-xue-xi.html</id><summary type="html">&lt;p&gt;Socket编程涉及多个函数，本篇主要介绍其相关函数。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Socket编程涉及多个函数，本篇主要介绍其相关函数。&lt;/p&gt;
&lt;h2&gt;基本API函数&lt;/h2&gt;
&lt;h3&gt;1.socket()函数-创建套接字&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//成功返回sockfd;出错返回-1.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;sockfd是一个socket描述符，它唯一标识一个socket。这个socket描述符跟其他文件描述符一样，后续的读写操作都需用到这个socket描述符。&lt;/p&gt;
&lt;p&gt;创建socket的时候，可以指定不同的参数创建不同的socket描述符，socket()函数的三个参数分别为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;domain:协议域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;协议域规定了socket的地址类型，在通信中必须采用对应的地址类型。AF_INET(IPv4协议),AF_INET6(IPv6协议),AF_LOCAL(Unix域协议),AF_ROUTE(路由套接口)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type:socket类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的socket类型有SOCK_STREAM(字节流套接口),SOCK_DGRAM(数据包套接口),SOCK_RAW(原始套接口),SOCK_PACKET,SOCK_SEQPACKET(有序分组套接口)等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;protocol:协议类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的通信协议有IPPROTO_TCP(TCP传输协议),IPPROTO_UDP(UDP传输协议),IPPROTO_SCTP(SCTP传输协议),IPPROTO_TIPC等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：type和protocol并不是可以随意组合的。一般情况下设置protocol为０，系统会自动选择type类型所对应的默认协议。&lt;/p&gt;
&lt;h3&gt;2.bind()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;addrlen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//返回:0-成功，-1-出错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;bind()函数涉及三个对象：套接口，地址和端口，负责把特定的地址和端口赋给socket描述符，即sockfd，是从进程到内核传递套接口地址结构的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sockfd&lt;/strong&gt;:socket描述符，即socket()函数创建的唯一标识一个socket。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addr&lt;/strong&gt;:一个const struct sockaddr * 指针,指向要绑定给sockfd的协议地址。其中ipv4地址对应如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct sockaddr_in{
    sa_family_t sin_family;
    in_port_t sin_port;       //port in network byte order
    struct in_addr sin_addr;
}
struct in_addr{
    uint32_t s_addr;  //address in network byte order
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;addrlen&lt;/strong&gt;:对应的是地址的长度。&lt;/p&gt;
&lt;p&gt;函数示例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct sockaddr_in serv;
bind(sockfd, (struct sockaddr *)&amp;amp;serv, sizeof(serv));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3.listen()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;listen()函数用于服务器端，服务器通过调用listen()函数来监听某个socket。其两个参数如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sockfd&lt;/strong&gt;:socket描述符，及socket()函数创建的唯一标识一个socket。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;backlog&lt;/strong&gt;:该sockfd可以允许的最大连接数。&lt;/p&gt;
&lt;h3&gt;4.connect()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;addrlen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回:0-成功，-1-出错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;connect()函数用在客户端，客户端通过这个函数连接服务器端，是从进程到内核传递套接口地址结构的函数。其各参数如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sockfd&lt;/strong&gt;:socket描述符，即socket()函数创建的唯一标识一个socket。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addr&lt;/strong&gt;:一个const struct sockaddr * 指针,指向要绑定给sockfd的协议地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addrlen&lt;/strong&gt;:对应的是地址的长度。&lt;/p&gt;
&lt;h3&gt;5.accept()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addrlen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//返回连接connect_fd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;TCP服务器端依次调用&lt;font color="#ff0000"&gt;socket(),bind(),listen()&lt;/font&gt;之后，进入监听状态，并监听制定的socket地址。TCP客户端依次调用socket(),connect()之后，开始向TCP服务器端发送一个连接请求。TCP服务器端 监听到这个请求后，调用accept()函数接受请求，这样连接就建立好了。accept()函数是从内核到进程传递套接口地址结构的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;sockfd&lt;/strong&gt;:socket描述符，及socket()函数创建的唯一标识一个socket。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;addr&lt;/strong&gt;:一个结果参数，用来接受一个返回值，指向客户端的地址。若对客户的地址不感兴趣，可设这个值为NULL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;addrlen&lt;/strong&gt;:一个结果参数，用来接受上addr的结构的大小，可以设置为NULL。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6.网络I/O函数&lt;/h3&gt;
&lt;p&gt;常见的网络I/O函数有read()/write(),recv()/send(),readv()/writev(),recvmsg()/sendmsg()和recvfrom()/sendto()。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;recvmsg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;msghdr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;sendmsg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;msghdr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回：成功返回读入/写出的字节数，出错为-1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中函数的大部分参数封装到一个msghdr结构中，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct msghdr{
    void          *msg_name;       /*protocol address*/
    socklen_t     msg_namelen;     /*size of protocol address*/
    struct iovec  *msg_iovlen;     /*scatter/gather array*/
    int           msg_iovlen;      /*  elements in msg_iov*/
    void          *msg_control;    /*ancillary data*/
    socklen_t     msg_controllen;  /*length of ancillary data*/
    int           msg_flags;       /*flags returned by recvmsg*/
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="socket"></category><category term="newtork programming"></category></entry><entry><title>Socket编程之基础篇</title><link href="www.subond.com/pages/2016/05/14/socket-bian-cheng-ji-chu.html" rel="alternate"></link><published>2016-05-14T00:00:00+08:00</published><updated>2016-05-14T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-05-14:www.subond.com/pages/2016/05/14/socket-bian-cheng-ji-chu.html</id><summary type="html">&lt;p&gt;Socket，又称为“套接字”，是进程间进行通信的一种方式，即通过网络库的API函数实现分布在不同主机的相关进程间的数据交换。在TCP/IP网络应用中，通信的两个进程的主要模式是客户/服务器模式， 即客户向服务器发送服务请求，服务器接收到请求后，提供相应的服务。Socket编程接口是指从顶上三层（网际协议的应用层）进入传输层的接口，涉及两个方向上的传递：从进程到内核和从内核到进程，如图1-1所示。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Socket，又称为“套接字”，是进程间进行通信的一种方式，即通过网络库的API函数实现分布在不同主机的相关进程间的数据交换。在TCP/IP网络应用中，通信的两个进程的主要模式是客户/服务器模式， 即客户向服务器发送服务请求，服务器接收到请求后，提供相应的服务。Socket编程接口是指从顶上三层（网际协议的应用层）进入传输层的接口，涉及两个方向上的传递：从进程到内核和从内核到进程，如图1-1所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="tcp-ip-stack" src="http://on64c9tla.bkt.clouddn.com/20160514socket-yu-xie-yi-ge-ceng.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;套接字地址结构&lt;/h2&gt;
&lt;p&gt;学习套接字编程，首先要知道套接字的地址结构，大多数套接字函数都需要一个指向套接字的地址结构的指针作为参数。每个协议族都有自己的套接字地址结构， 均以sockaddr_开头，并以对应的每个协议族的唯一后缀结尾。&lt;/p&gt;
&lt;h3&gt;1.IPv4套接字地址结构&lt;/h3&gt;
&lt;p&gt;IPv4套接字地址结构以sockaddr_in命名，定义在&amp;lt;netinet/in.h&amp;amp;mt头文件中，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;in_addr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;in_addr_t&lt;/span&gt; &lt;span class="n"&gt;s_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="cm"&gt;/*32-bit IPv4 address;network byte ordered*/&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_in&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;uint8_t&lt;/span&gt;            &lt;span class="n"&gt;sin_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;sa_family_t&lt;/span&gt;        &lt;span class="n"&gt;sin_family&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/*AF_INET*/&lt;/span&gt;
        &lt;span class="n"&gt;in_port_t&lt;/span&gt;          &lt;span class="n"&gt;sin_port&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt; &lt;span class="n"&gt;TCP&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;UDP&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;ordered&lt;/span&gt;&lt;span class="err"&gt;*/&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;in_addr&lt;/span&gt;     &lt;span class="n"&gt;in_addr&lt;/span&gt; &lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/*32-bit IPv4 address;network byte ordered*/&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt;               &lt;span class="n"&gt;sin_zero&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="cm"&gt;/*unused*/&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;: 一般情况下，我们只使用这个结构中的3个字段：sin_family,sin_addr和sin_port，其分别对应套接字地址结构的协议族、IP地址和端口号。套接字地址结构仅在给定主机上使用 其结构中的某些字段用在不同主机间的通信，但结构本身不在主机之间传递。&lt;/p&gt;
&lt;h3&gt;2.IPv6套接字地址结构&lt;/h3&gt;
&lt;p&gt;IPv4套接字地址结构以sockaddr_in6命名，定义在&amp;lt;netinet/in.h&amp;amp;mt头文件中，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;in6_addr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;uninet8_t&lt;/span&gt; &lt;span class="n"&gt;s6_addr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="cm"&gt;/*128-bit IPv4 address;network byte ordered*/&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_in&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kt"&gt;uint8_t&lt;/span&gt;          &lt;span class="n"&gt;sin6_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;sa_family_t&lt;/span&gt;      &lt;span class="n"&gt;sin6_family&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/*AF_INET6*/&lt;/span&gt;
      &lt;span class="n"&gt;in_port_t&lt;/span&gt;        &lt;span class="n"&gt;sin6_port&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/*transport layer port;network byte ordered*/&lt;/span&gt;
      &lt;span class="kt"&gt;uint32_t&lt;/span&gt;         &lt;span class="n"&gt;sin6_flowinfo&lt;/span&gt;       &lt;span class="cm"&gt;/*flow information,undefined*/&lt;/span&gt;
      &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;in6_addr&lt;/span&gt;  &lt;span class="n"&gt;sin6_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/*128-bit IPv6 address;network byte ordered*/&lt;/span&gt;
      &lt;span class="kt"&gt;uint32_t&lt;/span&gt;         &lt;span class="n"&gt;sin6_zero&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="cm"&gt;/*unused*/&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3.值-结果参数&lt;/h3&gt;
&lt;p&gt;当往一个套接字函数传递一个套接字地址结构时，结构以引用形式来传递，也就是说传递的是指向该结构的一个指针，该结构的长度作为一个参数来传递，其传递方向取决于传递方向：是内核到进程，还是进程到内核。&lt;/p&gt;
&lt;p&gt;(1)从进程到内核传递套接字地址结构的函数有3个：bind(),connet()和sendto()。这些函数的一个参数是指向某个套接字地址结构的指针，一个参数是该结构的整数大小，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(2)从内核到进程传递套接字地址结构的函数有4个：accept(),recvfrom(),getsockname()和getpeername()。这4个函数其中的两个参数是指向某个套接字地址结构的指针和指向该地址结构大小的整数变量指针，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4.字节排序函数&lt;/h3&gt;
&lt;p&gt;简单来说，主机和网络存储整形数据的字节顺序一般是不一样的，我们将他们称之为主机字节序和网络字节序，分别对应内核处理和进程处理。两种字节序之间的互转使用以下4个函数，其对应套接字地址结构（IP地址＋端口号）的字节序的转换。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;netinet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="nf"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;host16bitvalue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;htonl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;host32bitvalue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//返回：网络字节序的值&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="nf"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;host16bitvalue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;host32bitvalue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//返回：主机字节序的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;5.地址转换函数&lt;/h3&gt;
&lt;p&gt;地址转换函数可以在ASCII字符串与网络字节序的二进制值之间转换网际地址。常用的地址转换函数有inet_pton()和inet_ntop()，其中p代表表达（presentation），n代表数值（numeric）。地址的表达格式通常是ASCII字符串，数值格式是存放到 套接字地址结构中的二进制值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;inet_pton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;family&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;strptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addrptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回：1-成功；0-输入不是有效表达式；-1-出错。&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;inet_ntop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;family&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addrptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;strptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回：成功则为指向结果的指针，出错为NULL。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;6.字节操作函数&lt;/h3&gt;
&lt;p&gt;字节操作函数用于处理多字节字段，例如bzero()函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;strings.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nbytes&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="socket"></category><category term="newtork programming"></category></entry><entry><title>LTE系统网络架构</title><link href="www.subond.com/pages/2016/05/10/lte-xi-tong-wang-luo-jia-gou.html" rel="alternate"></link><published>2016-05-10T00:00:00+08:00</published><updated>2016-05-10T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-05-10:www.subond.com/pages/2016/05/10/lte-xi-tong-wang-luo-jia-gou.html</id><summary type="html">&lt;p&gt;整个LTE网络是由核心网（EPC,Evolved Packet Core）和接入网（E-UTRAN）组成，如图1-1所示。核心网由许多逻辑节点组成，而接入网只有一个节点，即与用户终端（UE）相连的eNodeB。所有网元都通过接口相互连接，通过对接口的标准化，可以满足众多供应商产品间的互操作性。&lt;/p&gt;</summary><content type="html">&lt;p&gt;整个LTE网络是由核心网（EPC,Evolved Packet Core）和接入网（E-UTRAN）组成，如图1-1所示。核心网由许多逻辑节点组成，而接入网只有一个节点，即与用户终端（UE）相连的eNodeB。所有网元都通过接口相互连接，通过对接口的标准化，可以满足众多供应商产品间的互操作性。&lt;/p&gt;
&lt;p&gt;&lt;img alt="lte-xitong" src="http://on64c9tla.bkt.clouddn.com/20160510lte-xitong.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1-1&amp;nbsp;LTE系统网络架构示意图&lt;/p&gt;
&lt;p&gt;与3G系统相比，LTE系统重新定义了系统网络架构，核心网和接入网之间的功能划分也随之有所变化，针对LTE系统架构，网络功能划分如图1-2所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="lte-xieyi" src="http://on64c9tla.bkt.clouddn.com/20160510lte-xitong-gongneng-xieyi.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1-2&amp;nbsp;LTE系统功能实体划分、协议架构示意图&lt;/p&gt;
&lt;h3&gt;1.接入网&lt;/h3&gt;
&lt;p&gt;LTE接入网E-UTRAN仅由eNodeB组成，网络架构中节点数量减少，网络架构更加趋于扁平化，这种扁平化的网络架构可以有效地降低呼叫时延以及用户数据传输时延。E-UTRAN系统提供用户平面和控制平面的协议，用户平面用户平面包括分组数据汇聚协议（PDCP,Packet Data Convergence Protocol）层、 无线链路层控制（RLC,Radio Link Control）层、媒体接入层（MAC,Medium Access Control）层；控制平面包括无线资源控制（RRC,Radio Resource Control）层。eNodeB之间通过X2接口进行连接，通过S1接口与EPC连接，具体来说就是，通过S1-MME接口连接到MME，通过S1-U接口连接到S-GW。eNodeB与UE间的协议为接入层（AS）协议。&lt;/p&gt;
&lt;p&gt;eNodeB具有如下功能：&lt;/p&gt;
&lt;p&gt;（1）无线资源管理相关的功能，如无线资源承载控制、接纳控制、连接移动性管理、上/下行动态资源分配/调度等；&lt;br&gt;
（2）IP头压缩与用户数据流的加密；&lt;br&gt;
（3）UE附着时的MME选择。由于eNodeB可以与 多个MME/S-GW之间存在S1接口相连，因此，UE初始接入到网络时，需要选择一个MME进行附着;&lt;br&gt;
（4）寻呼信息的调度和传输；&lt;br&gt;
（5）广播信息的调度和传输；&lt;br&gt;
（6）用于移动和调度的测量和测量报告的配置。  &lt;/p&gt;
&lt;h3&gt;2.核心网&lt;/h3&gt;
&lt;p&gt;核心网负责对用户终端的全面控制和有关承载的建立。EPC的主要逻辑节点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分组数据网关（P-GW,Packet Data Network Gateway）  &lt;/li&gt;
&lt;li&gt;服务网关（S-GW,Serving Gateway）  &lt;/li&gt;
&lt;li&gt;移动性管理实体（MME, Mobility Management Entity）  &lt;/li&gt;
&lt;li&gt;归属签约用户服务器（HSS,Home Subscriber Server）  &lt;/li&gt;
&lt;li&gt;策略及计费规则功能（RCPF,Policy and Charging Rules Function）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EPC逻辑主要节点的功能，下面详细介绍。&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;P-GW：分组数据网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;P-GW提供与外部分组数据网络的连接，是主要的移动性处理节点。P-GW负责用户IP地址分配和QoS保证，并根据PCRF规则进行基于流量的计费。一个UE可能和多个P-GW相连 ，P-GW同时负责UE IP地址的分配。P-GW为保证比特率承载提供QoS保证。另外，P-GW可以通过一系列不同的接口，成为其他3GPP网络或非3GPP网络。&lt;/p&gt;
&lt;p&gt;(2) &lt;strong&gt;S-GW：服务网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;S-GW通过S1-U接口来实现用户数据包的路由和转发。实现的功能主要有数据通道、IP头压缩处理、用户数据流加密、针对移动性的用户面的切换、寻呼时用户面数据包的终止。当用户在eNodeB之间移动时，S-GW作为数据承载的本地移动性管理实体。当用户处于空闲状态时， S-GW将保留承载信息并临时把下行数据存储在缓存区里，以便当MME开始寻呼UE时重新建立承载。同时，在与其他3GPP技术如GPRS和UMTS等交互工作时，它可以作为“&lt;strong&gt;移动性管理锚点&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;(3) &lt;strong&gt;MME：移动性管理实体&lt;/strong&gt;
MME是处理UE和核心网络信令交互的控制节点。在UE和核心网络间所执行的协议栈成为非接入层协议（NAS）。MME具有如下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寻呼信息分发。MME负责将寻呼信息按照一定的原则分发到相关的eNodeB;    &lt;/li&gt;
&lt;li&gt;安全控制;  &lt;/li&gt;
&lt;li&gt;空闲状态的移动性管理;  &lt;/li&gt;
&lt;li&gt;SAE（系统架构演进）承载控制;  &lt;/li&gt;
&lt;li&gt;非接入层信令的加密和完整性保护。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(4) &lt;strong&gt;HSS：归属签约用户服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HSS作为用户的集中签约管理数据库，存放了用户的EPS网络签约信息，并完成对UE的位置登记管理，以及结合AUC（鉴权中心）网元完成用户鉴权参数管理，并通过S6a接口下发给 MME完成对UE的鉴权即安全功能。&lt;/p&gt;
&lt;p&gt;(5) &lt;strong&gt;PCRF：策略及计费规则功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PCRF网元是SAE架构中提供集中策略和计费控制的网元。PCRF主要完成策略控制的决定功能及基于不同IP流的计费控制功能。因此，PCRF要结合PCEE（Policy and Charging Enforcement Function）网元 检测后上报的不同业务类型来进行QoS及计费策略方面的决策，并通过Ｇx接口将策略下发给PCEF网元去执行。&lt;/p&gt;
&lt;h3&gt;3.主要业务接口&lt;/h3&gt;
&lt;h3&gt;S1接口&lt;/h3&gt;
&lt;p&gt;S1接口是MME/S-G网关和eNodeB之间的接口。S1接口又可以分为两个接口，一个用于用户平面S1-U，一个用于控制平面S1-MME。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户平面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;S1-U接口用于提供eNodeB与S-GW网元之间用户数据传输功能，其协议栈如图3-1所示。S1-U的传输网络层基于IP传输，UDP/IP协议之上采用GTP-U（GPRS Tunnelling Protocol for User Plane：GPRS用户平面隧道协议）来传输S-GW与eNodeB之间的用户平面PDU。&lt;/p&gt;
&lt;p&gt;&lt;img alt="s1-u" src="http://on64c9tla.bkt.clouddn.com/20160510s1-u-xie-yi-zhan.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图3-1&amp;nbsp;S1-U接口协议栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制平面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;S1-MME也是基于IP传输的，不同的是控制平面在IP层的上面采用SCTP（Stream Control Transmission Protocol：流控制传输协议），为无线网络层信令消息提供可靠的传输，其协议栈如图3-2所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="s1-mme" src="http://on64c9tla.bkt.clouddn.com/20160510s1-mme-xie-yi-zhan.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图3-2&amp;nbsp;S1-MME接口协议栈&lt;/p&gt;
&lt;h3&gt;X2接口&lt;/h3&gt;
&lt;p&gt;X2接口是eNodeB与eNodeB之间的接口，采用了与S1接口一致的原则，其用户平面协议接口与控制平面协议接口均与S1接口类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户平面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;X2接口是eNodeB与eNodeB之间的接口，采用了与S1接口一致的原则，其用户平面协议接口与控制平面协议接口均与S1接口类似。&lt;/p&gt;</content><category term="architecture"></category><category term="lte"></category></entry><entry><title>Git学习手记</title><link href="www.subond.com/pages/2016/04/29/git-xue-xi-shou-ji.html" rel="alternate"></link><published>2016-04-29T00:00:00+08:00</published><updated>2016-04-29T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-04-29:www.subond.com/pages/2016/04/29/git-xue-xi-shou-ji.html</id><summary type="html">&lt;p&gt;Git版本控制功能很强大，作为程序猿必修掌握。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;一、基础篇&lt;/h2&gt;
&lt;h3&gt;指令介绍&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global user.name &lt;span class="s2"&gt;&amp;quot;username&amp;quot;&lt;/span&gt;    &lt;span class="c1"&gt;#配置仓库参数，作为一个标志&lt;/span&gt;
git config --global user.email &lt;span class="s2"&gt;&amp;quot;useremail&amp;quot;&lt;/span&gt;  &lt;span class="c1"&gt;#配置仓库参数，作为一个标志&lt;/span&gt;
git init                      &lt;span class="c1"&gt;#把当前目录变成git可管理的仓库&lt;/span&gt;
git add files          &lt;span class="c1"&gt;#添加文件到暂存区&lt;/span&gt;
git diff file          &lt;span class="c1"&gt;#查看文件的修改内容&lt;/span&gt;
git commit -m &lt;span class="s2"&gt;&amp;quot;提交说明信息&amp;quot;&lt;/span&gt;   &lt;span class="c1"&gt;#提交文件到仓库&lt;/span&gt;
git status                    &lt;span class="c1"&gt;#获取当前仓库中文档的状态&lt;/span&gt;
git log                       &lt;span class="c1"&gt;#查看历史记录&lt;/span&gt;
git log -pretty&lt;span class="o"&gt;=&lt;/span&gt;oneline       &lt;span class="c1"&gt;#单行显示历史信息&lt;/span&gt;
git reflog                    &lt;span class="c1"&gt;#显示版本号&lt;/span&gt;
git checkout -- file          &lt;span class="c1"&gt;#取出文件&lt;/span&gt;
git remote add origin &amp;lt;仓库地址&amp;gt;    &lt;span class="c1"&gt;#添加远程仓库地址&lt;/span&gt;
git push origin &amp;lt;分支名1&amp;gt;          &lt;span class="c1"&gt;#推送本地内容到远程仓库分支1&lt;/span&gt;
git pull origin &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
                                  &lt;span class="c1"&gt;#取回远程主机某个分支，并与本地指定分支合并&lt;/span&gt;
git clone &amp;lt;仓库地址&amp;gt;               &lt;span class="c1"&gt;#克隆远程仓库到本地仓库&lt;/span&gt;
git remote            &lt;span class="c1"&gt;#查看远程仓库信息&lt;/span&gt;
git remote -v         &lt;span class="c1"&gt;#查看远程仓库详细信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;版本回退&lt;/h3&gt;
&lt;p&gt;git reset --hard 版本号(即commit_id)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git reset --hard HEAD^      &lt;span class="c1"&gt;#回退至上一版本&lt;/span&gt;
git reset --hard HEAD^^     &lt;span class="c1"&gt;#回退至上上版本&lt;/span&gt;
git reset --hard HEAD~10    &lt;span class="c1"&gt;#回退至前10个版本&lt;/span&gt;
git reset --hard commit_id  &lt;span class="c1"&gt;#结合git reflog;git log使用&lt;/span&gt;
                            &lt;span class="c1"&gt;#git log可以查看提交历史，以便确定回退到哪个版本;&lt;/span&gt;
                            &lt;span class="c1"&gt;#git reflog可以查看命令历史，以便确定回到未来的哪个版本&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;分支操作&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git branch                &lt;span class="c1"&gt;#查看分支&lt;/span&gt;
git checkout &amp;lt;分支名1&amp;gt;       &lt;span class="c1"&gt;#切换至分支名1&lt;/span&gt;
git checkout -b &amp;lt;分支名1&amp;gt;  &lt;span class="c1"&gt;#创建并切换至分支名1&lt;/span&gt;
git merge &amp;lt;分支名1&amp;gt;        &lt;span class="c1"&gt;#合并分支名1至当前分支&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;提交文件步骤&lt;/h3&gt;
&lt;p&gt;第一步：&lt;code&gt;git add file_name&lt;/code&gt;,提交文件到暂存区(Index)&lt;/p&gt;
&lt;p&gt;第二步：&lt;code&gt;git commit -m "message about file"&lt;/code&gt;,提交文件到本地仓库(Repository)&lt;/p&gt;
&lt;p&gt;第三步：&lt;code&gt;git push origin master&lt;/code&gt;,提交文件到远程仓库master分支(Remote)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 第一次推送至master分支，需要使用-u参数，即&lt;code&gt;git push -u origin master&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="git-mechism" src="http://on64c9tla.bkt.clouddn.com/20160429gitcaozuo.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1 Git基本操作示意图&lt;/p&gt;
&lt;p&gt;几个名词解释：&lt;/p&gt;
&lt;p&gt;Workspace:工作区&lt;br&gt;
Index：暂存区&lt;br&gt;
Repository：仓库区(本地仓库)&lt;br&gt;
Remote：远程仓库  &lt;/p&gt;
&lt;h2&gt;二、进阶篇&lt;/h2&gt;
&lt;h3&gt;分支管理&lt;/h3&gt;
&lt;p&gt;一般而言，主分支master分支是非常稳定的版本，可以用来直接发布，一般情况下不允许直接在上面进行修改。一般都是新建一个dev分支，在dev分支上进行修改操作，工作完成后可合并到主分支master上。其流程一般如下：
1.创建一个dev分支；&lt;br&gt;
2.修改文件内容；&lt;br&gt;
3.添加到暂存区；&lt;br&gt;
4.切换至主分支(msater)； &lt;br&gt;
5.合并dev分支；&lt;br&gt;
6.查看历史记录。  &lt;/p&gt;
&lt;p&gt;注意:合并分支时，git一般使用“Fast Forward”模式，在这种模式下，删除分支后，会丢掉分支信息。为了保证可以随时查看分支信息，合并时可使用命令git merge -no-ff -m "注释信息" dev&lt;/p&gt;
&lt;h3&gt;Stach功能介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;工作过程中，我们一般在自己的分支上修改和调试代码，如果临时接到通知需要修改某个BUG问题，而且自己的工作还需要一段时间才能完成， 而修复BUG问题可能只需要一点时间，此时我们就需要使stash功能。”git stash“通俗地讲就是把当前的工作现场”隐藏起来“，待现场回复后可继续 工作。具体来说就是先使用’git stash'将当前未提交到本地（或服务器）的代码推入git的栈中，这时我们的工作区和上一次提交的内容是一样，所以可以放心的修复BUG问题，等到 修复完成并提交到服务器之后，再使用'git stash apply'将以前的工作应用回来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git stash       &lt;span class="c1"&gt;#备份当前分支的工作区内容，保证工作区内容和上一次提交的内容一致，同时，将当前的工作内容压入git栈中&lt;/span&gt;
git pop         &lt;span class="c1"&gt;#从git栈中读取最近一次保存的内容，恢复工作区的相关内容&lt;/span&gt;
git stash list  &lt;span class="c1"&gt;#显示git栈中所有备份，可以利用列表选择从哪恢复内容&lt;/span&gt;
git stash apply &amp;lt;版本号&amp;gt;   &lt;span class="c1"&gt;#将制定版本号的内容恢复至当前工作区，配合git stash list使用&lt;/span&gt;
git stash clear           &lt;span class="c1"&gt;#清空git栈&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;三、gitbook使用指南&lt;/h2&gt;
&lt;p&gt;gitbook的使用方法和git基本类似，其修改记录，发布版本等相关操作均可参考上面的git指令，略有不同，下面详细介绍：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 初始化书记目录&lt;/span&gt;
gitbook init
&lt;span class="c1"&gt;# 编译图书，可在本地查看&lt;/span&gt;
gitbook serve
&lt;span class="c1"&gt;# 克隆远程图书到本地&lt;/span&gt;
git clone https://git.gitbook.com/user_name/book_name.git
&lt;span class="c1"&gt;# 添加文件&lt;/span&gt;
git add file_name
&lt;span class="c1"&gt;# 提交修改记录&lt;/span&gt;
git commit -m &lt;span class="s2"&gt;&amp;quot;sth about your changes&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# 添加图书的远程地址&lt;/span&gt;
git remote add gitbook https://git.gitbook.com/user_name/book_name.git
&lt;span class="c1"&gt;# 发布图书至远程仓库&lt;/span&gt;
git push -u gitbook master  &lt;span class="c1"&gt;#第一次使用-u参数，之后可以不用加-u参数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="git"></category><category term="gitbook"></category></entry><entry><title>利用Pelican+Github pages搭建个人博客</title><link href="www.subond.com/pages/2016/04/24/pelican-github-chuang-jian-blog.html" rel="alternate"></link><published>2016-04-24T00:00:00+08:00</published><updated>2016-04-24T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-04-24:www.subond.com/pages/2016/04/24/pelican-github-chuang-jian-blog.html</id><summary type="html">&lt;p&gt;本教程基于pelican博客引擎和github page的功能，实现个人博客搭建。&lt;/p&gt;</summary><content type="html">&lt;p&gt;说明：本教程使用的系统平台为ubuntu16.04。&lt;/p&gt;
&lt;h2&gt;Github pages&lt;/h2&gt;
&lt;p&gt;注册Github，并创建一个名为username.github.io的版本库。注意username为自己的用户名。&lt;/p&gt;
&lt;h2&gt;配置本地环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安装Pelican和Markdown&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pelican是一套开源的使用Python编写的博客静态生成，可以添加文章和创建页面，可使用Markdown，reStructuredText和AsiiDoc的格式来书写，同时使用Disqus评论系统，支持 RSS和Atom输出，插件，主题，代码高亮等功能。&lt;/p&gt;
&lt;p&gt;安装Pelican有很多方法，一般采用python的包管理器pip进行安装。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo apt-get install python-pip
$ sudo pip install pelican
$ sudo pip install markdow
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;创建博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建博客目录，然后使用快速生成，具体如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mkdir blog
$ &lt;span class="nb"&gt;cd&lt;/span&gt; blog
$ pelican-quickstart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行pelican-quicstart命令后，会提示博客的配置选项，根据提示操作即可，除必填项之外，其他选择默认即可。如果有需要 可以在之后的pelicanconf.py文件进行修改。完成之后，会出现Pelican框架，如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bolg
&lt;span class="p"&gt;|&lt;/span&gt;__content             &lt;span class="c1"&gt;#存放输入的Markdown文件&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__output              &lt;span class="c1"&gt;#存放最终生成的静态博客网页文件&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__develop_server.sh   &lt;span class="c1"&gt;#本地测试服务器文件&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__Makefile            &lt;span class="c1"&gt;#管理博客的Makefile&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__pelicanconf.py      &lt;span class="c1"&gt;#博客配置文件&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__publishconf.py      &lt;span class="c1"&gt;#发布文件，可删除&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;撰写博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成博客主题搭建后，使用Markdown语法书写博客，完成后保存在content目录下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;     &lt;span class="c1"&gt;//文章名字&lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2016&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;04&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;
&lt;span class="n"&gt;Category&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Python&lt;/span&gt;          &lt;span class="c1"&gt;//文章分类&lt;/span&gt;
&lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;publishing&lt;/span&gt; &lt;span class="c1"&gt;//文章标签&lt;/span&gt;
&lt;span class="n"&gt;Slug&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt;       &lt;span class="c1"&gt;//html文件名&lt;/span&gt;
&lt;span class="n"&gt;Author&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Alexis&lt;/span&gt; &lt;span class="n"&gt;Metaireau&lt;/span&gt;  &lt;span class="c1"&gt;//作者信息&lt;/span&gt;
&lt;span class="n"&gt;Summary&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Short&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;feeds&lt;/span&gt;  &lt;span class="c1"&gt;//文章摘要&lt;/span&gt;

&lt;span class="c1"&gt;//文章正文&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成之后，在blog目录下，执行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ make html
$ ./develop_server.sh start &lt;span class="m"&gt;8000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之后，在浏览器中输入http://localhost:8000 即可看到博客效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发布博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前我们已经在Github上创建了仓库，现在我们就将本地文件搬到远程仓库中，进入output目录下，具体指令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git init
$ git add .
$ git remote add origin https://github.com/username/username.github.io
$ git pull origin master
$ git commit -m &lt;span class="s2"&gt;&amp;quot;First update&amp;quot;&lt;/span&gt;
$ git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成博客发布后，访问http://username.github.io 即可。&lt;/p&gt;
&lt;h2&gt;附：Git简易教程&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git init                    &lt;span class="c1"&gt;#把当前目录变成git可管理的repository&lt;/span&gt;
$ git add &amp;lt;files&amp;gt;             &lt;span class="c1"&gt;#添加文件至缓存区&lt;/span&gt;
$ git commit -m &lt;span class="s2"&gt;&amp;quot;message&amp;quot;&lt;/span&gt;     &lt;span class="c1"&gt;#提交文件&lt;/span&gt;
$ git remote add origin &amp;lt;server&amp;gt;       &lt;span class="c1"&gt;#添加远程服务器&lt;/span&gt;
$ git remote set-url origin &amp;lt;server&amp;gt;   &lt;span class="c1"&gt;#修改远程服务器地址&lt;/span&gt;
$ git push origin master      &lt;span class="c1"&gt;#推送到远程服务器&lt;/span&gt;
$ git status    &lt;span class="c1"&gt;#查看当前各文件状态&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="pelican"></category><category term="blog"></category></entry></feed>