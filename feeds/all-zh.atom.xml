<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>SuperBond</title><link href="www.subond.com/" rel="alternate"></link><link href="www.subond.com/feeds/all-zh.atom.xml" rel="self"></link><id>www.subond.com/</id><updated>2018-05-01T00:00:00+08:00</updated><entry><title>gRPC使用指南</title><link href="www.subond.com/pages/2018/05/01/grpc_helloworld.html" rel="alternate"></link><published>2018-05-01T00:00:00+08:00</published><updated>2018-05-01T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2018-05-01:www.subond.com/pages/2018/05/01/grpc_helloworld.html</id><summary type="html">&lt;p&gt;gRPC是一个高性能、开源、通用的RPC框架，面向移动和HTTP/2设计，并且提供多个语言版本支持。本文章基于golang语言，通过概述和一个简单的HelloWorld来介绍gRPC的基本概念和使用方法。&lt;/p&gt;</summary><content type="html">&lt;p&gt;gRPC是一个高性能、开源、通用的RPC框架，面向移动和HTTP/2设计，并且提供多个语言版本支持。本文章基于golang语言，通过概述和一个简单的HelloWorld来介绍gRPC的基本概念和使用方法。&lt;/p&gt;
&lt;h2&gt;1. gRPC概述&lt;/h2&gt;
&lt;p&gt;gRPC允许客户端应用可以像调用本地对象一样直接调用另一台不同机器上的服务端应用，使开发人员更容易地创建分布式应用和服务。&lt;/p&gt;
&lt;p&gt;在gRPC里，首先需要 &lt;strong&gt;定义一个服务&lt;/strong&gt;，指定其能够被远程调用的方法(包含参数和返回类型)。然后，服务端将实现这个接口，并运行一个gRPC服务器来处理客户端的调用。客户端则拥有一个 &lt;strong&gt;存根&lt;/strong&gt; 能够像服务端一样的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Protocol Buffers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gRPC默认使用Protocol Buffers，这是Google开源的一套成熟的结构数据序列化机制。在proto文件中创建gRPC服务，并且用消息类型来定义相关的参数和返回类型都比较方便，这里我们使用&lt;code&gt;proto3&lt;/code&gt;版本。&lt;/p&gt;
&lt;h2&gt;2. 安装gRPC和proto&lt;/h2&gt;
&lt;p&gt;安装golang，且版本大于等于1.6；并设置相应的环境变量GOPATH,GOROOT等。&lt;/p&gt;
&lt;p&gt;安装gRPC，gRPC使用golang语言编写的，可以直接使用go命令去下载。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;get&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt; &lt;span class="nx"&gt;google&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;golang&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;org&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;grpc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装protobuf，参考&lt;a href="https://github.com/google/protobuf/releases"&gt;https://github.com/google/protobuf/releases&lt;/a&gt;，依据相应的系统平台选择安装包。&lt;/p&gt;
&lt;p&gt;安装protobuf go插件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;get&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt; &lt;span class="nx"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;golang&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;protobuf&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;protoc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;gen&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;3. HelloWorld gRPC&lt;/h2&gt;
&lt;p&gt;这个HelloWorld程序位于gRPC源码的&lt;code&gt;examples&lt;/code&gt;目录下，它展示了一个简单的客户端-服务端应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过proto文件定义一个简单的带有HelloWorld方法的gRPC服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个实现这个接口的服务端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个客户端来访问你的服务端&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指定protobuf版本&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;syntax&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;proto3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;指定包名&lt;/h3&gt;
&lt;p&gt;这个包名就是生成golang源码后所使用的包名。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;helloworld&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义服务&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;service&lt;/code&gt;关键字来定义一个服务，并指定其参数和返回类型。参数和返回类型一般通过&lt;code&gt;message&lt;/code&gt;关键字进行定义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;service&lt;/span&gt; &lt;span class="n"&gt;Greeter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Sends a greeting&lt;/span&gt;
  &lt;span class="k"&gt;rpc&lt;/span&gt; &lt;span class="n"&gt;SayHello&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HelloRequest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;returns&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HelloReply&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// The request message containing the user&amp;#39;s name.&lt;/span&gt;
&lt;span class="kd"&gt;message&lt;/span&gt; &lt;span class="nc"&gt;HelloRequest&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// The response message containing the greetings&lt;/span&gt;
&lt;span class="kd"&gt;message&lt;/span&gt; &lt;span class="nc"&gt;HelloReply&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="kd"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;值得说明的是，在proto文件中定义的service &lt;em&gt;转化&lt;/em&gt; 成golang源码中的interface类型；message类型 &lt;em&gt;转化&lt;/em&gt; 成struct类型。&lt;/p&gt;
&lt;h3&gt;生成golang源码&lt;/h3&gt;
&lt;p&gt;命令&lt;code&gt;protoc helloworld/helloworld.proto --go_out=plugins=grpc:.&lt;/code&gt;可生成proto文件中定义的service和message，文件以&lt;code&gt;.pb.go&lt;/code&gt;结尾。&lt;/p&gt;
&lt;h2&gt;4. 服务端应用&lt;/h2&gt;
&lt;p&gt;服务端编程中，需要首先import刚才生成的包，然后定义server类型，并实现SayHello接口。部分代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;google.golang.org/grpc&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;pb&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;google.golang.org/grpc/examples/helloworld/helloworld&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;// server is used to implement helloworld.GreeterServer.&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;server&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="c1"&gt;// SayHello implements helloworld.GreeterServer&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;server&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;SayHello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt; &lt;span class="nx"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;in&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HelloRequest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HelloReply&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HelloReply&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;Message&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;in&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;main中先生成grpc服务，并注册该服务，部分代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;grpc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="nx"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RegisterGreeterServer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;server&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5. 客户端应用&lt;/h2&gt;
&lt;p&gt;同样，客户端编程中也需要import相应的包，然后通过&lt;code&gt;grpc.Dial()&lt;/code&gt;建立与server的连接，并根据连接生成客户端，在进行rpc调用。部分代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// import相应的包&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;google.golang.org/grpc&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;pb&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;google.golang.org/grpc/examples/helloworld/helloworld&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;// 建立与server的连接&lt;/span&gt;
&lt;span class="nx"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;grpc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Dial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;address&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;grpc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WithInsecure&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="c1"&gt;// 生成客户端&lt;/span&gt;
&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewGreeterClient&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;// 调用server的方法&lt;/span&gt;
&lt;span class="nx"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;SayHello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HelloRequest&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;值得注意的是，调用结束后连接需要释放。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;6. 启动服务端与客户端&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 启动服务端&lt;/span&gt;
&lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;run&lt;/span&gt; &lt;span class="nx"&gt;server&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;go&lt;/span&gt;

&lt;span class="c1"&gt;// 启动客户端&lt;/span&gt;
&lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;run&lt;/span&gt; &lt;span class="nx"&gt;client&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="tech"></category><category term="golang"></category><category term="rpc"></category></entry><entry><title>年轻的自信与成熟的笃定</title><link href="www.subond.com/pages/2017/11/19/confident_and_certainty.html" rel="alternate"></link><published>2017-11-19T00:00:00+08:00</published><updated>2017-11-19T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-11-19:www.subond.com/pages/2017/11/19/confident_and_certainty.html</id><summary type="html">&lt;p&gt;当一个年轻人开始逐渐摆脱盲目自信的时候，脚步更加坚定的时候，他迎来的是更加成熟的笃定。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;当一个年轻人开始逐渐摆脱盲目自信的时候，脚步更加坚定的时候，他迎来的是更加成熟的笃定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天吴晓波频道（微信号公众号：wuxiaobopd）推送了一篇文章，叫做《月入2万，95后还觉得自己活得不如狗？》，文中提到极光大数据发布的&lt;a href="https://www.jiguang.cn/reports/116"&gt;《95后群体画像研究报告》&lt;/a&gt;，于是便找来看了一番。其中，让我感兴趣的部分是如何看待比自己早生/晚生10年的一代人。&lt;/p&gt;
&lt;p&gt;&lt;img alt="9501" src="http://on64c9tla.bkt.clouddn.com/Reads/9501.GIF"&gt;
&lt;img alt="9502" src="http://on64c9tla.bkt.clouddn.com/Reads/9502.GIF"&gt;&lt;/p&gt;
&lt;p&gt;数据表明，相比其他年龄群体，95后对85后的评价普遍偏低，同样对“晚辈”（05后）的评价也不高，但是对于自己的评价，42.7%的人认为自己重诚信，尊老爱幼，乐于助人、爱国、孝顺、有礼貌的爱国青年。&lt;/p&gt;
&lt;p&gt;&lt;img alt="9503" src="http://on64c9tla.bkt.clouddn.com/Reads/9503.GIF"&gt;&lt;/p&gt;
&lt;p&gt;这种种数据表明，&lt;strong&gt;95后是自信的一代&lt;/strong&gt;。当然，这并不是没有任何理由。作为90后，我们生活在长期和平的年代，1978年改革开放后，无论是城市还是农村，生活水平都有不同程度的提高。我们的父母都是改革开放的见证者，等到我们出生的时候，温饱问题基本上解决了（除了少数偏远山村）。与此同时，90s年代，又是信息技术发展的快速时期，使我们这一代从小就接触到电脑，互联网。这样良好的成长环境使我们更加自信，&lt;/p&gt;
&lt;p&gt;但是，我想说的是，自信并不属于95后，而是属于年轻人。纳什·沃夏尔·硕得提出的"社会三定律"讲的就是这个道理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一，任何比我早出生10年及以上的人都是裹步不前的老顽固。&lt;br&gt;
二，任何出生时间和我相差10年以内的人都是这个社会的精英，中流砥柱。&lt;br&gt;
三，任何比我晚出生10年及以上的人都是无可救药垮掉的一代。 ​​​​  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，自信永远属于年轻人，自命不凡的年轻人。年少无知，无知即无畏。初生牛犊不怕虎，说的正是年轻人。&lt;/p&gt;
&lt;p&gt;正如，当一个人开始怀念少年时光的时候，他的少年时代就已经一去不复返了，此时此刻的他俨然成了一个有责任的青年人。同样，当一个年轻人开始逐渐摆脱盲目自信的时候，脚步更加坚定的时候，他迎来的是更加成熟的笃定。&lt;/p&gt;</content><category term="reading"></category><category term="work"></category><category term="growth"></category></entry><entry><title>关于找工作的两个基本事实</title><link href="www.subond.com/pages/2017/11/08/two_fundamental_truths_about_work.html" rel="alternate"></link><published>2017-11-08T00:00:00+08:00</published><updated>2017-11-08T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-11-08:www.subond.com/pages/2017/11/08/two_fundamental_truths_about_work.html</id><summary type="html">&lt;p&gt;对于应届毕业生而言，由于缺乏工作经验，对工作环境缺少了解，往往不能够很快地进入工作状态。这时候，如果能够获得一份不错的实习机会，对今后的工作可以说是大有裨益。&lt;/p&gt;</summary><content type="html">&lt;p&gt;对于应届毕业生而言，由于缺乏工作经验，对工作环境缺少了解，往往不能够很快地进入工作状态。这时候，如果能够获得一份不错的实习机会，对今后的工作可以说是大有裨益。&lt;/p&gt;
&lt;p&gt;一份良好的实习不仅可以帮助我们了解真实的工作环境和氛围，而且可以帮助我们调整自己的心态，逐步从校园生活过渡到社会生活。同时，如果在实习工作中培养了自己良好的工作习惯和职业操守，对于技术类实习生而言，还能够提高自己的技术水平，那自然是更好的事情了。&lt;/p&gt;
&lt;p&gt;那么，对于找实习，甚至是找工作来说，我觉着有两个基本事实需要求职者明白，并做好的相应的应对措施。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事实一：工作机会总是有的，只是合适人却不常有。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为接受过高等教育的应届生，社会上的工作机会总是有的，所以，不要担心工作问题，一定要注意自己作为求职者的自信。除了没有工作经验，你没有比任何人差，甚至有些时候，没有工作经验还是好事。&lt;em&gt;没有工作经验，在工作中往往更有利于发挥你的创新能力，也更有职业的可塑性的可能&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;“千里马常有，而伯乐不常有”。对于工作，也是同样的道理。几乎没有人能够完全匹配一项工作。对于某些关键岗位来说，合适的人就更加少了，为了找的这样的人，公司也往往不惜花费重金。&lt;/p&gt;
&lt;p&gt;因此，&lt;em&gt;与其找工作，不如让工作来找你&lt;/em&gt;，让自己成为那个最合适的人选，做到主动择业。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事实二：好的工作机会是有限的，就像社会资源有限一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，什么是好的工作机会？我想应该具备以下两个特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;工作内容具有一定程度的挑战性&lt;/em&gt;。作为求职者，求职过程中我们往往寻找那些与我们能力相匹配的工作岗位。但是，事实却是具有一定挑战性的工作往往更容易激发我们的工作热情，发掘个人的工作能力。不然，一份工作就变成毫无意义的 &lt;em&gt;重复性劳动&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;一份好的工作，应该是下一份工作的基础&lt;/em&gt;。现代社会的发展非常迅速，几乎没有人能够一生只在一个岗位上工作。既然是这样，那么现在的工作应该而且必须成为我们下一次择业的基础。因此，设想自己3-5年后的工作，然后反推。即如果自己想要获取那样的工作，应该具备什么的工作能力，专业素质等，并依次为依据作为这次工作应该着重培养的能力。如果，这份工作能够满足未来的期望，那么它就是一个好工作。这样想来，好工作就是有限的资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于公司而言，面向应届生招聘也往往看重应届生对基础知识的把握。而对应届生而言，大多数人所具备的专业知识又是&lt;em&gt;相对同质化的&lt;/em&gt;，而且，简单的30分钟左右的面试，也不能很好地评估一个人所具备的能力。所以说，一份你能胜任的好工作，意味着你的同学也同样可以胜任。但是，好机会的名额却是有限的。那么，想要获得这样的好工作，就要&lt;em&gt;抢占先机&lt;/em&gt;，尽早地拿到这个名额。所以，有些时候，并不是你不适合这个工作，而是你来晚了。对这一点，你要有心理准备。&lt;/p&gt;</content><category term="work"></category><category term="growth"></category></entry><entry><title>初入职场</title><link href="www.subond.com/pages/2017/10/08/starting_job.html" rel="alternate"></link><published>2017-10-08T00:00:00+08:00</published><updated>2017-10-08T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-10-08:www.subond.com/pages/2017/10/08/starting_job.html</id><summary type="html">&lt;p&gt;“如何有机会让现在的你遇到刚毕业初入职场的你，你会对他说什么？”这是一个知乎上的问题，以下的回答部门节选自冯大辉。&lt;/p&gt;</summary><content type="html">&lt;p&gt;“如何有机会让现在的你遇到刚毕业初入职场的你，你会对他说什么？”这是一个知乎上的问题，以下的回答部门节选自冯大辉。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;能力的提升比薪资更重要，尽管现在的你比较缺钱。【这个观点与吴军老师的观点不谋而合。初入职场，重要的是提升自己的能力，培养良好的工作习惯。因为，现阶段的薪资就基本上是挣多少花多少，而能力的提升与培养才能够让你有机会在3-5年后拿到同龄人3-5倍的薪酬。】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意仪表仪容，尽管你是一个工程师。【没有人会通过一个邋遢的外表去关注一个有趣的灵魂。】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你的同事不是笨蛋，你的客户也不是白痴，你自己才是蠢货。【遇事多找自身原因，摆脱学生时代的依赖，学会自己去处理任何事情。】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;做好每一个小事，处理好每一件小事的细节；如果做不好的地方多总结，找出原因并改进。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;培养一个好习惯。比如每天工作记录，每天回顾自己，每天Review代码。一段时间之后你就会发现，好习惯可以秒杀一部分人；如果能够多培养几个好习惯，你就会变得优秀，甚至卓越。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高沟通能力，注意写作。适应跟不同风格的人协作；能够把一件事情讲清楚，写清楚。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锻炼身体，这是_革命的本钱_。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;靠谱就是三件事：“凡事有交代，件件有着落，事事有回音”。——罗振宇&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="carrer"></category><category term="work"></category></entry><entry><title>Vagrant使用案例</title><link href="www.subond.com/pages/2017/05/15/vagrant_usage.html" rel="alternate"></link><published>2017-05-15T00:00:00+08:00</published><updated>2017-05-15T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-05-15:www.subond.com/pages/2017/05/15/vagrant_usage.html</id><summary type="html">&lt;h2&gt;1.单机配置&lt;/h2&gt;
&lt;p&gt;1) 配置一个centos7系统，要求使用私有网络地址&lt;code&gt;192.168.10.10&lt;/code&gt;，hostname为dbserver。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Vagrant&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;dbserver&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="n"&gt;dbserver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;centos/7&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;dbserver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;private_network&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;192.168.10.10&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;dbserver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;dbserver&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要说明的是：使用私有地址，vm的私有ip只能在各vm间互访，而不能访问Internet，即HOST_ONLY模式；使用公有地址，vm的公有地址将于主机某个网卡(启动vm时需指定)的地址同一网段，vm能够使用该地址访问Internet。&lt;/p&gt;
&lt;p&gt;2) 配置一个ubuntu xenial64系统，并将工程目录下的&lt;code&gt;data&lt;/code&gt;目录同步到vm中 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.单机配置&lt;/h2&gt;
&lt;p&gt;1) 配置一个centos7系统，要求使用私有网络地址&lt;code&gt;192.168.10.10&lt;/code&gt;，hostname为dbserver。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Vagrant&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;dbserver&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="n"&gt;dbserver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;centos/7&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;dbserver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;private_network&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;192.168.10.10&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;dbserver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;dbserver&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要说明的是：使用私有地址，vm的私有ip只能在各vm间互访，而不能访问Internet，即HOST_ONLY模式；使用公有地址，vm的公有地址将于主机某个网卡(启动vm时需指定)的地址同一网段，vm能够使用该地址访问Internet。&lt;/p&gt;
&lt;p&gt;2) 配置一个ubuntu xenial64系统，并将工程目录下的&lt;code&gt;data&lt;/code&gt;目录同步到vm中，目录为&lt;code&gt;/vagrant/project_data&lt;/code&gt;；同时将vm的80端口映射到主机的8080端口。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Vagrant&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;ubuntu16&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="n"&gt;ubuntu16&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ubuntu/xenial64&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;ubuntu16&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;forwarded_port&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;guest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;host&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8080&lt;/span&gt;
  &lt;span class="n"&gt;ubuntu16&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;synced_folder&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/subond/UCloud/VHost/data&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/project_data&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要说明的是：指定同步文件时，第一个参数既可以当前工程目录的相对目录，也可以是主机上的绝对路径；第二个参数是vm中的绝对路径。默认情况下，当前工程目录下的文件将同步至vm中的&lt;code&gt;/vagrant&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;3) 配置一个centos7系统，要求设置vm的名字为&lt;code&gt;foobar&lt;/code&gt;,内存大小为512M。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Vagrant&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;centos&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="n"&gt;centos&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;centos/7&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;centos&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;virtualbox&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;customize&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;modifyvm&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;--name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;--memory&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;512&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;2.分布式系统配置&lt;/h2&gt;
&lt;p&gt;1) 创建两个主机，一个做服务端，hostname为&lt;code&gt;server&lt;/code&gt;,一个做客户端，hostname为&lt;code&gt;client&lt;/code&gt;，两个虚拟均设置私有网络，并配置dhcp服务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Vagrant&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;subond&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="n"&gt;subond&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;centos/7&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;subond&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;server&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;private_network&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;dhcp&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;server&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="n"&gt;subond&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;client&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;private_network&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;dhcp&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;client&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2) 创建一个具有三个节点的集群，hostname分别为&lt;code&gt;node1&lt;/code&gt;,&lt;code&gt;node2&lt;/code&gt;,&lt;code&gt;node3&lt;/code&gt;,并设置私有网络；节点大小Mem = 2048,CPU = 1；同时将其配置成docker开发环境。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Vagrant&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;node&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
      &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;centos/7&amp;quot;&lt;/span&gt;
      &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;node&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
      &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;private_network&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;192.168.10.&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
      &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;virtualbox&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
         &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;node&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2048&lt;/span&gt;
         &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cpus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
      &lt;span class="k"&gt;end&lt;/span&gt;
      &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;provision&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;shell&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;inline&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;-&lt;/span&gt;&lt;span class="dl"&gt;SHELL&lt;/span&gt;
&lt;span class="sh"&gt;        yum install wget -y&lt;/span&gt;
&lt;span class="sh"&gt;        wget -P /home/vagrant https://download.docker.com/linux/centos/7/x86_64/stabl    e/Packages/docker-ce-18.03.1.ce-1.el7.centos.x86_64.rpm&lt;/span&gt;
&lt;span class="sh"&gt;        yum install /home/vagrant/docker-ce-18.03.1.ce-1.el7.centos.x86_64.rpm -y&lt;/span&gt;
&lt;span class="dl"&gt;       SHELL&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要的说明的是：如果需要shell功能，最好的方式就是单独写shell脚本，通过文件同步的方式注入虚机；安装包文件也最好使用这种方式，速度会快一些。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1]. &lt;a href="https://segmentfault.com/a/1190000005875116"&gt;使用Vagrant创建多节点虚拟机集群&lt;/a&gt;&lt;br&gt;
[2]. &lt;a href="https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-ce"&gt;docker安装&lt;/a&gt;&lt;br&gt;
[3]. &lt;a href="https://www.vagrantup.com/docs/providers/configuration.html"&gt;vagrant provider配置&lt;/a&gt;&lt;br&gt;
[4]. &lt;a href="https://www.vagrantup.com/docs/provisioning/"&gt;vagrant provision配置&lt;/a&gt;  &lt;/p&gt;</content><category term="vagrant"></category><category term="cloud"></category></entry><entry><title>Vagrant的快速使用</title><link href="www.subond.com/pages/2017/05/10/vagrant_startup.html" rel="alternate"></link><published>2017-05-10T00:00:00+08:00</published><updated>2017-05-10T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-05-10:www.subond.com/pages/2017/05/10/vagrant_startup.html</id><summary type="html">&lt;p&gt;Vagrant是为了方便的实现虚拟化环境而设计的，使用Ruby语言开发，基于VirtualBox等虚拟机管理软件的接口，提供了一个可配置、轻量级的便携式虚拟开发环境。使用Vagrant可以很方便的就建立起来一个虚拟环境，而且可以模拟多台虚拟机，形成分布式系统。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Vagrant是为了方便的实现虚拟化环境而设计的，使用Ruby语言开发，基于VirtualBox等虚拟机管理软件的接口，提供了一个可配置、轻量级的便携式虚拟开发环境。使用Vagrant可以很方便的就建立起来一个虚拟环境，而且可以模拟多台虚拟机，形成分布式系统。&lt;/p&gt;
&lt;p&gt;其次，Vagrant还可以实现文件共享，即用于主机和虚拟之间共享文件，方便开发人员在主机上写程序，再往虚拟里拷贝的麻烦。而且，Vagrant的package功能还可以将完整的开发环境进行打包，供其他人使用，极大地提高了工作效率。&lt;/p&gt;
&lt;h2&gt;1.Vagrant安装&lt;/h2&gt;
&lt;p&gt;Vagrant只是一个方便创建，管理虚拟的便携式工具，底层支持由VirtualBox、VMware等虚拟机系统支持。本文以VirtualBox为例，主机系统为Mac OSX。&lt;/p&gt;
&lt;h3&gt;VirtualBox安装&lt;/h3&gt;
&lt;p&gt;这是Virtual官网链接&lt;a href="https://www.virtualbox.org/wiki/Downloads"&gt;https://www.virtualbox.org/wiki/Downloads&lt;/a&gt;，可以依据自己的系统选择合适的安装包进行安装。&lt;/p&gt;
&lt;h3&gt;Vagrant安装&lt;/h3&gt;
&lt;p&gt;Vagrant官网&lt;a href="https://www.vagrantup.com/downloads.html"&gt;https://www.vagrantup.com/downloads.html&lt;/a&gt;，同样需要依据自己的系统选择合适的安装包进行安装。&lt;/p&gt;
&lt;h2&gt;2.Vagrant配置&lt;/h2&gt;
&lt;p&gt;Vagrant配置主要在&lt;code&gt;Vagrantfile&lt;/code&gt;文件中，通过&lt;code&gt;vagrant init&lt;/code&gt;命令可以获得。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mkdir MyHost
$ &lt;span class="nb"&gt;cd&lt;/span&gt; MyHost
$ vagrant init
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在MyHost文件夹下就会出现&lt;code&gt;Vagrantfile&lt;/code&gt;文件，该文件是配置虚机的主要的文件。例如，我们想要创建一个Ubuntu Xenial 64位的虚机，并设置虚机的hostname为ubuntu64，则&lt;code&gt;Vagrantfile&lt;/code&gt;中进行如下修改：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ubuntu/xenial64&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ubuntu64&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;3.启动虚拟&lt;/h2&gt;
&lt;p&gt;在MyHost目录下，通过命令&lt;code&gt;vagrant up&lt;/code&gt;即可启动在&lt;code&gt;Vagrantfile&lt;/code&gt;文件中配置的虚拟。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ vagrant up
&lt;span class="c1"&gt;# 进入虚拟&lt;/span&gt;
$ vagrant ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;4.Vagrantfile详解&lt;/h2&gt;
&lt;p&gt;1) 语言版本&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Vagrant&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中"2"指定Vagrantfile所使用的语言版本，一般为&lt;code&gt;2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;2) box相关&lt;/p&gt;
&lt;p&gt;指定创建虚机vm所需的box&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ubuntu/xenial64&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置vm的hostname&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ubuntu64&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置vm的网络，如果是设置私有网络，需指定ip地址；如果设置公有网络，则不需要。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 设置私有网络&lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;private_network&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;192.168.33.10&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# 设置公有网络&lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;public_network&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# 设置端口映射，即vm80端口映射到主机8080端口&lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;forwarded_port&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;guest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;host&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3) 文件同步&lt;/p&gt;
&lt;p&gt;将主机的文件(或目录)挂载到vm中，实现文件同步。&lt;br&gt;
第一个参数是主机的文件路径，第二个参数是vm里面的路径。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;synced_folder&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;../data&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/vagrant_data&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.Vagrant常用命令&lt;/h2&gt;
&lt;p&gt;1) box管理&lt;/p&gt;
&lt;p&gt;包括添加、删除、更新等等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ vagrant box
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2) 虚机的管理&lt;/p&gt;
&lt;p&gt;包括启动，摧毁、打包，重载等等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 关掉虚拟&lt;/span&gt;
$ vagrant halt

&lt;span class="c1"&gt;# 重载虚拟，即修改虚拟的配置后(Vagrantfile)需要重载才能生效&lt;/span&gt;
$ vagrant reload

&lt;span class="c1"&gt;# 摧毁整个虚拟及其相关文件&lt;/span&gt;
$ vagrant destory

&lt;span class="c1"&gt;# 将整个虚拟打包成一个box文件,&lt;/span&gt;
$ vagrant package
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1]. Getting Started Vagrant&lt;a href="https://www.vagrantup.com/intro/index.html"&gt;https://www.vagrantup.com/intro/index.html&lt;/a&gt;&lt;br&gt;
[2]. Vagrant安装配置&lt;a href="https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/01.2.md"&gt;https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/01.2.md&lt;/a&gt;  &lt;/p&gt;</content><category term="vagrant"></category><category term="cloud"></category></entry><entry><title>Docker进阶：服务配置</title><link href="www.subond.com/pages/2017/05/01/docker-swarm-jin-jie2.html" rel="alternate"></link><published>2017-05-01T00:00:00+08:00</published><updated>2017-05-01T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-05-01:www.subond.com/pages/2017/05/01/docker-swarm-jin-jie2.html</id><summary type="html">&lt;p&gt;当使用Docker Swarm模式时，我们可以通过命令&lt;code&gt;docker service create&lt;/code&gt;向Swarm集群部署应用服务。Swarm集群中的管理节点将服务描述视为应用服务所需的状态。其次，所有服务相关的命令，即&lt;code&gt;docker service&lt;/code&gt;，一定要在管理节点上运行(管理节点负责Swarm集群中的服务管理和任务编排)。&lt;/p&gt;</summary><content type="html">&lt;p&gt;当使用Docker Swarm模式时，我们可以通过命令&lt;code&gt;docker service create&lt;/code&gt;向Swarm集群部署应用服务。Swarm集群中的管理节点将服务描述视为应用服务所需的状态。其次，所有服务相关的命令，即&lt;code&gt;docker service&lt;/code&gt;，一定要在管理节点上运行(管理节点负责Swarm集群中的服务管理和任务编排)。&lt;/p&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#创建服务"&gt;创建服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#配置服务"&gt;配置服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;创建服务&lt;/h3&gt;
&lt;p&gt;Swarm集群中最简单创建服务的方式就是指定所要创建的服务镜像就可以，即命令&lt;code&gt;docker service create &amp;lt;IMAGE&amp;gt;&lt;/code&gt;。当执行创建服务命令后，Swarm编排器则向可用节点分派服务任务。一个任务其实就是一个基于指定镜像生成的容器。比如，创建一个nginx web服务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在管理节点上
# --name参数用于指定服务的名称
$ docker service create --name myweb nginx
l3w3x4df6tnia8qql64mkdm1s
# 查看Swarm集群中的服务
$ docker service ls
ID            NAME   MODE        REPLICAS  IMAGE
l3w3x4df6tni  myweb  replicated  1/1       nginx:latest
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，我们也可以在部署服务时指定容器中将要运行的指令，其命令为&lt;code&gt;docker service create &amp;lt;IMAGE&amp;gt; &amp;lt;COMMAND&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker service create --name myalpine ping www.bing.com
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;服务配置&lt;/h3&gt;
&lt;p&gt;当创建一个服务时，我们通过修改配置选项对服务进行限制，命令&lt;code&gt;docker service create --help&lt;/code&gt;可以查看创建服务的帮助信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置服务的运行环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过以下参数配置服务的运行环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;--env参数可以指定环境变量&lt;/li&gt;
&lt;li&gt;--workdir参数可以指定容器中的工作目录&lt;/li&gt;
&lt;li&gt;--user参数可以指定用户名或者UID&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 通过不同的参数配置服务
$ docker service create --name myservice \
  --env MYSERVICE=/usr/local/service
  --workdir /tmp
  --user subond
  alpine ping www.baidu.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;配置服务规模和位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面的介绍中，我们讲到Swarm模式中有两种服务类型：复制服务(replicated service)和全局服务(global service)。对于复制服务类型，我们可指定--replicas参数来创建一定数量的服务任务，从而将任务分派到可用节点上；而对于全局服务，调度器则在每一个可用节点上均部署一个任务，--mode参数可以指定全局服务。具体如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在具有一个管理节点(manager)和一个工作节点(worker1)的Swarm集群中，部署一个具有两个副本的nginx web服务
# 在节点manger
$ docker node ls
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
34y77dgnqon4soj2kqyb65a9y *  manager   Ready   Active        Leader
nxb55hhu8kwp272z21xi9dhyy    worker1   Ready   Active
$ docker service create --name myweb1 --replicas 3 nginx
xpmhprvzqtl1fi0mdveowjdoa
# 创建成功
# docker service ls
ID            NAME    MODE        REPLICAS  IMAGE
xpmhprvzqtl1  myweb1  replicated  2/2       nginx:latest
$ docker ps
CONTAINER ID        IMAGE                                                                           COMMAND                  CREATED             STATUS              PORTS               NAMES
27aa642e7786        nginx@sha256:12d30ce421ad530494d588f87b2328ddc3cae666e77ea1ae5ac3a6661e52cde6   &amp;quot;nginx -g &amp;#39;daemon ...&amp;quot;   59 seconds ago      Up 58 seconds       80/tcp              myweb1.1.ei5mappmkkcdhbnk6gv3tcgrf

# 在节点worker1
$ docker ps
CONTAINER ID        IMAGE                                                                           COMMAND                  CREATED              STATUS              PORTS               NAMES
245a257c56d5        nginx@sha256:12d30ce421ad530494d588f87b2328ddc3cae666e77ea1ae5ac3a6661e52cde6   &amp;quot;nginx -g &amp;#39;daemon ...&amp;quot;   About a minute ago   Up About a minute   80/tcp              myweb1.2.y2am04ermd2b8d3qevfeyzn67
# 我们的可以看到在两个节点上均有一个myweb1服务

# 接下来，我们再部署一个myweb2服务，与myweb1不同的是，myweb2是全局服务
# 在manager节点上
$ docker service create --name myweb2 --mode global nginx
yfbd525ztbqpa688ego4u0de8
$ docker service ls
ID            NAME    MODE        REPLICAS  IMAGE
xpmhprvzqtl1  myweb1  replicated  2/2       nginx:latest
yfbd525ztbqp  myweb2  global      2/2       nginx:latest
$ docker ps
CONTAINER ID        IMAGE                                                                           COMMAND                  CREATED              STATUS              PORTS               NAMES
5a99dca94917        nginx@sha256:12d30ce421ad530494d588f87b2328ddc3cae666e77ea1ae5ac3a6661e52cde6   &amp;quot;nginx -g &amp;#39;daemon ...&amp;quot;   About a minute ago   Up About a minute   80/tcp              myweb2.34y77dgnqon4soj2kqyb65a9y.rush02tpvachu294flrklw32p
27aa642e7786        nginx@sha256:12d30ce421ad530494d588f87b2328ddc3cae666e77ea1ae5ac3a6661e52cde6   &amp;quot;nginx -g &amp;#39;daemon ...&amp;quot;   8 minutes ago        Up 8 minutes        80/tcp              myweb1.1.ei5mappmkkcdhbnk6gv3tcgrf

# 在worker1节点上
$ docker ps
CONTAINER ID        IMAGE                                                                           COMMAND                  CREATED              STATUS              PORTS               NAMES
3a00f5c5ce9b        nginx@sha256:12d30ce421ad530494d588f87b2328ddc3cae666e77ea1ae5ac3a6661e52cde6   &amp;quot;nginx -g &amp;#39;daemon ...&amp;quot;   About a minute ago   Up About a minute   80/tcp              myweb2.nxb55hhu8kwp272z21xi9dhyy.on9e6cr8obz3y51e84b3s72z4
245a257c56d5        nginx@sha256:12d30ce421ad530494d588f87b2328ddc3cae666e77ea1ae5ac3a6661e52cde6   &amp;quot;nginx -g &amp;#39;daemon ...&amp;quot;   8 minutes ago        Up 8 minutes        80/tcp              myweb1.2.y2am04ermd2b8d3qevfeyzn67

# 接下来，我们将工作节点worker2加入Swarm集群
$ 在worker2节点上
$ docker swarm join \
  --token SWMTKN-1-1omg2k2e92snxv3wlja3komux5wan4hynn80ikkma2s9rd5cxz-9hq2vf8n0jysukytfqpavd8j7 \
  172.28.128.3:2377
This node joined a swarm as a worker.
# 在manager节点上
$ docker node ls
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
34y77dgnqon4soj2kqyb65a9y *  manager   Ready   Active        Leader
nxb55hhu8kwp272z21xi9dhyy    worker1   Ready   Active
v0rmad0igl7xwn8alop33j3fu    worker2   Ready   Active

# 在worker2节点上
$ docker ps
CONTAINER ID        IMAGE                                                                           COMMAND                  CREATED             STATUS              PORTS               NAMES
356da4542dd5        nginx@sha256:12d30ce421ad530494d588f87b2328ddc3cae666e77ea1ae5ac3a6661e52cde6   &amp;quot;nginx -g &amp;#39;daemon ...&amp;quot;   40 seconds ago      Up 39 seconds       80/tcp              myweb2.v0rmad0igl7xwn8alop33j3fu.5wa1pg01i73u3a1feb73ht5p5
# 可以看到worker2上具有myweb2的服务，而不具备myweb1服务
# 这是复制服务和全局的模式的重要区别
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;配置发布端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当创建Swarm服务时，有两个方式将服务的端口发布到Swarm群外的主机端口上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依靠路由网络。当我们发布一个服务端口时，无论节点上是否运行着服务的任务，Swarm都会在每个节点的目标端口上访问该服务。&lt;/li&gt;
&lt;li&gt;直接在运行该服务任务的节点上发布服务端口。Docker1.13及其更高版本支持该功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一种：依靠路由网络发布端口&lt;/p&gt;
&lt;p&gt;我们可以通过参数--publish &lt;target-port&gt;:&lt;service-port&gt;发布服务的端口。Swarm使得服务在每个节点的目标端口均可达。如果外部主机连接到Swarm集群中的任何一个节点，都可以通过路由网络将其路由到服务任务所在的节点上。外部主机不要知道服务任务所在的ip和内部使用的服务端口就可以与服务进行交互。&lt;/p&gt;
&lt;p&gt;例如，我们在一个具有3个节点的Swarm集群中运行一个具有2个副本的nginx web服务，并将发布端口设为8080。那么，在任何一个节点上可以使用8080端口上的nging服务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在manger节点上部署nginx web服务，并发布8080端口
$ docker service create --name myweb --replicas 2 --publish 8080:80 nginx
# 通过检查，我们发现在manager节点和worker2节点均有myweb任务
# 在worker1节点请求nginx服务
$ curl localhost:8080
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Welcome to nginx!&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
...
&lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;外部主机上，使用任何一个节点的ip均可以访问到nginx服务，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nginx服务" src="http://on64c9tla.bkt.clouddn.com/Comput/docker_nginx.png"&gt;&lt;/p&gt;
&lt;p&gt;第二种：在Swarm节点上发布端口&lt;/p&gt;
&lt;p&gt;通过指定mode=host来进行参数--publish的设定，我们可以将发布端口指定到每个运行服务任务的Swarm节点上。&lt;/p&gt;
&lt;p&gt;主要注意的是：如果使用mode=host直接在Swarm节点上发布服务的端口，并且还设置published=&lt;PORT&gt;，则会创建一个隐式限制，只能在给定的群组节点上为该服务运行一个任务。 另外，如果使用mode=host，并且在docker服务创建时不使用--mode=global标志，那么将难以知道哪些节点正在运行服务，以便将工作路由到它们。&lt;/p&gt;
&lt;p&gt;接下来，我们创建一个全局服务类型的nginx web服务，并将发布端口指定为8090。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在manager节点上
$ docker service create --name mynginx --mode global --publish mode=host,target=80,published=8090 nginx
# 这样我们可以在Swarm任何一个节点上访问到8090端口上的nginx服务，即使新加入的节点。
&lt;/pre&gt;&lt;/div&gt;</content><category term="Cloud"></category><category term="Docker"></category></entry><entry><title>Docker进阶：以Swarm模式运行Docker引擎</title><link href="www.subond.com/pages/2017/04/28/docker-swarm-jin-jie1.html" rel="alternate"></link><published>2017-04-28T00:00:00+08:00</published><updated>2017-04-28T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-28:www.subond.com/pages/2017/04/28/docker-swarm-jin-jie1.html</id><summary type="html">&lt;p&gt;Docker Engine 1.12及后续版本支持Swarm模式，我们可以通过以下两种方式开始Swarm模式：创建一个Swarm集群和加入一个已有的Swarm集群。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Docker Engine 1.12及后续版本支持Swarm模式，我们可以通过以下两种方式开始Swarm模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个Swarm集群&lt;/li&gt;
&lt;li&gt;加入一个已有的Swarm集群&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#创建Swarm"&gt;创建Swarm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#加入Swarm"&gt;加入Swarm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#节点管理"&gt;节点管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;创建Swarm&lt;/h3&gt;
&lt;p&gt;当我们使用命令行创建一个Swarm集群时，Docker引擎将启用Swarm模式。当执行&lt;code&gt;docker swarm init&lt;/code&gt;命令时，Docker引擎将启动一个Swarm集群，主要过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将当前的模式切换至Swarm模式，并创建一个名为&lt;code&gt;default&lt;/code&gt;的Swarm&lt;/li&gt;
&lt;li&gt;指定当前节点为Swarm的管理节点，并以当前主机名命名当前节点&lt;/li&gt;
&lt;li&gt;配置网络监听端口，端口号为2377&lt;/li&gt;
&lt;li&gt;将当前节点设置为&lt;code&gt;Active&lt;/code&gt;状态，意味着该节点可以接收调度器分派的任务&lt;/li&gt;
&lt;li&gt;启动一个全局分布式数据中心，存储并维护Swarm信息和服务信息&lt;/li&gt;
&lt;li&gt;默认情况下，为Swarm集群生成自签名根CA&lt;/li&gt;
&lt;li&gt;默认情况下，生成工作节点和管理节点的token(令牌)，用于其他节点加入该Swarm&lt;/li&gt;
&lt;li&gt;创建一个名为&lt;code&gt;ingress&lt;/code&gt;的overlay网络，用于对外发布服务端口&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 创建一个swarm
$ docker swarm init
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;配置通告地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管理节点通过通告地址(advertise address)来允许Swarm集群中的其他节点访问Swarmkit API和覆盖网络。Swarm集群上的其他节点必须能够访问其通告地址(Ip地址)上的管理节点。&lt;/p&gt;
&lt;p&gt;如果不指定通告地址，Docker则通过检查系统IP，设置其中一个为通告地址，并监听2377端口。如果系统有多个Ip，最好通过--advertise-addr配置通告地址，以便其他节点能够与管理节点进行通信。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 设置通告地址
$ docker swarm init --advertise-addr 172.28.128.3:2377
Swarm initialized: current node (34y77dgnqon4soj2kqyb65a9y) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-1omg2k2e92snxv3wlja3komux5wan4hynn80ikkma2s9rd5cxz-9hq2vf8n0jysukytfqpavd8j7 \
    172.28.128.3:2377

To add a manager to this swarm, run &amp;#39;docker swarm join-token manager&amp;#39; and follow the instructions.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;查看节点加入指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如前所述，其他节点加入Swarm需要使用正确的token值。对于管理节点和工作节点，其加入Swarm使用的token值是不同的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 向Swarm中加入管理节点 docker swarm join-token manager
$ docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-86w02153sf0kbncz42aoa41p9 \
    10.0.2.15:2377

# 向Swarm中加入工作节点 docker swarm join-token worker
$ docker swarm join-token worker
To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-6t4a6w0shlr78nc55hh9si3ll \
    10.0.2.15:2377
# 通过对比可以发现，管理节点和工作节点使用的是不同的token值
# 两个token值的前半部分是一样的，即根证书的摘要是一样的；后半部分是不一样的，即随机生成的密钥
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过传递--quiet标志，可以仅输出token值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 输出工作节点的token值
$ docker swarm join-token --quiet worker
SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-6t4a6w0shlr78nc55hh9si3ll

# 输出管理节点的token值
$ docker swarm join-token --quiet manager
SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-86w02153sf0kbncz42aoa41p9
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Swarm集群的token值是需要保护的，因为它允许新的工作节点/管理节点加入该Swarm。Docker建议我们在以下情况下轮换token值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果token被意外登记到版本控制系统中，群聊或日志中。&lt;/li&gt;
&lt;li&gt;如果怀疑某个节点被入侵。&lt;/li&gt;
&lt;li&gt;如果希望保证没有新的节点加入Swarm集群。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;出于对Swarm集群的保护，建议至少每6个月轮换一次token值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 轮换工作节点token值
$ docker swarm join-token --roteate worker
# 轮换管理节点token值
$ docker swarm join-token --rotate manager
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;加入Swarm&lt;/h3&gt;
&lt;p&gt;当我们创建一个Swarm集群时，只是创建一个包含单个管理节点的Swarm集群。为了充分利用Swarm集群的优势，我们可以向Swarm集群中加入其它节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加入工作节点(worker node)以实现Swarm的增容。当我们向Swarm集群中部署服务时，调度器可以通过random/binpacking/spread策略向可用的节点上分派任务。因此，增加工作节点可以提高Swarm对于服务的处理能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入管理节点(manager node)以提高Swarm的容错性。管理节点负责Swarm集群的编排和管理。如果存在多个管理节点时，当单一的主管理节点出现宕机时，其他管理节点则可以通过选举产生新的主管理节点来保证整个Swarm集群的正常运行。默认情况下，管理节点也运行任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;加入工作节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在管理节点上，通过命令&lt;code&gt;docker swarm join-token worker&lt;/code&gt;查看加入工作节点的token值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在管理节点上
$ docker swarm join-token worker
To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-6t4a6w0shlr78nc55hh9si3ll \
    10.0.2.15:2377

# 在预接入的工作节点上
$ docker swarm join \
--token SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-6t4a6w0shlr78nc55hh9si3ll \
10.0.2.15:2377
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令&lt;code&gt;docker swarm join&lt;/code&gt;主要的工作流程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将当前节点Docker Engine切换至Swarm模式&lt;/li&gt;
&lt;li&gt;向管理节点请求一个TLS证书&lt;/li&gt;
&lt;li&gt;基于token将当前节点加入到管理节点监听地址所在的Swarm集群&lt;/li&gt;
&lt;li&gt;设置当前节点为&lt;code&gt;Active&lt;/code&gt;状态，意味着该节点可以接收分派的任务&lt;/li&gt;
&lt;li&gt;将入口翻盖网络扩展至当前节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;加入管理节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们向Swarm集群中加入管理节点时，Docker引擎同样将当前节点切换至Swarm模式。与工作节点不同的是，管理节点的状态是&lt;code&gt;Reachable&lt;/code&gt;（可达的），已经存在的管理节点将成为Leader管理节点，即主管理节点。&lt;/p&gt;
&lt;p&gt;Docker建议在每个Swarm集群中放置三到五个管理节点以提高整个集群的高可用性。因为，Swarm模式下管理节点之间通过Raft共享数据，因此需要奇数个管理节点。&lt;/p&gt;
&lt;p&gt;在管理节点上，通过命令&lt;code&gt;docker swarm join-token manager&lt;/code&gt;查看加入管理节点的token值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在管理节点上
$ docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-86w02153sf0kbncz42aoa41p9 \
    10.0.2.15:2377

# 在预加入的管理节点上
$ docker swarm join \
--token SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-86w02153sf0kbncz42aoa41p9 \
10.0.2.15:2377
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;节点管理&lt;/h3&gt;
&lt;p&gt;作为Swarm集群管理生命周期的一部分，我们需要掌握节点的主要操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#列出节点"&gt;列出Swarm集群中的所有节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#检查节点"&gt;检查单个节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#更新节点"&gt;节点的更新&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#节点离开"&gt;节点离开Swarm集群&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;列出节点&lt;/h4&gt;
&lt;p&gt;在管理节点上通过命令&lt;code&gt;docker node ls&lt;/code&gt;可以查看Swarm集群中的所有节点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在管理节点上
$ docker node ls
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
i8yofrrddqu8mkved5s2uwb0s    worker2   Ready   Active
utfwatnlalniyo5glt734m4sj *  manager   Ready   Active        Leader
xf5ysyp7n2biukskzigc5f3bd    worker1   Ready   Active
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;AVAILABILITY&lt;/code&gt;标志状态，描述了调度器是否可以将任务分派至该节点，有三个值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Active:激活状态，意味着调度器可以向该节点分派任务&lt;/li&gt;
&lt;li&gt;Pause:暂停状态，意味着调度器不可以向该节点分派新的任务，但是原有的任务将正常运行&lt;/li&gt;
&lt;li&gt;Drain:排水状态，意味着调度器不可以向该节点分派新的任务，并且将其原来负责的任务迁移至其他可用节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;MANAGER STATUS&lt;/code&gt;标志状态，显示了节点的是否参与Raft共识过程，有四个值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无状态标记，意味着该节点是工作节点，不参与Swarm集群管理&lt;/li&gt;
&lt;li&gt;Leader:意味着该节点是主管理节点，负责整个Swarm集群的管理和服务编排&lt;/li&gt;
&lt;li&gt;Reachable:意味着该节点参与Raft共识过程。如果Leader节点变成不可达状态，该节点则参与选举产生新的Leader过程。&lt;/li&gt;
&lt;li&gt;Unavailable:意味着该节点不能够与其他管理节点进行通信。当一个管理节点变成不可达状态，最好向Swarm集群中加入新的管理节点或者将其中的一个工作节点变成管理节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;检查节点&lt;/h4&gt;
&lt;p&gt;我们可以通过命令&lt;code&gt;docker node inspect &amp;lt;NODE-ID&amp;gt;&lt;/code&gt;查看单个节点的信息，默认信息的输出格式为JSON格式，也可以通过--pretty标志以可读的方式输出节点信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在管理节点上
$ docker node inspect self --pretty
ID:         utfwatnlalniyo5glt734m4sj
Hostname:       manager
Joined at:      2017-05-11 08:23:12.477597386 +0000 utc
Status:
 State:         Ready
 Availability:      Active
 Address:       172.28.128.3
Manager Status:
 Address:       172.28.128.3:2377
 Raft Status:       Reachable
 Leader:        Yes
Platform:
 Operating System:  linux
 Architecture:      x86_64
Resources:
 CPUs:          2
 Memory:        992.2 MiB
Plugins:
  Network:      bridge, host, macvlan, null, overlay
  Volume:       local
Engine Version:     17.03.1-ce

$ docker node inspect worker1 --pretty
ID:         xf5ysyp7n2biukskzigc5f3bd
Hostname:       worker1
Joined at:      2017-05-11 08:31:54.044503498 +0000 utc
Status:
 State:         Ready
 Availability:      Active
 Address:       172.28.128.4
Platform:
 Operating System:  linux
 Architecture:      x86_64
Resources:
 CPUs:          2
 Memory:        992.2 MiB
Plugins:
  Network:      bridge, host, macvlan, null, overlay
  Volume:       local
Engine Version:     17.03.1-ce
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;更新节点&lt;/h3&gt;
&lt;p&gt;在Swarm集群中，我们可以修改节点的以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改变节点的可用性&lt;/li&gt;
&lt;li&gt;添加/移除标签元数据&lt;/li&gt;
&lt;li&gt;改变节点的角色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;改变节点的可用性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;改变节点的可用性主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将管理节点置为&lt;code&gt;Drain&lt;/code&gt;状态，这样做意味着该节点只负责Swarm集群的管理工作，而不具备运行任务的功能，使节点成为“纯管理节点”。&lt;/li&gt;
&lt;li&gt;将节点置为&lt;code&gt;Drain&lt;/code&gt;状态，以便将其停止并进行维护工作。&lt;/li&gt;
&lt;li&gt;将节点置为&lt;code&gt;Pause&lt;/code&gt;状态，使它不再接收新的任务&lt;/li&gt;
&lt;li&gt;将节点由暂停或不可达状态置为可达状态，使其重新接收新任务&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 将worker1节点置为drain状态
$ docker node update --availability drain worker1
worker1
$ docker node ls
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
i8yofrrddqu8mkved5s2uwb0s    worker2   Ready   Active
utfwatnlalniyo5glt734m4sj *  manager   Ready   Active        Leader
xf5ysyp7n2biukskzigc5f3bd    worker1   Ready   Drain
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;添加/移除标签元数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;节点标签提供了一种节点管理的灵活方式，当然，在进行服务部署和限制时也可以使用节点标签。在管理节点上运行命令&lt;code&gt;docker node update --label-add&lt;/code&gt;，可以向一个节点添加标签，&lt;code&gt;--label-add&lt;/code&gt;标志接收键参数(&lt;key&gt;)，也可以接收键值对(&lt;key&gt;=&lt;value&gt;)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker node update --label-add subond worker1
# docker node inspect worker1 --pretty
ID:         xf5ysyp7n2biukskzigc5f3bd
Labels:
 - subond =
Hostname:       worker1
Joined at:      2017-05-11 08:31:54.044503498 +0000 utc
Status:
 State:         Ready
 Availability:      Active
 Address:       172.28.128.4
Platform:
 Operating System:  linux
 Architecture:      x86_64
Resources:
 CPUs:          2
 Memory:        992.2 MiB
Plugins:
  Network:      bridge, host, macvlan, null, overlay
  Volume:       local
Engine Version:     17.03.1-ce
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;节点角色的转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker允许提升工作节点为管理节点，尤其是在管理节点宕机时，这个方法很有用。当然，我们也可以将管理节点降为工作节点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 提升节点角色命令 docker node promote
$ docker node promote worker1

# 降低节点角色命令 docker node demote
$ docker node demote worker1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;docker node promote&lt;/code&gt;和&lt;code&gt;docker node demote&lt;/code&gt;命令是&lt;code&gt;docker node update --role manager&lt;/code&gt;和&lt;code&gt;docker node update --role worker&lt;/code&gt;命令的简化版，两者具有同样的作用。&lt;/p&gt;
&lt;h4&gt;节点离开&lt;/h4&gt;
&lt;p&gt;命令&lt;code&gt;docker swarm leave&lt;/code&gt;可以使一个节点离开Swarm集群。当一个节点离开Swarm集群时，该节点的Docker引擎将停止运行Swarm模式，调度器不再将任务分派值该节点。如果该节点是管理节点，移除节点将收到警告信息，可以通过--force参数强制移除。&lt;/p&gt;</content><category term="Cloud"></category><category term="Docker"></category></entry><entry><title>Docker集群：工作原理</title><link href="www.subond.com/pages/2017/04/26/docker-swarm-gong-zuo-yuan-li.html" rel="alternate"></link><published>2017-04-26T00:00:00+08:00</published><updated>2017-04-26T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-26:www.subond.com/pages/2017/04/26/docker-swarm-gong-zuo-yuan-li.html</id><summary type="html">&lt;p&gt;一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。&lt;/p&gt;</summary><content type="html">&lt;p&gt;一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。&lt;/p&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#节点的工作原理"&gt;节点的工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#服务的工作原理"&gt;服务的工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#PKI工作原理"&gt;PKI工作原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;节点的工作原理&lt;/h3&gt;
&lt;p&gt;Docker1.12及其以后版本中引入的Swarm模式，即允许创建一个Docker集群。一个Swarm集群包含一个或多个节点，既可以是物理节点，也可以是虚拟节点。但是，需要保证的是节点上要安装Docker1.12或高于1.12的Docker引擎。&lt;/p&gt;
&lt;p&gt;Swarm模式下节点分为两种：&lt;strong&gt;管理节点&lt;/strong&gt; 和 &lt;strong&gt;工作节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="节点的工作原理" src="http://on64c9tla.bkt.clouddn.com/Comput/node_work.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管理节点负责集群的管理任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护集群状态信息&lt;/li&gt;
&lt;li&gt;服务调度&lt;/li&gt;
&lt;li&gt;处理Swarm模式下的API请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过Raft原理，管理节点负责维护整个Swarm集群的内部一致状态以及其上运行的所有服务。为了测试其功能，我们可以运行单个管理节点的Swarm集群。为了保证服务的正常运行，如果单个管理节点的Swarm集群失败，则需要创建一个新的Swarm集群来接管原来的服务。&lt;/p&gt;
&lt;p&gt;为了很好的利用Swarm集群的容错功能，Docker建议部署奇数个节点以保证整个Swarm集群的高可用性。与此同时，当采用多个管理节点时，Swarm系统可以保证管理节点的故障恢复，而不会导致服务停机。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个具有三个管理节点的Swarm集群，最多可允许一个管理节点出现故障。&lt;/li&gt;
&lt;li&gt;一个具有五个管理节点的Swarm集群，最多可允许两个管理节点出现故障。&lt;/li&gt;
&lt;li&gt;一个具有&lt;code&gt;N&lt;/code&gt;个管理节点的Swarm集群，最多可允许&lt;code&gt;(N-1)/2&lt;/code&gt;个管理节点出现故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一个Swarm集群中，Docker推荐最多部署七个管理节点。因为，更多的管理节点并不一定意味着高可用性和高伸缩性，有时恰恰相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工作节点也是Docker引擎的实例，主要负责运行容器实例。工作节点不参与Raft分布式状态维护，调度决策的制定以及服务Swarm模式下的API请求。我们可以创建单个管理节点的Swarm集群，但却不能创建具有单个工作节点的Swarm集群。&lt;strong&gt;模式情况下，所有的管理节点也是工作节点&lt;/strong&gt;。当然，也可以通过配置，让管理节点仅负责“管理功能”。&lt;/p&gt;
&lt;p&gt;为了防止服务调度器在具有多个节点的Swarm集群中，将任务布置到管理节点上，可以将管理节点的可用性设置为&lt;code&gt;Drain&lt;/code&gt;。这样，服务调度器就不会将任务部署到&lt;code&gt;Drain&lt;/code&gt;状态的节点上，而只将任务分派到&lt;code&gt;Active&lt;/code&gt;状态的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;角色转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker Swarm模式中，允许我们将工作节点提升为管理节点以保证整个Swarm集群的正常运行，尤其是在管理节点出现故障时。相关命令可以参考&lt;code&gt;docker node promote&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同样的道理，我们也可以将管理节点变为工作节点。相关命令可以参考&lt;code&gt;docker node demote&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;服务的工作原理&lt;/h3&gt;
&lt;p&gt;在Swarm模式下，Docker允许我们通过创建服务的方式来部署应用镜像。通常情况下，服务是某些更大应用程序的上下文中为服务器的镜像。比如，服务包括HTTP服务器，数据库，或者希望在分布式环境中运行的任何类型的可执行程序。&lt;/p&gt;
&lt;p&gt;当创建一个服务的时候，我们需要制定服务需要的镜像(即运行环境)和即将在容器中运行的命令(即应用程序)。当然，也包括其他选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端口:在Swarm集群外提供服务的端口&lt;/li&gt;
&lt;li&gt;网络方式:用于连接到Swarm集群中其他服务的网络环境&lt;/li&gt;
&lt;li&gt;系统限制:CPU和内存限制及预留&lt;/li&gt;
&lt;li&gt;更新操作:更新时延策略&lt;/li&gt;
&lt;li&gt;副本数量:Swarm中镜像的副本数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;服务，任务与容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们向Swarm集群中部署服务时，管理节点将服务定义为服务所需的状态。然后，将服务以任务副本的方式分派到Swarm集群中的各个节点上。这些任务在Swarm集群中的节点上独立运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个容器就是一个独立的进程&lt;/strong&gt;。Swarm集群中，每个任务调用一个容器。一个任务类似调度器放置在容器里面的一个”插槽“。一旦容器处于运行状态，调度器能够识别任务处于运行状态。如果容器出现问题或终止，则任务终止。&lt;/p&gt;
&lt;p&gt;&lt;img alt="服务的工作原理" src="http://on64c9tla.bkt.clouddn.com/Comput/service_work.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务与调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任务是 &lt;strong&gt;Swarm集群中调度的基本单元&lt;/strong&gt;，具有 &lt;strong&gt;原子性&lt;/strong&gt;，即一个任务在容器中要么运行成功，要么失败。当我们创建或更新一个服务所需要的服务状态时，调度器通过调度任务来满足服务所需的状态。比如，我们创建一个包括三个HTTP监听的服务，调度器则通过创建三个任务来做出响应。每个任务都是调度器通过创建一个容器并填充一个”插槽“来实现。简单来讲就是，容器是任务的实例化。如果其中一个HTTP监听服务失败或崩溃，调度器将创建一个新容器并执行新的任务副本。&lt;/p&gt;
&lt;p&gt;任务采用的是 &lt;strong&gt;单向机制&lt;/strong&gt;。它通过一系列状态单独运行：分配，准备，运行等。如果任务失败，调度器将删除该任务及其容器，然后根据服务所需的状态创建一个新任务来替代原来的任务。&lt;/p&gt;
&lt;p&gt;Swarm集群的基础逻辑包括 &lt;strong&gt;通用调度器&lt;/strong&gt; 和 &lt;strong&gt;编排器&lt;/strong&gt;。服务和任务均具有抽象性，而将其类型是不可知。假设我们要实现其他类型的任务，比如虚拟机任务或非容器化任务。调度器和编排器对于任务的类型是不可知的。但是，目前Docker只支持容器任务。&lt;/p&gt;
&lt;p&gt;Swarm模式下如何接受服务并创建任务，以及将任务分派到其他节点，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="调度器与编排器" src="http://on64c9tla.bkt.clouddn.com/Comput/scheduler.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制及全局服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swarm模式下有两种服务的部署方式，&lt;strong&gt;复制服务&lt;/strong&gt; 和 &lt;strong&gt;全局服务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;复制服务模式下，我们需要制定将要运行的任务副本的数量。比如，部署一个具有三个任务副本的HTTP监控服务，每个任务都具有相同的内容。&lt;/p&gt;
&lt;p&gt;全局服务模式下，每个节点均运行一个服务的任务副本，不需要指定任务副本的数量。当新的节点加入Swarm集群后，编排器则创建新的任务并将其分派到该节点。监控服务，反病毒扫描程序或者其他类型的容器都是比较好的全局服务的对象。&lt;/p&gt;
&lt;h3&gt;PKI工作原理&lt;/h3&gt;
&lt;p&gt;Docker引擎中内置的公钥基础设施(Public Key Infrastructure)系统使得容器的部署和编排变得更加简单和安全。Swarm集群中的节点使用传输层安全(TLS)来认证，授权和加密它们与集群中其他节点的通信。&lt;/p&gt;
&lt;p&gt;当我们使用命令&lt;code&gt;docker swarm init&lt;/code&gt;创建一个Swarm集群时，Docker引擎则将当前节点视为一个管理节点。默认情况下，管理节点自身生成一个新的跟证书颁发机构(CA)以及密钥对，以保护与加入集群的其他节点的通信。当然，也可以通过配置--external-ca参数来指定外部的根证书颁发机构。&lt;/p&gt;
&lt;p&gt;与此同时，管理节点还生成两个token值(用于向Swarm集群中加入节点)，一个是工作节点token值，另一个是管理节点token值。每一个token值都包含根CA证书的摘要和随机生成的密钥。当节点加入集群时，它使用摘要来验证远程管理节点的根CA证书，使用密钥来确保该节点是经过批准的节点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 创建一个swarm
$ docker swarm init
# 查看管理节点和工作节点的加入命令
# 向Swarm中加入管理节点 docker swarm join-token manager
# 向Swarm中加入工作节点 docker swarm join-token worker
$ docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-86w02153sf0kbncz42aoa41p9 \
    10.0.2.15:2377
$ docker swarm join-token worker
To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-35n1uqy8q7si9lvkapojdkxjcntl5uixtdg1xo0ib3b2sg9t8g-6t4a6w0shlr78nc55hh9si3ll \
    10.0.2.15:2377
# 通过对比可以发现，管理节点和工作节点使用的是不同的token值
# 两个token值的前半部分是一样的，即根证书的摘要是一样的；后半部分是不一样的，即随机生成的密钥
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次当新的节点加入Swarm集群时，管理节点向包含随机生成的节点ID颁发证书，用来标识证书通用名(CN)下的节点和组织名(UN)下的角色。节点ID用来标识Swarm集群中节点寿命的密码安全。&lt;/p&gt;
&lt;p&gt;&lt;img alt="PKI工作原理" src="http://on64c9tla.bkt.clouddn.com/Comput/PKI.png"&gt;&lt;/p&gt;</content><category term="Cloud"></category><category term="Docker"></category></entry><entry><title>Docker集群：服务回滚</title><link href="www.subond.com/pages/2017/04/24/docker-swarm-fu-wu-hui-gun.html" rel="alternate"></link><published>2017-04-24T00:00:00+08:00</published><updated>2017-04-24T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-24:www.subond.com/pages/2017/04/24/docker-swarm-fu-wu-hui-gun.html</id><summary type="html">&lt;p&gt;一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。&lt;/p&gt;</summary><content type="html">&lt;p&gt;一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。&lt;/p&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#服务更新与回滚"&gt;服务更新与回滚&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#路由网络"&gt;路由网络&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;服务更新与回滚&lt;/h3&gt;
&lt;p&gt;Docker Swarm集群管理中支持服务的版本更新及回滚操作，具体演示如下：&lt;/p&gt;
&lt;p&gt;所使用的系统环境环境如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三个节点(manager, worker1, worker2)均为Ubuntu16.04，即xenial64系统  &lt;/li&gt;
&lt;li&gt;节点的IP分布，manager(172.28.128.3), worker1(172.28.128.4), worker2(172.28.128.5)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，我们将Redis 3.0.6版本部署到Swarm集群中，并指定10s的更新时延。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在manger节点上
$ docker service create --replicas 3 --name redis --update-delay 10s redis:3.0.6

# --update-delay参数配置服务任务或任务集的更新的时延
# 其格式为T1hT2mT3s，即T1小时T2分钟T3秒
# 默认情况下，更新调度程序一次更新一个任务。但是，可以配置--update-parallelism参数指定同时更新的最大服务任数
# 默认情况下，当一个任务更新并返回RUNNING状态后，更新调度程序才调度另一个任务进行更新，直到所有的任务更新完成。
# 如果某个任务更新返回FAILED状态，更新调度程序则停止更新。
# 当然，也可以通过配置--update-failure-action参数指定服务创建和更新，例如：
# --update-failure-action docker service create
# --update-failure-action docker service update

# 接下来，我们更新redis的镜像
$ docker service update --image redis:3.0.7 redis
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如前所述，默认情况下，更新主要包括以下几个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停止第一个任务&lt;/li&gt;
&lt;li&gt;调度器更新已经停止的任务&lt;/li&gt;
&lt;li&gt;为更新过的任务启动容器&lt;/li&gt;
&lt;li&gt;若任务更新返回RUNNING状态，则等待设定的时延，并进行下一个任务的更新&lt;/li&gt;
&lt;li&gt;若任务更新返回FAILED状态，则停止更新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更新结束后，我们看到如下状态：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker service ps redis
ID            NAME         IMAGE        NODE           DESIRED STATE  CURRENT STATE                ERROR  PORTS
i9c6xvbopko2  redis.1      redis:3.0.7  ubuntu-xenial  Running        Running &lt;span class="m"&gt;5&lt;/span&gt; seconds ago
mnw258z0j5hg   &lt;span class="se"&gt;\_&lt;/span&gt; redis.1  redis:3.0.6  ubuntu-xenial  Shutdown       Shutdown &lt;span class="m"&gt;5&lt;/span&gt; seconds ago
iu7yjb7nm345  redis.2      redis:3.0.7  ubuntu-xenial  Running        Running &lt;span class="m"&gt;53&lt;/span&gt; seconds ago
fmgyoq4vladx   &lt;span class="se"&gt;\_&lt;/span&gt; redis.2  redis:3.0.6  ubuntu-xenial  Shutdown       Shutdown &lt;span class="m"&gt;54&lt;/span&gt; seconds ago
zsliph02ycsf  redis.3      redis:3.0.7  ubuntu-xenial  Running        Running about a minute ago
8j75vwiunh49   &lt;span class="se"&gt;\_&lt;/span&gt; redis.3  redis:3.0.6  ubuntu-xenial  Shutdown       Shutdown about a minute ago
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由此我们可以判断，在服务/任务更新的过程中，实质上是 &lt;strong&gt;创建了一批新的容器来满足我们的更新时所指定的新的需求&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;路由网格&lt;/h3&gt;
&lt;p&gt;Docker Swarm模式下可以轻松地配置PublishedPort，使外部可以访问到Swarm集群中的资源。&lt;strong&gt;所有的节点都参与到入口路由网格&lt;/strong&gt;。路由网格使得Swarm集群中的每个节点能够接受已发布端口上的任何服务，即使节点上没有正在运行的任务。&lt;strong&gt;路由网格将所有传入请求路由到可用节点的已发布端口的活动容器上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了保证在Swarm中使用入口网络，在启用Swarm模式时需要打开以下端口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Port 7946[TCP/UDP]用于容器网络的发现&lt;/li&gt;
&lt;li&gt;Port 4789[UDP]用于容器入口网络&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，还必须打开Swarm集群节点和任何需要访问外部资源之间已发布的端口。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# --publish参数用于指定服务端口，--publish &amp;lt;PublishedPort&amp;gt;:&amp;lt;TARGET-PORT&amp;gt;
# &amp;lt;TARGET-PORT&amp;gt;是容器监听的端口
# &amp;lt;PublishedPort&amp;gt;是Swarm对外服务的端口
$ docker service create --name myweb --publish 8080:80 --replicas 2 nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认情况下，当我们发布一个端口时，默认指定为TCP端口。但是，有时我们需要仅指定TCP端口或UDP端口，可进行如下设置。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 仅指定TCP端口
$ docker service create --name dns-cache -p 53:53 dns-cache
$ docker service create --name dns-cache -p 53:53/tcp dns-cache
# 以上两个命令是等价的，因为默认情况下即为TCP端口

# 同时指定TCP和UDP端口
$ docker service create --name dns-cache -p 53:53/tcp -p 53:53/udp dns-cache

# 仅指定UDP端口
$ docker service create --name dns-cache -p 53:53/udp dns-cache
&lt;/pre&gt;&lt;/div&gt;</content><category term="Cloud"></category><category term="Docker"></category></entry><entry><title>Docker集群：服务部署</title><link href="www.subond.com/pages/2017/04/22/docker-swarm-fu-wu-bu-shu.html" rel="alternate"></link><published>2017-04-22T00:00:00+08:00</published><updated>2017-04-22T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-22:www.subond.com/pages/2017/04/22/docker-swarm-fu-wu-bu-shu.html</id><summary type="html">&lt;p&gt;一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。&lt;/p&gt;</summary><content type="html">&lt;p&gt;一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。&lt;/p&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#核心概念"&gt;核心概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#搭建Swarm集群"&gt;搭建Swarm集群&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;核心概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Swarm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个节点即是参与Swarm集群的Docker引擎实例。我们可以将其理解为一个Docker节点。虽然，我们可以在同一物理主机或云服务上运行一个或多个节点，但是典型的Swarm生产环境则是在分布式的物理主机或云服务上部署多个Docker节点。&lt;/p&gt;
&lt;p&gt;当部署一个服务到Swarm集群中时，我们需要率先在 &lt;strong&gt;管理节点&lt;/strong&gt; 上注册该服务。然后，管理节点将该服务（称之为 &lt;strong&gt;任务&lt;/strong&gt;）分派给各个 &lt;strong&gt;工作节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;管理节点(Swarm Manager)负责服务编排和集群管理以保证整个集群的正常运行，并负责选出一个leader进行任务编排工作。&lt;/p&gt;
&lt;p&gt;工作节点(Swarm Agent)负责接收并执行管理节点派发下来的任务。默认情况下，管理节点同时扮演工作节点的角色，即接收并执行任务。当然，我们也可以通过配置让管理节点只负责任务管理的功能，使之成为“只具备管理”的节点。Agent在每个工作节点上运行，并报告分派给它的任务。工作节点向管理节点报告其分派到的任务的当前状态，以便管理节点可以维护每个工作节点所需的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务和任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个服务是指运行在工作节点上任务的定义。它是Swarm系统的中心结构，也是用户与Swarm交互的主要根据。当创建一个服务时，我们需要指定容器即将使用的镜像以及容器中要执行的命令。在服务分派模型中，Swarm的管理节点根据我们在所需状态下设置的比例，在工作节点中分配特定数量的任务副本。对于全局服务，Swarm在集群中的每个可用工作节点上为服务运行一个任务。&lt;/p&gt;
&lt;p&gt;一个任务带有一个Docker容器和在容器中执行的命令。任务是Swarm进行服务管理的原子调度单元。管理节点根据服务规模中设置的副本数量将任务分派给工作节点。一旦一个任务分派给某个节点，任务就不能移动到另一个节点，它只能在分配的节点上运行或者失败，这即是任务的原子性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swarm集群管理使用的是 &lt;strong&gt;入口负载均衡&lt;/strong&gt; 策略来暴露想要从外部访问的服务。Swarm的管理节点可以自动地给服务分配一个PublishedPort，也可以为该服务自行配置一个PublishedPort。如果不指定端口，Swarm管理节点将分配30000-32767之间的某个端口。&lt;/p&gt;
&lt;p&gt;外部组件，像云端负载均衡，可以访问集群中任何一个节点的PublishedPort，无论这个节点当前是否在运行某个服务的任务。Swarm路由中的所有节点都将连接到正在运行任务实例的节点上。&lt;/p&gt;
&lt;p&gt;Swarm中还有一个内部DNS组件，可自动为集群中的每个服务分配DNS条目。Swarm管理节点使用内部负载均衡，根据服务的DNS名称在集群内部的服务之间分配请求。&lt;/p&gt;
&lt;h3&gt;搭建Swarm集群&lt;/h3&gt;
&lt;p&gt;搭建Swarm集群过程中，所使用的系统环境环境如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三个节点(manager, worker1, worker2)均为xenial64系统  &lt;/li&gt;
&lt;li&gt;节点的IP分布，manager(172.28.128.3), worker1(172.28.128.4), worker2(172.28.128.5)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.创建一个Swarm集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在manager所在的主机创建Swarm集群，即创建Swarm管理节点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在manager节点上
# 使用docker swarm init --advertise-addr &amp;lt;manager-ip&amp;gt;命令创建Swarm的管理节点
$ docker swarm init --advertise-addr 172.28.128.0.3
Swarm initialized: current node (utfwatnlalniyo5glt734m4sj) is now a manager.
To add a worker to this Swarm, run the following command:
    docker Swarm join \
    --token SWMTKN-1-3pa0dv3m2spedchgfrt2zuv9x2ykuxdj3liegogxub9fijimy1-4xrv3f26wk7lkrrf2q672ew3m \
    172.28.128.3:2377
To add a manager to this Swarm, run &amp;#39;docker Swarm join-token manager&amp;#39; and follow the instructions.
# docker node ls查看管理节点的状态
$ docker node ls
ID                           HOSTNAME       STATUS  AVAILABILITY  MANAGER STATUS
utfwatnlalniyo5glt734m4sj *  ubuntu-xenial  Ready   Active        Leader
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2.向Swarm中注册工作节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在worker[1-2]所在的主机创建Swarm工作节点，并加入到Swarm集群中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在worker1节点上
$ docker Swarm join \
$ --token SWMTKN-1-3pa0dv3m2spedchgfrt2zuv9x2ykuxdj3liegogxub9fijimy1-4xrv3f26wk7lkrrf2q672ew3m \
$ 172.28.128.3:2377
This node joined a Swarm as a worker.

# 在worker2节点上
$ docker Swarm join \
$ --token SWMTKN-1-3pa0dv3m2spedchgfrt2zuv9x2ykuxdj3liegogxub9fijimy1-4xrv3f26wk7lkrrf2q672ew3m \
$ 172.28.128.3:2377
This node joined a Swarm as a worker.
# 使用命令docker Swarm leave将节点移除Swarm集群

# 在manager节点上
$ docker node ls
ID                           HOSTNAME       STATUS  AVAILABILITY  MANAGER STATUS
i8yofrrddqu8mkved5s2uwb0s    ubuntu-xenial  Ready   Active
utfwatnlalniyo5glt734m4sj *  ubuntu-xenial  Ready   Active        Leader
xf5ysyp7n2biukskzigc5f3bd    ubuntu-xenial  Ready   Active
# 可以看到当前Swarm集群中已经存在三个节点，并且用*指出管理节点的ID
# 需要注意的是，命令docker node ls只能工作在管理节点上，用于查看Swarm集群中的节点状态
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3.向Swarm集群中部署服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务的部署和管理均在管理节点上进行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在manager节点上
$ docker service create --replicas 1 --name helloworld alpine ping docker.com
kugt1fx2j2es172l4zmvr0fbk
# --name 指定服务名称
# --replicas 指定任务的副本数量
# alpine ping docker.com 表示该服务所使用的容器镜像和容器中要执行的命令

# 使用命令docker ps可以查看主机上服务运行所在的docker容器的状态
$ docker ps
CONTAINER ID        IMAGE                                                                            COMMAND             CREATED             STATUS              PORTS               NAMES
8a0bd7183d20        alpine@sha256:c0537ff6a5218ef531ece93d4984efc99bbf3f7497c0a7726c88e2bb7584dc96   &amp;quot;ping docker.com&amp;quot;   3 minutes ago       Up 3 minutes                            helloworld.1.f1b58uxk5c1l56736uznzapjm

# 使用docker service ls查看服务
ID            NAME        MODE        REPLICAS  IMAGE
kugt1fx2j2es  helloworld  replicated  1/1       alpine:latest
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;4.服务检查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们向Swarm集群中部署服务后，可以使用docker命令查看服务的运行状态。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 命令docker service inspect --pretty &amp;lt;SERVICE-ID&amp;gt;可以以可读的格式显示服务的细节信息
# 在manager节点上
$ docker service inspect --pretty helloworld
ID:     kugt1fx2j2es172l4zmvr0fbk
Name:       helloworld
Service Mode:   Replicated
 Replicas:  1
Placement:
UpdateConfig:
 Parallelism:   1
 On failure:    pause
 Max failure ratio: 0
ContainerSpec:
 Image:     alpine:latest@sha256:c0537ff6a5218ef531ece93d4984efc99bbf3f7497c0a7726c88e2bb7584dc96
 Args:      ping docker.com
Resources:
Endpoint Mode:  vip

# 命令docker service ps &amp;lt;SERVICE-ID&amp;gt;可查看服务/任务运行在哪个节点上
$ docker service ps helloworld
ID            NAME          IMAGE          NODE           DESIRED STATE  CURRENT STATE           ERROR  PORTS
f1b58uxk5c1l  helloworld.1  alpine:latest  ubuntu-xenial  Running        Running 13 minutes ago
# 在任务运行的节点上，可使用docker ps查看容器运行的信息
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;5.Swarm集群中服务的缩放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦向Swarm中部署服务后，我们还可以调整某项服务的容器数量，即任务的数量。命令如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker service scale &amp;lt;SERVICE-ID&amp;gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;NUMBERS-OF-TASKS&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在manager节点上
# 将之前部署的helloworld服务扩大至5个任务
$ docker service scale helloworld=5
helloworld scaled to 5

# 查看5个任务的分布情况及运行状态
$ docker service ps helloworld
ID            NAME          IMAGE          NODE           DESIRED STATE  CURRENT STATE           ERROR  PORTS
f1b58uxk5c1l  helloworld.1  alpine:latest  ubuntu-xenial  Running        Running 28 minutes ago
xkgyz1874p3r  helloworld.2  alpine:latest  ubuntu-xenial  Running        Running 2 minutes ago
0rnlxcv4487o  helloworld.3  alpine:latest  ubuntu-xenial  Running        Running 2 minutes ago
izu5oeb5qerp  helloworld.4  alpine:latest  ubuntu-xenial  Running        Running 2 minutes ago
m2v2uzgoy9g1  helloworld.5  alpine:latest  ubuntu-xenial  Running        Running 2 minutes ago

$ docker ps
CONTAINER ID        IMAGE                                                                            COMMAND             CREATED             STATUS              PORTS               NAMES
ea297aa56bc4        alpine@sha256:c0537ff6a5218ef531ece93d4984efc99bbf3f7497c0a7726c88e2bb7584dc96   &amp;quot;ping docker.com&amp;quot;   2 minutes ago       Up 2 minutes                            helloworld.5.m2v2uzgoy9g1sdohtdyenjclu
8a0bd7183d20        alpine@sha256:c0537ff6a5218ef531ece93d4984efc99bbf3f7497c0a7726c88e2bb7584dc96   &amp;quot;ping docker.com&amp;quot;   29 minutes ago      Up 29 minutes                           helloworld.1.f1b58uxk5c1l56736uznzapjm
# 可以看到在manager主机上运行着1和5号任务

# 在worker1节点上
$ docker ps
CONTAINER ID        IMAGE                                                                            COMMAND             CREATED             STATUS              PORTS               NAMES
ebd0c448b9a4        alpine@sha256:c0537ff6a5218ef531ece93d4984efc99bbf3f7497c0a7726c88e2bb7584dc96   &amp;quot;ping docker.com&amp;quot;   15 minutes ago      Up 15 minutes                           helloworld.2.xkgyz1874p3rsaih8e1jbfmyx
# 运行着2号任务

# 在worker2节点上
$ docker ps
CONTAINER ID        IMAGE                                                                            COMMAND             CREATED             STATUS              PORTS               NAMES
a30267238db2        alpine@sha256:c0537ff6a5218ef531ece93d4984efc99bbf3f7497c0a7726c88e2bb7584dc96   &amp;quot;ping docker.com&amp;quot;   5 minutes ago       Up 5 minutes                            helloworld.3.0rnlxcv4487o0y4qqaot7n0yt
bb5b75e55b30        alpine@sha256:c0537ff6a5218ef531ece93d4984efc99bbf3f7497c0a7726c88e2bb7584dc96   &amp;quot;ping docker.com&amp;quot;   5 minutes ago       Up 5 minutes                            helloworld.4.izu5oeb5qerpkfjde4bna47e5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;6.服务删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Swarm集群的管理节点上，我们可以使用命令&lt;code&gt;docker service rm &amp;lt;SERVICE-ID&amp;gt;&lt;/code&gt;删除服务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 在manager节点上
$ docker service rm helloworld
helloworld
# 通过命令docker service inspect &amp;lt;SERVICE-ID&amp;gt;可以看到服务已经不存在
# 通过命令docker ps可以看到相应的容器也随之删除
&lt;/pre&gt;&lt;/div&gt;</content><category term="Cloud"></category><category term="Docker"></category></entry><entry><title>Docker技术：快速上手教程</title><link href="www.subond.com/pages/2017/04/20/docker-quickstart.html" rel="alternate"></link><published>2017-04-20T00:00:00+08:00</published><updated>2017-04-20T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-20:www.subond.com/pages/2017/04/20/docker-quickstart.html</id><summary type="html">&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#1.构建容器-Containers"&gt;1.构建容器-Containers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2.组合服务-Compose"&gt;2.组合服务-Compose&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#3.集群管理-Swarm"&gt;3.集群管理-Swarm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4.应用协作-Stacks"&gt;4.应用协作-Stacks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.构建容器-Containers&lt;/h3&gt;
&lt;p&gt;Dockerfile将定义容器中环境的内容。通过将访问资源（例如，网络接口和磁盘驱动器）进行虚拟化处理，实现与宿主机系统的隔离。为此，我们需要将端口映射到外部宿主系统环境中，并说明将要把那些文件“复制”到隔离的环境中，即容器。这样之后，我们就可以期望在Dockerfile中定义的应用程序可以在任何地方运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dockerfile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个新的空目录，在目录下创建名为&lt;code&gt;Dockerfile&lt;/code&gt;的文件，并写入以下内容。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# Use an official Python runtime as a base image
FROM python:2.7-slim

# Set the working directory to /app …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#1.构建容器-Containers"&gt;1.构建容器-Containers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2.组合服务-Compose"&gt;2.组合服务-Compose&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#3.集群管理-Swarm"&gt;3.集群管理-Swarm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4.应用协作-Stacks"&gt;4.应用协作-Stacks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.构建容器-Containers&lt;/h3&gt;
&lt;p&gt;Dockerfile将定义容器中环境的内容。通过将访问资源（例如，网络接口和磁盘驱动器）进行虚拟化处理，实现与宿主机系统的隔离。为此，我们需要将端口映射到外部宿主系统环境中，并说明将要把那些文件“复制”到隔离的环境中，即容器。这样之后，我们就可以期望在Dockerfile中定义的应用程序可以在任何地方运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dockerfile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个新的空目录，在目录下创建名为&lt;code&gt;Dockerfile&lt;/code&gt;的文件，并写入以下内容。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# Use an official Python runtime as a base image
FROM python:2.7-slim

# Set the working directory to /app
WORKDIR /app

# Copy the current directory contents into the container at /app
ADD . /app

# Install any needed packages specified in requirements.txt
RUN pip install -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD [&amp;quot;python&amp;quot;, &amp;quot;app.py&amp;quot;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dockerfile中用到两个我们还未创建的文件，即&lt;code&gt;requirements.txt&lt;/code&gt;和&lt;code&gt;app.py&lt;/code&gt;。接下来，创建这两个文件，内容分别如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;requirements.txt&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Flask
Redis
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;app.py&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;flask&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;redis&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Redis&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RedisError&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;socket&lt;/span&gt;

&lt;span class="c1"&gt;# Connect to Redis&lt;/span&gt;
&lt;span class="n"&gt;redis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Redis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;redis&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket_connect_timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket_timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;visits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;redis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;incr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;counter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="n"&gt;RedisError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;visits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;i&amp;gt;cannot connect to Redis, counter disabled&amp;lt;/i&amp;gt;&amp;quot;&lt;/span&gt;

    &lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;h3&amp;gt;Hello {name}!&amp;lt;/h3&amp;gt;&amp;quot;&lt;/span&gt; \
           &lt;span class="s2"&gt;&amp;quot;&amp;lt;b&amp;gt;Hostname:&amp;lt;/b&amp;gt; {hostname}&amp;lt;br/&amp;gt;&amp;quot;&lt;/span&gt; \
           &lt;span class="s2"&gt;&amp;quot;&amp;lt;b&amp;gt;Visits:&amp;lt;/b&amp;gt; {visits}&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getenv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;NAME&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;hostname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gethostname&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;visits&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;visits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0.0.0.0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;构建并运行应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建好Dockerfile和其所需的文件后，我们就可以利用docker命令构建Dockerfile中定义的应用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 构建应用，即为构建Dockerfile定义的应用镜像
$ docker build -t subond-hello .
# -t指定镜像名称
# .代表以当前目录为上下文内容

# 镜像创建成功后，可以通过docker images命令查看镜像信息
$ docker images
subond-hello        latest              e440849c12a4        3 hours ago         195 MB
python              2.7-slim            1c7128a655f6        5 days ago          183 MB
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Dockerfile中我们定义了容器需要暴露的端口，因此，在容器运行时需要将暴露出来的端口映射到宿主机的某个端口，这样在宿主机上就可以访问容器中的资源。-p可以指定宿主机与容器间的端口映射关系。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 运行刚刚构建好的应用镜像
$ docker run -p 8080:80 subond-hello
* Running on http://0.0.0.0:80/ (Press CTRL+C to quit)

# 验证应用是否成功运行
# 在宿主机上
$ curl http://localhost:8080
&lt;span class="nt"&gt;&amp;lt;h3&amp;gt;&lt;/span&gt;Hello World!&lt;span class="nt"&gt;&amp;lt;/h3&amp;gt;&amp;lt;b&amp;gt;&lt;/span&gt;Hostname:&lt;span class="nt"&gt;&amp;lt;/b&amp;gt;&lt;/span&gt; 3d8822177c83&lt;span class="nt"&gt;&amp;lt;br/&amp;gt;&amp;lt;b&amp;gt;&lt;/span&gt;Visits:&lt;span class="nt"&gt;&amp;lt;/b&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;i&amp;gt;&lt;/span&gt;cannot connect to Redis, counter disabled&lt;span class="nt"&gt;&amp;lt;/i&amp;gt;&lt;/span&gt;

$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES
3d8822177c83        subond-hello        &amp;quot;python app.py&amp;quot;     57 seconds ago      Up 56 seconds       0.0.0.0:8080-&amp;gt;80/tcp   heuristic_davinci
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;共享镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当自己创建的镜像能够正常运行时，我们可以选择将镜像上传到DockerHub上与别人分享。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 登录DockerHub账号
$ docker login
# 给自己的镜像打上tag标签，如果不添加tag信息，则默认为最新，即latest
# username/repository:tag为DockerHub上的仓库
$ docker tag subond-hello username/repository:tag

# 上传镜像
$ docker push username/repository:tag
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一旦上传成功，镜像就实现了共享。此后，运行该镜像的时候，就可以指定DockerHub仓库中的镜像了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 以DockerHub上的镜像启动容器
$ docker run -p 8080:80 username/repository:tag
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;常用命令&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker build -t friendlyname .        # 使用当前目录下的Dockerfile创建应用镜像
docker run -p 4000:80 appname         # 运行”appname&amp;quot;的镜像，并进行端口映射
docker run -d -p 4000:80 friendlyname # 独立运行&amp;quot;appname&amp;quot;镜像，并进行端口映射
docker ps                             # 显示运行中的容器
docker stop &amp;lt;hash&amp;gt;                    # 停止运行中的容器
docker ps -a                          # 显示所有容器(运行的和未运行的)
docker kill &amp;lt;hash&amp;gt;                    # 杀死某个容器
docker rm &amp;lt;hash&amp;gt;                      # 移除容器
docker rm $(docker ps -a -q)          # 移除宿主机上的全部容器
docker images -a                      # 显示应用镜像
docker rmi &amp;lt;imagename&amp;gt;                # 移除应用镜像
docker rmi $(docker images -q)        # 移除所有应用镜像
docker images -f &amp;quot;dangling=true&amp;quot;      # 显示所有&amp;lt;none&amp;gt;:&amp;lt;none&amp;gt;的镜像
docker login                          # 登录DockerHub仓库
docker tag &amp;lt;image&amp;gt; username/repository:tag      # 为上传镜像打标签
docker push username/repository:tag             # 上传镜像至仓库
docker run username/repository:tag              # 运行仓库中的镜像
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2.组合服务-Compose&lt;/h3&gt;
&lt;p&gt;在分布式应用程序中，应用的不同部分称为“服务”。例如，一个视频共享网站，它可能需要数据库服务，用于存储应用程序数据；还需要后台视频转码服务，用于用户上传视频；还需要前端服务等。&lt;/p&gt;
&lt;p&gt;一个服务只是意味着“生产中的容器”。一个服务只运行一个镜像，但是它编码了镜像运行的方式——使用哪些端口，需要运行多少副本以及服务所需的容量等。因此，扩展服务实际上更改容器实例的数量，并提供扩展服务过程中所需的计算资源。&lt;/p&gt;
&lt;p&gt;Docker平台可以让服务运行及扩展变得更为简单，只需一个&lt;code&gt;docker-compose.yaml&lt;/code&gt;文件。&lt;code&gt;docker-compose.yaml&lt;/code&gt;文件是一个YAML文件，定义了实际生产环境中Docker容器的行为。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yaml&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;version: &amp;quot;3&amp;quot;
services:
  web:
    image: subond/suker:v1.0
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: &amp;quot;0.1&amp;quot;
          memory: 50M
      restart_policy:
        condition: on-failure
    ports:
      - &amp;quot;80:80&amp;quot;
    networks:
      - webnet
networks:
  webnet:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来，我们就可以利用&lt;code&gt;docker-compose.yml&lt;/code&gt;文件运行带有 &lt;strong&gt;负载均衡&lt;/strong&gt; 的应用服务。在使用&lt;code&gt;docker stack deploy&lt;/code&gt;之前，需要将Docker切换至Swarm模式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 将Docker引擎切换至Swarm模式
$ docker swarm init
# 启动应用服务，并命名为suweb
$ docker stack deploy -c docker-compose.yml suweb
Creating network suweb_webnet
Creating service suweb_web

# 查看suweb的状态
$ docker stack ps suweb
ID            NAME         IMAGE              NODE       DESIRED STATE  CURRENT STATE           ERROR  PORTS
gcc9oupfdi8g  suweb_web.1  subond/suker:v1.0  Ubuntu-16  Running        Running 10 seconds ago
s7vrc9fwwnt7  suweb_web.2  subond/suker:v1.0  Ubuntu-16  Running        Running 9 seconds ago
ns8trslxt2n6  suweb_web.3  subond/suker:v1.0  Ubuntu-16  Running        Running 10 seconds ago

# 查看容器信息
$ docker ps
CONTAINER ID        IMAGE                                                                                  COMMAND             CREATED             STATUS              PORTS               NAMES
89f858d3e9ff        subond/suker@sha256:c2c33f0db407c195ae44dcafc5a81172afb1e88157efd489580148d73d8a532a   &amp;quot;python app.py&amp;quot;     2 minutes ago       Up 2 minutes        80/tcp              suweb_web.2.s7vrc9fwwnt7szj62cwf235zc
0999d38459a6        subond/suker@sha256:c2c33f0db407c195ae44dcafc5a81172afb1e88157efd489580148d73d8a532a   &amp;quot;python app.py&amp;quot;     2 minutes ago       Up 2 minutes        80/tcp              suweb_web.3.ns8trslxt2n6vsw5pcxo6iiw6
1bc62f75cdca        subond/suker@sha256:c2c33f0db407c195ae44dcafc5a81172afb1e88157efd489580148d73d8a532a   &amp;quot;python app.py&amp;quot;     2 minutes ago       Up 2 minutes        80/tcp              suweb_web.1.gcc9oupfdi8gflriegrsth272

# 命令docker stack rm suweb，可以移除服务
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;常用命令&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker stack ls                                 # 列出所有运行着的应用程序
docker stack deploy -c &amp;lt;composefile&amp;gt; &amp;lt;appname&amp;gt;  # 以Compose文件运行容器服务
docker stack services &amp;lt;appname&amp;gt;                 # 列出与应用程序关联的服务
docker stack ps &amp;lt;appname&amp;gt;                       # 列出与应用程序关联的运行着的容器
docker stack rm &amp;lt;appname&amp;gt;                       # 删除应用程序
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;docker-compose.yml&lt;/code&gt;文件，我们可以很方便的扩展应用服务的规模，只需要修理该文件里面的相关配置，然后重新运行命令&lt;code&gt;docker stack deploy -c docker-compose.yml suweb&lt;/code&gt;即可。例如，修改replicas的值来增加或减少容器副本的数量。&lt;/p&gt;
&lt;p&gt;命令&lt;code&gt;docker run&lt;/code&gt;可以简单地实现应用服务的部署和管理；而对于实际生产环境需要大量部署应用服务时，Compose文件(即&lt;code&gt;docker-compose.yml&lt;/code&gt;)可以方便地定义容器的行为，使得对服务的扩展，限制以及重新部署非常容易。命令&lt;code&gt;docker stack deploy&lt;/code&gt;就是提供这样的一种方式。&lt;/p&gt;
&lt;h3&gt;3.集群管理-Swarm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个虚拟机，并且均安装Docker引擎1.13或者更高版本&lt;/li&gt;
&lt;li&gt;完成&lt;a href="#1.构建容器"&gt;1.构建容器&lt;/a&gt;和&lt;a href="#2.组合服务"&gt;2.组合服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;构建Swarm集群环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于Swarm集群环境说明：&lt;/p&gt;
&lt;p&gt;两个虚拟机的主机名与ip的配置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;manager(ip:172.28.128.4)扮演Swarm集群中管理节点的角色&lt;/li&gt;
&lt;li&gt;worker1(ip:172.28.128.5)扮演Swarm集群中工作节点的角色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Swarm集群中部署应用&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 第一步，将docker-compose.yml文件拷贝至manager的home目录下
# 第二步，在manager上通过composer文件部署应用服务
# 这个示例中，我使用的是vagrant虚拟机，如果你使用的是Docker-manchine方式
# 将下面指令中vagrant ssh 替换为docker-manchine，并且删除-c参数

$ vagrant ssh manager -c &amp;quot;docker stack deploy -c docker-compose.yml suweb&amp;quot;
Creating network suweb_webnet
Creating service suweb_web

# 查看容器分布及运行情况
$ vagrant ssh manager -c &amp;quot;docker stack ps suweb&amp;quot;
ID            NAME         IMAGE              NODE     DESIRED STATE  CURRENT STATE            ERROR  PORTS
d6g4m7qldta8  suweb_web.1  subond/suker:v1.0  worker1  Running        Preparing 3 seconds ago
nrginvlp568y  suweb_web.2  subond/suker:v1.0  manager  Running        Preparing 3 seconds ago
o61f0oc280et  suweb_web.3  subond/suker:v1.0  manager  Running        Preparing 3 seconds ago

# 可以看出：在worker1节点上运行着一个suweb容器服务
$ vagrant ssh worker1 -c &amp;quot;docker ps&amp;quot;
CONTAINER ID        IMAGE                                                                                  COMMAND             CREATED             STATUS              PORTS               NAMES
33a0a2a34b8b        subond/suker@sha256:c2c33f0db407c195ae44dcafc5a81172afb1e88157efd489580148d73d8a532a   &amp;quot;python app.py&amp;quot;     12 seconds ago      Up 11 seconds       80/tcp              suweb_web.1.d6g4m7qldta8mm16x80qimx8i
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4.应用协作-Stacks&lt;/h3&gt;
&lt;p&gt;&lt;a href="#3.Swarm集群-Swarm"&gt;3.Swarm集群-Swarm&lt;/a&gt;中，我们学习了如何启用Swarm模式，并向Swarm集群中部署应用服务。接下来，我们将完成如何让多个应用服务进行协作，完成更加复杂的功能。这一部分，我们将接触分布式应用程序的结构层次的顶部，即Stacks。一个Stack是一组相互关联的服务，它们共享依赖关系，并可以一起进行编排和缩放。单个堆栈能够定义和协调整个应用程序的功能(更为复杂的功能可以需要使用多个堆栈)。&lt;/p&gt;
&lt;p&gt;第一步：在&lt;code&gt;docker-compose.yml&lt;/code&gt;文件中，增加新的服务，并重新部署&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;文件内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;version: &amp;quot;3&amp;quot;
services:
  web:
    image: subond/suker:v1.0
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: &amp;quot;0.1&amp;quot;
          memory: 50M
      restart_policy:
        condition: on-failure
    ports:
      - &amp;quot;80:80&amp;quot;
    networks:
      - webnet
  visualizer:
    image: dockersamples/visualizer:stable
    ports:
      - &amp;quot;8080:8080&amp;quot;
    volumes:
      - &amp;quot;/var/run/docker.sock:/var/run/docker.sock&amp;quot;
    deploy:
      placement:
        constraints: [node.role == manager]
    networks:
      - webnet
networks:
  webnet:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来，将&lt;code&gt;docker-compose.yml&lt;/code&gt;文件拷贝至manager节点的home目录下，并重新部署应用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 重新部署suweb应用程序
$ vagrant ssh manager -c &amp;quot;docker stack deploy -c docker-compose.yml suweb&amp;quot;
Creating network suweb_webnet
Creating service suweb_visualizer
Creating service suweb_web

# 查看stack中的服务
$ vagrant ssh manager -c &amp;quot;docker stack ls&amp;quot;
NAME   SERVICES
suweb  2

# 查看suweb应用的容器分布及运行情况
$ vagrant ssh manager -c &amp;quot;docker stack ps suweb&amp;quot;
ID            NAME                IMAGE                            NODE     DESIRED STATE  CURRENT STATE               ERROR  PORTS
eu18grghbpbq  suweb_web.1         subond/suker:v1.0                worker1  Running        Running about a minute ago
qw03jh0fibxi  suweb_visualizer.1  dockersamples/visualizer:stable  manager  Running        Running 32 seconds ago
7q2481c0p04b  suweb_web.2         subond/suker:v1.0                manager  Running        Running about a minute ago
6ugzg4hpvqio  suweb_web.3         subond/suker:v1.0                worker1  Running        Running about a minute ago

# manager节点上运行两个容器，suweb_visualizer.1和suweb_web.2
$ vagrant ssh manager -c &amp;quot;docker ps&amp;quot;
CONTAINER ID        IMAGE                                                                                              COMMAND             CREATED              STATUS              PORTS               NAMES
b26cef6f4852        dockersamples/visualizer@sha256:f924ad66c8e94b10baeaf7bdb9cd491ef4e982a1d048a56a17e02bf5945401e5   &amp;quot;npm start&amp;quot;         About a minute ago   Up About a minute   8080/tcp            suweb_visualizer.1.qw03jh0fibxizukjrep7ipkaj
6742285357df        subond/suker@sha256:c2c33f0db407c195ae44dcafc5a81172afb1e88157efd489580148d73d8a532a               &amp;quot;python app.py&amp;quot;     2 minutes ago        Up 2 minutes        80/tcp              suweb_web.2.7q2481c0p04b908m5knwexgsa

# worker1节点上运行两个容器，suweb_web.1和suweb_web.3
$ vagrant ssh worker1 -c &amp;quot;docker ps&amp;quot;
CONTAINER ID        IMAGE                                                                                  COMMAND             CREATED             STATUS              PORTS               NAMES
e9207afbd53f        subond/suker@sha256:c2c33f0db407c195ae44dcafc5a81172afb1e88157efd489580148d73d8a532a   &amp;quot;python app.py&amp;quot;     4 minutes ago       Up 4 minutes        80/tcp              suweb_web.1.eu18grghbpbqyzu3nbflx1d4z
4f841d8748fd        subond/suker@sha256:c2c33f0db407c195ae44dcafc5a81172afb1e88157efd489580148d73d8a532a   &amp;quot;python app.py&amp;quot;     4 minutes ago       Up 4 minutes        80/tcp              suweb_web.3.6ugzg4hpvqiouhoy8u6109y3h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二步，持久化数据。利用Redis服务可进行数据的持久化数据，修改&lt;code&gt;docker-compose.yml&lt;/code&gt;文件，文件内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;version: &amp;quot;3&amp;quot;
services:
  web:
    image: subond/suker:v1.0
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: &amp;quot;0.1&amp;quot;
          memory: 50M
      restart_policy:
        condition: on-failure
    ports:
      - &amp;quot;80:80&amp;quot;
    networks:
      - webnet
  visualizer:
    image: dockersamples/visualizer:stable
    ports:
      - &amp;quot;8080:8080&amp;quot;
    volumes:
      - &amp;quot;/var/run/docker.sock:/var/run/docker.sock&amp;quot;
    deploy:
      placement:
        constraints: [node.role == manager]
    networks:
      - webnet
  redis:
    image: redis
    ports:
      - &amp;quot;6379:6379&amp;quot;
    volumes:
      - ./data:/data
    deploy:
      placement:
        constraints: [node.role == manager]
    networks:
      - webnet
networks:
  webnet:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来，在manager节点上创建数据卷，用于持久化数据；并更新&lt;code&gt;docker-compose.yml&lt;/code&gt;文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 创建数据卷目录
$ vagrant ssh manager -c &amp;quot;mkdir ./data&amp;quot;

# 更新`docker-compose.yml`文件，具体指令省略

# 更新之前的suweb服务或者删除suweb服务后重新部署，指令均如下
$ vagrant ssh manager -c &amp;quot;docker stack deploy -c docker-compose.yml suweb&amp;quot;
Creating network suweb_webnet
Creating service suweb_web
Creating service suweb_visualizer
Creating service suweb_redis

# 查看suweb应用的运行及分布情况
$ vagrant ssh manager -c &amp;quot;docker stack ps suweb&amp;quot;
ID            NAME                IMAGE                            NODE     DESIRED STATE  CURRENT STATE           ERROR  PORTS
r9j3wjnpkl9r  suweb_redis.1       redis:latest                     manager  Running        Running 15 seconds ago
5eyr3izyrv7h  suweb_visualizer.1  dockersamples/visualizer:stable  manager  Running        Running 19 seconds ago
ubdvzap007ml  suweb_web.1         subond/suker:v1.0                worker1  Running        Running 24 seconds ago
2dshgwsnfftp  suweb_web.2         subond/suker:v1.0                manager  Running        Running 24 seconds ago
v82zhyx225yu  suweb_web.3         subond/suker:v1.0                manager  Running        Running 23 seconds ago
&lt;/pre&gt;&lt;/div&gt;</content><category term="Cloud"></category><category term="Docker"></category></entry><entry><title>Docker技术：Dockerfile的定义与使用</title><link href="www.subond.com/pages/2017/04/18/dockerfile-ding-yi-he-shi-yong.html" rel="alternate"></link><published>2017-04-18T00:00:00+08:00</published><updated>2017-04-18T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-18:www.subond.com/pages/2017/04/18/dockerfile-ding-yi-he-shi-yong.html</id><summary type="html">&lt;p&gt;Dockerfile是Docker用来构建镜像的文本文件，包括自定义指令和格式。命令&lt;code&gt;docker build&lt;/code&gt;可以与Dockerfile文件中构建我们自己需要的镜像。&lt;/p&gt;</summary><content type="html">&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Dockerfile的使用"&gt;Dockerfile的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Dockerfile指令"&gt;Dockerfile指令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dockerfile是Docker用来构建镜像的文本文件，包括自定义指令和格式。命令&lt;code&gt;docker build&lt;/code&gt;可以与Dockerfile文件中构建我们自己需要的镜像。&lt;/p&gt;
&lt;h3&gt;Dockerfile的使用&lt;/h3&gt;
&lt;p&gt;Dockerfile文件描述了构建镜像的步骤，其中每条指定都是单独执行的。除了FROM指令，&lt;strong&gt;其他每条指令都会在上一条指令所生成镜像的基础上执行，执行完成后生成一个新的镜像层。新的镜像层覆盖在原来的镜像之上，进而形成新的镜像&lt;/strong&gt;。Dockerfile文件所生成的最终镜像是在基础镜像上叠加一层层的镜像形成的。&lt;/p&gt;
&lt;p&gt;值得注意的是，Docker引擎在构建镜像的过程中会缓存中间镜像。当从一个已经存在的基础镜像开始构建新镜像时，则将Dockerfile中的下一个指令和基础镜像的所有子镜像进行比较，如果有一个子镜像是由相同的指令生成的，则命中缓存，直接使用该镜像。&lt;/p&gt;
&lt;h3&gt;Dockerfile指令&lt;/h3&gt;
&lt;p&gt;Dockerfile的基本格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 注释信息
INSTRUCTION arguments
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dockerfile指令不区分大小写，但是建议使用大写，方便区分；#开头的表示注释行。根据指令的作用可以分分为两种：构建指令和设置指令。构建指令用于构建镜像，其指定的操作不会运行在镜像的容器上；而设置指令用于设置镜像的属性，其指定的操作运行在镜像的容器上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;FROM&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：FROM &lt;image&gt;或FROM &lt;image&gt;:&lt;tag&gt;&lt;br&gt;
分类：构建指令&lt;/p&gt;
&lt;p&gt;FROM指令指定基础镜像，一个有效的Dockerfile文件必须以FROM作为第一条非注释指令。后续的指令都依赖于该指令指定的image。FROM指令指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;MAINTAINER&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：MAINTAINER &lt;name&gt;&lt;br&gt;
分类：构建指令&lt;/p&gt;
&lt;p&gt;用于将image的制作者相关的信息写入到image中。当我们对该image执行docker inspect命令时，输出中有相应的字段记录该信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;RUN&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：RUN &lt;shell_cmd&gt;  # shell格式&lt;br&gt;
  或 RUN ["exec", "param1", "param2"]  # exec格式&lt;br&gt;
分类：构建指令&lt;/p&gt;
&lt;p&gt;RUN可以运行任何被基础image支持的命令。如基础image选择了ubuntu，那么软件管理部分只能使用ubuntu的命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;ENV&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：ENV &lt;key&gt; &lt;value&gt;&lt;br&gt;
分类：构建指令&lt;/p&gt;
&lt;p&gt;ENV指令用于在image中设置一个环境变量。设置完环境变量后，后续的RUN命令都可以使用，container启动后，可以通过docker inspect查看这个环境变量，也可以通过在docker run --env key=value时设置或修改环境变量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;WORKDIR&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：WORKDIR &lt;path&gt;&lt;br&gt;
分类：设置指令&lt;/p&gt;
&lt;p&gt;WORKDIR用于指定工作目录，相当于切换指令，对RUN,CMD,ENTRYPOINT生效，可设置多次。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;ADD&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：ADD &lt;src&gt; &lt;dest&gt;&lt;br&gt;
分类：构建指令&lt;/p&gt;
&lt;p&gt;&lt;src&gt; 是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url&lt;br&gt;
&lt;dest&gt; 是container中的绝对路径&lt;/p&gt;
&lt;p&gt;所有复制到容器中的文件和文件夹权限为0755，uid和gid为0；如果是一个目录，那么会将该目录下的所有文件添加到容器中，不包括目录；如果文件是可识别的压缩格式，则Docker引擎会进行解压缩；如果&lt;src&gt;是文件且&lt;dest&gt;中不使用斜杠结束，则会将&lt;dest&gt;视为文件，&lt;src&gt;的内容会写入&lt;dest&gt;；如果&lt;src&gt;是文件且&lt;dest&gt;中使用斜杠结束，则会&lt;src&gt;文件拷贝到&lt;dest&gt;目录下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;COPY&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：COPY &lt;src&gt; &lt;dest&gt;&lt;br&gt;
分类：构建指令&lt;/p&gt;
&lt;p&gt;COPY指令复制&lt;src&gt;所指向的文件或目录，将其添加至新镜像中，复制的文件或目录在镜像中的路径是&lt;dest&gt;。&lt;src&gt;所指定的源可以是多个，但必须使上下文根目录的相对路径；也可以使用通配符指向所有匹配通配符的文件或目录。&lt;/p&gt;
&lt;p&gt;&lt;dest&gt;可以是文件或目录，但必须使镜像中的绝对路径或相对于WORKDIR的相对路径。&lt;/p&gt;
&lt;p&gt;若&lt;dest&gt;以反斜杠/结尾则其指向是目录，否则指向文件。&lt;src&gt;同理。&lt;/p&gt;
&lt;p&gt;若&lt;dest&gt;是文件，则&lt;src&gt;的内容被写入&lt;dest&gt;中；否则&lt;src&gt;所指向的文件或目录中的内容被复制到&lt;dest&gt;目录中。&lt;/p&gt;
&lt;p&gt;当&lt;src&gt;指定多个源时，&lt;dest&gt;必须使目录。若&lt;dest&gt;不存在，则会被创建。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;CMD&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：RUN &lt;shell_cmd&gt;  # shell格式&lt;br&gt;
或者：RUN ["exec", "param1", "param2"]  # exec格式&lt;br&gt;
或者：RUN ["param1", "param2"]  # 为ENTRYPOINT指令提供参数&lt;br&gt;
分类：设置指令&lt;/p&gt;
&lt;p&gt;CMD指令为容器运行时指定的操作默认操作。该操作可以是执行自定义脚本，也可以是执行系统命令。该指令只能在文件中存在一次，如果有多个，则只执行最后一条。&lt;/p&gt;
&lt;p&gt;第三种情况时，ENTRYPOINT指定的是一个可执行的脚本或者程序的路径，该指定的脚本或者程序将会以param1和param2作为参数执行。所以如果CMD指令使用上面的形式，那么Dockerfile中必须要有配套的ENTRYPOINT。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;ENTRYPOINT（设置container启动时执行的操作&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：ENTRYPOINT &lt;commond&gt;  # shell格式&lt;br&gt;
或者：ENTRYPOINT ["exec", "param1", "param2"]  # exec格式&lt;br&gt;
分类：设置指令&lt;/p&gt;
&lt;p&gt;ENTRYPOINT指定容器启动时执行的命令，可以多次设置，但是只有最后一个有效。该指令的使用分为两种情况，一种是独自使用，另一种和CMD指令配合使用。当独自使用时，如果你还使用了CMD命令且CMD是一个完整的可执行的命令，那么CMD指令和ENTRYPOINT会互相覆盖只有最后一个CMD或者ENTRYPOINT有效。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# CMD指令将不会被执行，只有ENTRYPOINT指令被执行  
CMD echo “Hello, World!”  
ENTRYPOINT ls -l  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CMD指令配合使用来指定ENTRYPOINT的默认参数，这时CMD指令不是一个完整的可执行命令，仅仅是参数部分；ENTRYPOINT指令只能使用JSON方式指定执行命令，而不能指定参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FROM ubuntu  
CMD [&amp;quot;-l&amp;quot;]  
ENTRYPOINT [&amp;quot;/usr/bin/ls&amp;quot;]  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;USER&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：USER &lt;name&gt;&lt;br&gt;
分类：设置指令&lt;/p&gt;
&lt;p&gt;USER用于设置启动容器的用户，默认是root用户。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;EXPOSE 指定容器需要映射到宿主机器的端口）&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：EXPOSE &lt;port&gt;  [&lt;port&gt;...]&lt;br&gt;
分类：设置指令&lt;/p&gt;
&lt;p&gt;EXPOSE用于指定容器需要映射到宿主机器的端口。当你需要访问容器的时候，可以不是用容器的IP地址而是使用宿主机器的IP地址和映射后的端口。要完成整个操作需要两个步骤，首先在Dockerfile使用EXPOSE设置需要映射的容器端口，然后在运行容器的时候指定-p选项加上EXPOSE设置的端口，这样EXPOSE设置的端口号会被随机映射成宿主机器中的一个端口号。也可以指定需要映射到宿主机器的那个端口，这时要确保宿主机器上的端口号没有被使用。EXPOSE指令可以一次设置多个端口号，相应的运行容器的时候，可以配套的多次使用-p选项。&lt;/p&gt;
&lt;p&gt;端口映射是docker比较重要的一个功能，原因在于每次运行容器的时候容器的IP地址不能指定而是在桥接网卡的地址范围内随机生成的。宿主机器的IP地址是固定的，我们可以将容器的端口的映射到宿主机器上的一个端口，免去每次访问容器中的某个服务时都要查看容器的IP的地址。对于一个运行的容器，可以使用docker port加上容器中需要映射的端口和容器的ID来查看该端口号在宿主机器上的映射端口。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 映射一个端口  
EXPOSE port1  
# 相应的运行容器使用的命令  
docker run -p port1 image  

# 映射多个端口  
EXPOSE port1 port2 port3  
# 相应的运行容器使用的命令  
docker run -p port1 -p port2 -p port3 image  
# 还可以指定需要映射到宿主机器上的某个端口号  
docker run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;VOLUME（指定挂载点）&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：VOLUME ["&amp;lt;mountpoint"]&lt;br&gt;
分类：设置指令&lt;/p&gt;
&lt;p&gt;VOLUME指令用于指定容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器使用。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;VOLUME [&amp;quot;&amp;lt;mountpoint&amp;gt;&amp;quot;]
FROM base  
VOLUME [&amp;quot;/tmp/data&amp;quot;]
# 运行通过该Dockerfile生成image的容器，/tmp/data目录中的数据在容器关闭后，里面的数据还存在。
# 例如另一个容器也有持久化数据的需求，且想使用上面容器共享的/tmp/data目录，那么可以运行下面的命令启动一个容器：
$ docker run -t -i -rm -volumes-from container1 image2 bash
# container1为第一个容器的ID，image2为第二个容器运行image的名字。
&lt;/pre&gt;&lt;/div&gt;</content><category term="Cloud"></category><category term="Docker"></category></entry><entry><title>Docker技术：Docker系统架构</title><link href="www.subond.com/pages/2017/04/16/docker-xi-tong-jia-gou.html" rel="alternate"></link><published>2017-04-16T00:00:00+08:00</published><updated>2017-04-16T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-16:www.subond.com/pages/2017/04/16/docker-xi-tong-jia-gou.html</id><summary type="html">&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Docker Engine"&gt;Docker Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Docker交付内容"&gt;Docker交付内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Docker系统架构"&gt;Docker系统架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Docker Engine&lt;/h3&gt;
&lt;p&gt;Docker Engine主要包含三个组件，如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker Server：一个长时间运行的守护进程。&lt;/li&gt;
&lt;li&gt;REST API：指定程序可以用来与守护进程通信的接口。&lt;/li&gt;
&lt;li&gt;Client：命令行CLI客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Docker全局预览" src="http://on64c9tla.bkt.clouddn.com/2017A/Docker-overview.png"&gt;&lt;/p&gt;
&lt;p&gt;CLI利用脚本或直接输入命令的方式，通过REST API与Docker Daemon(守护进程)进行通信，并完成相关操作。Docker Damemon是负责容器对象的主体，例如镜像，容器实例，网络管理以及数据卷等。&lt;/p&gt;
&lt;h3&gt;Docker交付内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;快速，一致地交付应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker允许开发人员通过提供本地容器标准化环境，从而简化应用程序和服务的开发生命周期。容器可以适用于连续集成和持续开发的工作流程。Docker的便携性和轻量级性质使得轻松实现动态管理工作负载，按照业务需求来实现扩展或拆除应用程序和服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在同一硬件上可允许多个工作流程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker重量轻，速度快。它为基于虚拟机管理程序的虚拟机提供了可行的，具有成本效益的替代方案，因此可以使用更多的计算能力来实现业务目标。Docker是高密度环境和中小型部署的理想选择，您需要用更少的资源来做更多的事情。&lt;/p&gt;
&lt;h3&gt;Docker系统架构&lt;/h3&gt;
&lt;p&gt;Docker采用Client/Server架构模式，其系统架构如下图所示 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Docker Engine"&gt;Docker Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Docker交付内容"&gt;Docker交付内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Docker系统架构"&gt;Docker系统架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Docker Engine&lt;/h3&gt;
&lt;p&gt;Docker Engine主要包含三个组件，如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker Server：一个长时间运行的守护进程。&lt;/li&gt;
&lt;li&gt;REST API：指定程序可以用来与守护进程通信的接口。&lt;/li&gt;
&lt;li&gt;Client：命令行CLI客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Docker全局预览" src="http://on64c9tla.bkt.clouddn.com/2017A/Docker-overview.png"&gt;&lt;/p&gt;
&lt;p&gt;CLI利用脚本或直接输入命令的方式，通过REST API与Docker Daemon(守护进程)进行通信，并完成相关操作。Docker Damemon是负责容器对象的主体，例如镜像，容器实例，网络管理以及数据卷等。&lt;/p&gt;
&lt;h3&gt;Docker交付内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;快速，一致地交付应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker允许开发人员通过提供本地容器标准化环境，从而简化应用程序和服务的开发生命周期。容器可以适用于连续集成和持续开发的工作流程。Docker的便携性和轻量级性质使得轻松实现动态管理工作负载，按照业务需求来实现扩展或拆除应用程序和服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在同一硬件上可允许多个工作流程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker重量轻，速度快。它为基于虚拟机管理程序的虚拟机提供了可行的，具有成本效益的替代方案，因此可以使用更多的计算能力来实现业务目标。Docker是高密度环境和中小型部署的理想选择，您需要用更少的资源来做更多的事情。&lt;/p&gt;
&lt;h3&gt;Docker系统架构&lt;/h3&gt;
&lt;p&gt;Docker采用Client/Server架构模式，其系统架构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Docker系统架构" src="http://on64c9tla.bkt.clouddn.com/2017A/docker.png"&gt;&lt;/p&gt;
&lt;p&gt;Docker客户端与守护进程既可以运行在同一台主机，也运行在不同的主机上，两者利用Unix Socket或网络接口，通过REST API进行通信。&lt;/p&gt;
&lt;p&gt;Docker Daemon监听Docker API来相应客户端的请求，完成Docker对象的管理。&lt;/p&gt;
&lt;p&gt;Docker客户端是用户与Docker Daemon进行交互的主要方式。&lt;/p&gt;
&lt;p&gt;Docker Registries用来管理Docker镜像。&lt;/p&gt;</content><category term="Cloud"></category><category term="Docker"></category></entry><entry><title>Docker技术：认识Docker</title><link href="www.subond.com/pages/2017/04/14/docker-ren-shi-docker.html" rel="alternate"></link><published>2017-04-14T00:00:00+08:00</published><updated>2017-04-14T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-14:www.subond.com/pages/2017/04/14/docker-ren-shi-docker.html</id><summary type="html">&lt;p&gt;Docker是使用Go语言进行开发实现，基于Linux内核的cgroup, namespace, 以及AUFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他隔离的进程，因此成为容器。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Docker和传统虚拟化方式的不同如下图所示。传统虚拟化技术是虚拟出一套硬件，在其上运行一个完整操作系统，再在该系统之上再运行所需的应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。&lt;/p&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#1.什么是Docker"&gt;1.什么是Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2.Docker基本概念"&gt;2.Docker基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#3.Docker安装"&gt;3.Docker安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4.Docker网络"&gt;4.Docker网络&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.什么是Docker&lt;/h3&gt;
&lt;p&gt;Docker是使用Go语言进行开发实现，基于Linux内核的cgroup, namespace, 以及AUFS类的Union FS等技术，对 &lt;strong&gt;进程&lt;/strong&gt; 进行封装隔离，属于 &lt;strong&gt;操作系统层面的虚拟化技术&lt;/strong&gt;。&lt;em&gt;由于隔离的进程独立于宿主和其他隔离的进程，因此成为容器&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;Docker和传统虚拟化方式的不同如下图所示。传统虚拟化技术是虚拟出一套硬件，在其上运行一个完整操作系统，再在该系统之上再运行所需的应用进程；而容器内的 &lt;strong&gt;应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Docker与虚拟化技术" src="http://on64c9tla.bkt.clouddn.com/2017A/Docker-vm.png"&gt;&lt;/p&gt;
&lt;h3&gt;2.Docker基本概念&lt;/h3&gt;
&lt;p&gt;Docker包括三个基本概念：&lt;strong&gt;镜像&lt;/strong&gt;、&lt;strong&gt;容器&lt;/strong&gt;、&lt;strong&gt;仓库&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 镜像(Image)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载&lt;code&gt;root&lt;/code&gt;文件系统为其提供用户空间支持。而Docker镜像，就相当于一个&lt;code&gt;root&lt;/code&gt;文件系统。&lt;/p&gt;
&lt;p&gt;Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件，也包含一些为应用运行时准备的配置参数。&lt;strong&gt;镜像不包含任何动态数据，其内容在构建之后也不会被改变&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分层存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;镜像在构建时，一层层构建，前一层是后一层的基础。每一层构建完成后就不会再发生改变，后一层上的任何改变值发生在自己这一层。当我们使用命令&lt;code&gt;docker pull ubuntu:14.04&lt;/code&gt;获取ubuntu14.04镜像时，可以看到每一层的镜像，及其相互依赖关系。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 获取DockerHub中的ubuntu14.04镜像
$ docker pull ubuntu:16.04
16.04: Pulling from library/ubuntu
b6f892c0043b: Pull complete
55010f332b04: Pull complete
2955fb827c94: Pull complete
3deef3fcbd30: Pull complete
cf9722e506aa: Pull complete
Digest: sha256:382452f82a8bbd34443b2c727650af46aced0f94a44463c62a9848133ecb1aa8
Status: Downloaded newer image for ubuntu:16.04
# 可以看到，整个ubuntu16.04镜像由五层存储构成

# 仓库的元数据
# 在文件/var/lib/docker/image/graph_dirver/repositories.json中可以看到仓库的元数据
$ cat repositories.json | python -mjson.tool
{
    &amp;quot;Repositories&amp;quot;: {
        &amp;quot;ubuntu&amp;quot;: {
            &amp;quot;ubuntu:16.04&amp;quot;: &amp;quot;sha256:ebcd9d4fca80e9e8afc525d8a38e7c56825dfb4a220ed77156f9fb13b14d4ab7&amp;quot;,
            &amp;quot;ubuntu@sha256:382452f82a8bbd34443b2c727650af46aced0f94a44463c62a9848133ecb1aa8&amp;quot;: &amp;quot;sha256:ebcd9d4fca80e9e8afc525d8a38e7c56825dfb4a220ed77156f9fb13b14d4ab7&amp;quot;
        }
    }
}

# 镜像的元数据
# 在文件/var/lib/docker/image/graph_dirver/imagedb/content/sha256/[image_id]中可以看到镜像的元数据
# 命令cat image_id | python -mjson.tool

# 镜像层的元数据
# 在文件/var/lib/docker/image/graph_dirver/layerdb/sha256/[chain_id]
# [chain_id]是某一层镜像层的存储索引
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2 容器(Container)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器的实质是进程&lt;/strong&gt;。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，称为“容器存储层”。容器存储层的生命周期与容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存在容器存储层的信息都会随容器删除而丢失。&lt;/p&gt;
&lt;p&gt;容器是Docker的核心概念。简单来讲，容器是 &lt;strong&gt;独立运行的一个或一组应用，以它们的运行态环境&lt;/strong&gt;。与之对应的，容易混淆的概念是虚拟机。虚拟机可以理解为 &lt;strong&gt;模拟运行的一整套操作系统(包括运行态环境和其他系统环境)和运行在操作系统上的应用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;容器的核心为所执行的应用程序，所需要的资源都是应用程序所必需的的。当Docker容器中指定的应用终结时，容器也自动终止。当利用&lt;code&gt;docker run&lt;/code&gt;创建容器时，Docker在后台运行的标准操作包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查本地是否存在指定的镜像，不存在就从公有仓库下载  &lt;/li&gt;
&lt;li&gt;利用镜像创建并启动一个容器  &lt;/li&gt;
&lt;li&gt;分配一个文件系统，并在只读的镜像层外面挂载一层可读写层  &lt;/li&gt;
&lt;li&gt;从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中  &lt;/li&gt;
&lt;li&gt;从地址池配置一个ip地址给容器  &lt;/li&gt;
&lt;li&gt;执行用户指定的应用程序  &lt;/li&gt;
&lt;li&gt;执行完毕后容器被终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3 仓库(Repository)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仓库(Repository)是集中存放镜像的地方，每个仓库下面有多个镜像。因此，仓库可以被认为是一个具体的项目或目录。仓库分为公有仓库和本地仓库(私有仓库)，公有仓库Docker Hub由Docker公司或用户维护，主要包括根镜像和用户镜像；而本地仓库可供私人使用。&lt;/p&gt;
&lt;h3&gt;3.Docker安装&lt;/h3&gt;
&lt;p&gt;对于Ubuntu系列，Docker CE支持以下三种64位发行版：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Yakkety 16.10&lt;/li&gt;
&lt;li&gt;Xenial 16.04&lt;/li&gt;
&lt;li&gt;Trusty 14.04&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一步：设置仓库。可以通过&lt;code&gt;lsb_release -cs&lt;/code&gt;命令查看Ubuntu系统版本，然后添加相应的仓库。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo apt-get -y install apt-transport-https ca-certificates curl
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg &lt;span class="p"&gt;|&lt;/span&gt; sudo apt-key add -
$ sudo add-apt-repository &lt;span class="s2"&gt;&amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;lsb_release -cs&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt; stable&amp;quot;&lt;/span&gt;
$ sudo apt-get update
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二步：获取Docker CE&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo apt-get install -y docker-ce
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第三步：检查Docker版本，查看是否安装成功。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker --version
&lt;span class="c1"&gt;# Docker version 17.04.0-ce, build 4845c56&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第四步：建立Docker用户组&lt;/p&gt;
&lt;p&gt;默认情况下，docker命令使用Unix Socket与Docker Daemon通信，而只有root用户和docker组用户才可以与Docker Daemon的Unix Socket建立通信。因此，出于安全考虑，我们可以将使用docker的用户加入Docker用户组。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 建立docker用户组
$ sudo groupadd docker
# 将当前用户加入docker用户组
$ sudo usermod -aG docker $USER
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4.Docker网络&lt;/h3&gt;
&lt;p&gt;Docker使用-p参数指定网络端口，将宿主主机的端口与容器中的端口形成映射关系。容器的连接(linking)系统是除了端口映射外，另一种与容器中应用的方式。&lt;strong&gt;连接系统可以在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息，而且不用映射容器的端口到宿主主机上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Docker通过2种方式为容器公开连接信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境变量  &lt;/li&gt;
&lt;li&gt;更新/etc/hosts文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;高级网络配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当Docker启动时，自动在宿主机上创建一个&lt;code&gt;docker0&lt;/code&gt;虚拟网桥，实际上是Linux的一个网桥，对挂载到它的网口进行数据转发。同时，Docker随机分配一个本地未占用的私有网段中的一个地址给&lt;code&gt;docker0&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;当创建一个Docker容器的时候，同时会创建一对&lt;code&gt;veth pair&lt;/code&gt;接口(虚拟网络设备对：即一对端口，当数据包发送到一个端口时，另一个端口也可以收到相同的数据包)。这对接口一端在容器内，即&lt;code&gt;eth0&lt;/code&gt;；另一端在本地并被挂载到&lt;code&gt;docker0&lt;/code&gt;网桥，名称以&lt;code&gt;veth&lt;/code&gt;开头。通过这种方式，主机可以跟容器通信，容器之间也可以通信。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Docker网络" src="http://on64c9tla.bkt.clouddn.com/Comput/docker_network.png"&gt;&lt;/p&gt;</content><category term="Cloud"></category><category term="Docker"></category></entry><entry><title>Dynamo分布式键值系统</title><link href="www.subond.com/pages/2017/04/09/dynamo-distributed-systems.html" rel="alternate"></link><published>2017-04-09T00:00:00+08:00</published><updated>2017-04-09T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-09:www.subond.com/pages/2017/04/09/dynamo-distributed-systems.html</id><summary type="html">&lt;p&gt;分布式键值模型是分布式表格模型的一种特例，一般只支持单个key-value的“增、删、查、改”操作，因此适用 &lt;strong&gt;哈希分布算法&lt;/strong&gt;。Amazon Dynamo是分布式键值系统，学习Dynamo的设计思想，设计原则，对理解分布式系统理论很有帮助。&lt;/p&gt;</summary><content type="html">&lt;p&gt;分布式键值模型是分布式表格模型的一种特例，一般只支持单个key-value的“增、删、查、改”操作，因此适用 &lt;strong&gt;哈希分布算法&lt;/strong&gt;。Amazon Dynamo是分布式键值系统，学习Dynamo的设计思想，设计原则，对理解分布式系统理论很有帮助。&lt;/p&gt;
&lt;h3&gt;Amazon Dynamo&lt;/h3&gt;
&lt;p&gt;Dynamo以简单的键值方式存储数据，且存储的是数据的原始形式，不解析数据的内容。以下是Dynamo设计中面临的问题及解决方案，接下来依次查看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Dynamo设计" src="http://on64c9tla.bkt.clouddn.com/Comput/dynamo.png"&gt;&lt;/p&gt;
&lt;h4&gt;数据分布&lt;/h4&gt;
&lt;p&gt;改进的一致性哈希算法(也称为一致性哈希表，简称DHT)的思想是：每一个物理节点根据其性能的差异分配多个token，&lt;strong&gt;每个token对应一个“虚拟节点”&lt;/strong&gt;。每个虚拟节点的处理能力相当，并 &lt;strong&gt;随机分布&lt;/strong&gt; 在哈希空间中，存储时，数据根据哈希值落在某个虚拟节点的负责的区域中，然后被存储在该虚拟节点对应的物理节点上。&lt;/p&gt;
&lt;p&gt;&lt;img alt="改进的哈希一致性算法" src="http://on64c9tla.bkt.clouddn.com/Comput/dynamo_hash.png"&gt;&lt;/p&gt;
&lt;p&gt;为了找到数据所属的节点，Dynamo系统中 &lt;strong&gt;每个节点维护整个集群的信息&lt;/strong&gt;，客户端也缓存整个集群的信息。与此同时，为了保证每个节点缓存是Dynamo系统中最新的集群信息，&lt;strong&gt;所有节点每隔固定时间&lt;/strong&gt; 通过 &lt;strong&gt;Gossip协议&lt;/strong&gt; 从其他节点中任意一个与之通信的节点。如果连接成功，&lt;strong&gt;双方交换各自保存的集群信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;【补充】：Gossip协议&lt;/p&gt;
&lt;p&gt;Gossip协议用于P2P系统中自洽的节点协调对整个集群的认识，比如集群的节点，负载情况等。一个简单的例子是这样的(集群中节点A和节点B交换对集群的认识)。&lt;/p&gt;
&lt;p&gt;1）A告诉B其管理的所有节点的版本（包括Down状态和Up状态的节点）&lt;br&gt;
2）B告诉A哪些版本比较旧，哪些版本它有最新的，然后把那些最新的版本发给A（处于Down状态下的版本由于没有更新，所有不会被关注）&lt;br&gt;
3）A将B中比较旧的版本发给B，同时将B发来的最新节点信息做本地更新&lt;br&gt;
4）B收到A发来的最新节点信息，然后做本地更新  &lt;/p&gt;
&lt;h4&gt;一致性和复制&lt;/h4&gt;
&lt;p&gt;Dynamo系统中对副本的管理思想是：假设数据存储N份，DHT定位到数据存储所属的节点K，则将数据存储在节点K, K+1, ..., K+N-1。如果第k+i(0&amp;lt;=i&amp;lt;=N-1)台机器，则往后找一台机器K+N临时替代。如果K+i台机器重启，临时替代的机器K+N能够通过Gossip协议发现，并把临时数据归还K+i，这个过程称为“&lt;strong&gt;消息回传&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;Dynamo中的NWR机制，其中N表示副本数，R表示成功读取操作的最少节点数，W表示成功写操作的最少节点数。只要满足W+R&amp;gt;N，可以保证当存在不超过一台机器故障时，至少能够读到一份有效的数据。由于每个节点存储的集群信息有所不同，可能出现同一条记录被多个节点同时更新，但不能多个节点之间的更新顺序。因此，Dynmao利用 &lt;strong&gt;向量时钟&lt;/strong&gt; 技术了解决冲突。&lt;/p&gt;
&lt;p&gt;向量时钟机制如下：&lt;/p&gt;
&lt;p&gt;[nodes, counter]：其中nodes表示节点，counter表示计数器，初始为0，节点每次更新操作加1。&lt;/p&gt;
&lt;p&gt;&lt;img alt="向量时钟" src="http://on64c9tla.bkt.clouddn.com/Comput/vectorclock.png"&gt;&lt;/p&gt;
&lt;h4&gt;容错&lt;/h4&gt;
&lt;p&gt;Dynamo中异常分为两种：临时性异常和永久性异常。Dynamo中的容错机制包括：&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;数据回传&lt;/strong&gt;。&lt;br&gt;
2）&lt;strong&gt;Merkle树同步&lt;/strong&gt;。当出现永久性异常时，利用Merkle树机制从其他副本进行数据同步。其原理是，每个非叶子节点对应多个文件(为其所有节点值组合以后的哈希值)；叶子节点对应单个数据文件(为文件内容的哈希值)。因此，&lt;strong&gt;任何一个数据文件不匹配都将导致从该文件对应的叶子节点到根节点的所有节点值不同&lt;/strong&gt;。每台机器对每一段范围的数据维护一棵Merkle树，机器同步时首先传输Merkle树信息，并且只需要同步从根到叶子的所有节点值均不同的文件。&lt;br&gt;
3）&lt;strong&gt;读取故障&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;负载均衡&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Dynamo的负载均衡取决于如何给每个机器分配虚拟节点号，即token&lt;/strong&gt;。一般有两种方法，如下所述。&lt;/p&gt;
&lt;p&gt;第一种，&lt;strong&gt;随机分配&lt;/strong&gt;。每台物理节点加入时根据其配置情况随机分配S个Token。优缺点是：可控性差，新节点加入/删除时，集群中的原有节点都需要扫描所有的数据从而找出属于新节点的数据，Merkle树也需要全部更新。&lt;/p&gt;
&lt;p&gt;第二种，&lt;strong&gt;数据范围等分+随机分配&lt;/strong&gt;。其思想是将数据额哈希空间等分为Q = N x S份(N = 机器数，S = 每台机器的虚拟节点数)，然后每台机器随机选取S个分割点作为Token。优缺点：每台机器都可以对属于每个范围的数据维护一棵逻辑上的Merkle树，新节点加入/删除，只需要扫描部分数据进行同步，并更新这部分数据对应的逻辑Merkle树。&lt;/p&gt;
&lt;h4&gt;读写流程&lt;/h4&gt;
&lt;p&gt;Dynamo的读写流程如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="写操作流程" src="http://on64c9tla.bkt.clouddn.com/Comput/dynamowrite.png"&gt;&lt;/p&gt;
&lt;p&gt;1) 根据一致性哈希算法计算出每个副本所在的存储节点，然后选取一个副本作为协调者。&lt;/p&gt;
&lt;p&gt;2）协调者 &lt;strong&gt;并发&lt;/strong&gt; 地往所有其他副本发送写请求，并将数据写入本地；如果发送写请求失败，协调者将它加入重试列表并不断重试。&lt;/p&gt;
&lt;p&gt;3）当副本接收到数据后，成功写入本地，并回复协调者&lt;/p&gt;
&lt;p&gt;4）等到W-1(协调者写入成功)个副本回复写入成功后，协调者恢复客户端写入成功；并继续等待或重试，直到所有副本写入成功。&lt;/p&gt;
&lt;p&gt;&lt;img alt="读操作流程" src="http://on64c9tla.bkt.clouddn.com/Comput/dynamoread.png"&gt;&lt;/p&gt;
&lt;p&gt;1）根据一致性哈希算法计算出每个副本所在的存储节点，然后选取一个副本作为协调者&lt;/p&gt;
&lt;p&gt;2）协调者根据负载策略选择R个副本，&lt;strong&gt;并发&lt;/strong&gt; 地向它们发送请求，并读取本地数据。&lt;/p&gt;
&lt;p&gt;3）每个副本读取本地数据，回复协调者读取结果。&lt;/p&gt;
&lt;p&gt;4）等到R-1个副本读取成功后，回复客户端。分两种情况，一种是，R个副本返回的数据一致，则将读取结果回复客户端；另一种是根据 &lt;strong&gt;冲突处理机制&lt;/strong&gt; （根据修改的时间戳选择最新数据）合并多个副本的读取结果，然后回复客户端。&lt;/p&gt;</content><category term="Amazon"></category><category term="Distributed Systems"></category></entry><entry><title>GFS分布式文件系统</title><link href="www.subond.com/pages/2017/04/06/gfs-distributed-systems.html" rel="alternate"></link><published>2017-04-06T00:00:00+08:00</published><updated>2017-04-06T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-04-06:www.subond.com/pages/2017/04/06/gfs-distributed-systems.html</id><summary type="html">&lt;p&gt;分布式文件系统主要有两个功能：一个是存储文档，图像，视频之类的Blob类数据；一个是作为分布式表格系统的持久化层。分布式文件系统中最著名的就是Google File System(GFS)，因此，本章通过介绍GFS的内部实现机制来学习分布式文件系统的知识与设计。&lt;/p&gt;</summary><content type="html">&lt;p&gt;分布式文件系统主要有两个功能：一个是存储文档，图像，视频之类的Blob类数据；一个是作为分布式表格系统的持久化层。分布式文件系统中最著名的就是Google File System(GFS)，因此，本章通过介绍GFS的内部实现机制来学习分布式文件系统的知识与设计。&lt;/p&gt;
&lt;h3&gt;1 整体架构&lt;/h3&gt;
&lt;p&gt;&lt;img alt="GFS整体架构" src="http://on64c9tla.bkt.clouddn.com/Comput/gfs-architecture.png"&gt;&lt;/p&gt;
&lt;p&gt;一个GFS系统中的节点有三种角色：&lt;strong&gt;GFS主控服务器(GFS Master)，GFS数据块服务器(GFS ChunkServer)和GFS客户端&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;GFS存储系统中的文件被分割成固定大小的数据块(chunk)，在chunk创建时，Master服务器给每个chunk分配一个全局唯一的chunk句柄。数据块服务器(ChunkServer,CS)把chunk以linux文件的形式存储到磁盘中，并根据指定的chunk句柄和字节范围来读写数据。为了保证可靠性，chunk在不同的服务器中复制多个副本，默认是三份。&lt;/p&gt;
&lt;p&gt;主控服务器维护系统的元数据，包括文件，chunk命名空间，文件到chunk之间的映射关系，chunk位置信息。同时，也负责整个系统的全局控制，如chunk租约管理，垃圾回收无用的chunk，chunk复制等。主控服务器 &lt;strong&gt;周期地&lt;/strong&gt; 与CS服务器通过 &lt;strong&gt;心跳的方式&lt;/strong&gt; 交换信息。&lt;/p&gt;
&lt;p&gt;客户端是GFS提供给应用程序的访问接口，它是一组专用接口，不遵循POSIX规范，以库文件的形式提供。客户端访问GFS时，首先访问主控服务器节点，获取与之交互的CS信息，然后直接访问这些CS，完成数据存取工作。值得注意的是，GFS客户端不缓存文件数据，只缓存主控服务器中获取的元数据。&lt;/p&gt;
&lt;h3&gt;2 关键问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1租约机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GFS系统中通过租约机制将chunk写操作授权给ChunkServer，从而减轻Master的负载。拥有租约授权的ChunkServer称为主ChunkServer，其他副本所在的ChunkServer称为备ChunkServer。主ChunkServer可以不断向Master请求延长租约的有效期直到整个chunk写满。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2一致性模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GFS系统主要是为了追加(append)而不是改写(overwrite)而设计的。如果不发生异常，追加成功的记录在GFS的各个副本中是确定并且严格一致的；如果出现异常，客户端将追究重试，直至成功（所有副本中至少成功追加一次）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3追加流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;追加流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gfs-append" src="http://on64c9tla.bkt.clouddn.com/Comput/gfs-append.png"&gt;&lt;/p&gt;
&lt;p&gt;1）客户端向Master请求chunk每个副本所在的ChunkServer，其中主ChunkServer持有修改租约。如果没有ChunkServer持有租约，说明该chunk最近没有写操作，Master会发起一个任务，按照一定的策略将chunk的租约授权给其中的一台ChunkServer。&lt;/p&gt;
&lt;p&gt;2）Master返回给客户端主副本和备副本所在的chunk的位置信息，客户端将缓存这些信息供以后使用。如果不出现故障，客户端以后读写该chunk都不需要再次请求Master。&lt;/p&gt;
&lt;p&gt;3）客户端将追加的记录发送到每一个副本中，每一个ChunkServer会在内部的LRU结构中缓存这些数据。GFS中采用数据流和控制流分流的方法，从而能够基于网络拓扑结构更好地调度数据流的传输。&lt;/p&gt;
&lt;p&gt;4）当所有副本都确认收到了数据，客户端发起一个写请求控制命令给主副本。由于主副本可能收到多个客户端对同一个chunk的并发追加操作，主副本将确定这些操作的顺序写入本地。&lt;/p&gt;
&lt;p&gt;5）主副本把写请求提交给所有的副本。每一个备副本会根据主副本确定的顺序执行写操作。&lt;/p&gt;
&lt;p&gt;6）备副本成功完成后应答主副本。&lt;/p&gt;
&lt;p&gt;7）主副本应答客户端，如果有副本发生错误，将出现主副本写成功但某些备副本不成功的情况，客户端将重试。&lt;/p&gt;
&lt;p&gt;GFS追加有两个特色：流水线及分离数据流和控制流。流水线操作可以减少延时。分离数据流和控制流主要为了优化数据传输，每一台机器都是把数据发送给网络拓扑图上”最近“的尚未收到数据的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4容错机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）Master容错&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Master容错通过操作日志加checkpoint的方式进行，并有一台称为“Shadow Master”的实时热备&lt;/em&gt;。Master的修改操作总是先记录操作日志，然后修改内存。当Master发生故障重启时，可以通过磁盘中的操作日志恢复内存中的数据结构。与此同时，为了减少Mater宕机的恢复时间，Master定期将内存中的数据以checkpoint文件的形式转储到磁盘中，从而减少回放的日志量。为了进一步提供Master的可靠性和可用性，所有的元数据修改操作都必须保证发送到实时热备才算成功。&lt;/p&gt;
&lt;p&gt;补充知识：&lt;strong&gt;元数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主控服务器存储三种主要类型的元数据：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件和chunk命名空间&lt;/strong&gt;，也就是整个文件系统的目录结构以及chunk基本信息；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件和chunk的映射关系&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个chunk副本的位置信息&lt;/strong&gt;，默认情况下，每个chunk有三个副本。&lt;/p&gt;
&lt;p&gt;所有的元数据都保存在Master服务器的内存中。同时，前两种类型的元数据（文件和chunk命名空间，文件和chunk映射关系）也会以记录的方式记录在操作系统的系统日志中，并存储在持久化介质上，另外，日志会复制到其他远程的主控服务器上进行热备。这样做的目的是，提供简单的可靠性，保证主控服务器崩溃的情况下数据的一致性。&lt;/p&gt;
&lt;p&gt;每个chunk的元数据不超过64字节。那么1PB数据的chunk元数据大小不超过1PB x 3 / 64MB x 64 = 3GB。&lt;/p&gt;
&lt;p&gt;2）ChunkServer容错&lt;/p&gt;
&lt;p&gt;简单来讲，ChunkServer容错包括 &lt;strong&gt;副本&lt;/strong&gt; 和 &lt;strong&gt;校验和&lt;/strong&gt; 两种方式。GFS采用复制多个chunk副本的方式实现ChunkServer容错，每个chunk的多个存储副本分别存储在不同的ChunkServer上。对于每个chunk，必须将所有的chunk副本全部写入成功，才视为成功写入。若出现某个副本丢失或者不可恢复时，Master自动将副本复制到其他ChunkServer，确保副本保持一定的个数。ChunkServer会对存储的数据维持校验和。每个64MB大小的chunk以Blok单位进行划分，Block大小为64KB，每个Block对应一个32位的校验和。若读取一个chunk副本时，ChunkServer通过读取数据和校验和进行比较，如果不匹配，则返回错误，客户端将选择其他ChunkServer上的副本。&lt;/p&gt;
&lt;h3&gt;3 Master设计&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;3.1名称空间和锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在逻辑上，GFS的名称空间是一个全路径和元数据映射关系的查找表(前缀压缩)。在存储名称空间的树型结构上，每个节点都有一个关联的读写锁。例如，一个操作设计/d1/d2/.../dn/leaf，那么操作首先获得目录/d1, /d1/d2, ..., /d1/d2/.../dn的读锁，以及/d1/d2/.../dn/leaf的读写锁。&lt;/p&gt;
&lt;p&gt;演示：/home/user被快照到/save/user，如何防止创建文件/home/user/foo&lt;/p&gt;
&lt;p&gt;1)快照操作获取/home和/save的读取锁，以及/home/user和/save/user的写入锁&lt;/p&gt;
&lt;p&gt;2）文件创建操作获取/home和/home/user的读取锁，以及/home/user/foo的写入锁&lt;/p&gt;
&lt;p&gt;两个操作要顺序执行，因为它们试图获取的/home/user的锁是相互冲突的。文件创建操作不需要获取父目录的写入锁，文件名的读取锁足以防止父目录被删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：支持同一目录的并行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;chunk副本位置选择的策略服务于两个目标：最大化数据可用性和可靠性，最大化网络带宽利用率。&lt;strong&gt;多个机架间分布存储chunk副本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;系统中需要创建chunk副本的三种情况：chunk创建，chunk复制以及负载均衡。&lt;/p&gt;
&lt;p&gt;当Master创建一个chunk，它会根据一下策略选择chunk副本的位置：1）用ChunkServer的磁盘利用率较低(比如低于平均水平)存储新的副本；2）限制每个ChunkServer“最近”创建的数量；3）每个chunk的所有副本不能在同一个机架上。关于第二点，如果不限制”最近“创建的数量，当一台空的ChunkServer上线时，由于磁盘利用率低，会造成大量的数据迁移。&lt;/p&gt;
&lt;p&gt;最后，Master会定期扫描当前的副本的分布情况，当出现磁盘使用量或负载不均衡时，将执行重新负载均衡操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3垃圾回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GFS采用延迟删除机制，即当删除文件后，GFS并不要求立即归还可用的物理存储，而是在元数据中将文件改为一个隐藏的名字，并且包含一个删除时间戳。Master定期检查，如果发现文件删除超过一定的时间(默认三天)，那么它会把文件从内存元数据中删除。之后，在ChunkServer和Master的心跳信息中，每一个ChunkServer都将报告自己的chunk集合，Master回复在元数据中已经不存在的chunk信息，进而ChunkServer释放chunk副本空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.4快照&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快照(Snapshot)操作是对源文件/目录进行一个”快照“操作，生成该时刻源文件/目录的一个瞬间状态存放在目标文件/目录中。GFS中使用标准的写时复制机制生成快照，即只是增加GFS中chunk的引用计数。对某个文件执行快照的大致如下：&lt;/p&gt;
&lt;p&gt;1）通过租约机制回收对文件的每个chunk的写权限，停止对文件的写服务；&lt;/p&gt;
&lt;p&gt;2）Master拷贝文件名等元数据生成一个新的文件快照；&lt;/p&gt;
&lt;p&gt;3）对执行快照的文件的所有chunk增加引用计数。&lt;/p&gt;
&lt;h3&gt;4 ChunkServer的设计&lt;/h3&gt;
&lt;p&gt;ChunkServer管理大小为64MB的chunk，存储的时候需要保证chunk尽可能均匀地分布在不同的磁盘中。&lt;/p&gt;
&lt;h3&gt;基本知识点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;chunk尺寸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GFS系统中chunk的大小是64MB。每个chunk的副本都以普通Linux文件的形式保存在CS服务器中。采用较大的chunk尺寸具有以下优点：1）可以减少客户端与主控服务器的请求次数。只需要一次与主控服务器的交互就可以获取chunk的位置信息，然后缓存到客户端，之后就可以对同一个chunk进行多次读写操作。2）因为客户端能够对一个chunk进行多次操作，客户端与数据块服务器保持较长时间的TCP连接，可以减少网络负载。3）一定程度上减少了主控服务器中需要保存的元数据的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;chunk位置信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主控服务器并不持久化保存数据块服务器中的chunk信息，而是在启动时轮询数据块服务器以获取这些信息，并且周期性地通过心跳信息监控数据块服务器的状态。这样做的目的是 &lt;strong&gt;在数据块服务器加入集群，离开集群，更名，失效，以及重启的时候，主控服务器可以保证与数据块服务器中chunk信息的一致性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主控服务器在日志增长到一定量时对系统状态做一次checkpoint，将所有的状态数据写入一个checkpoint文件。在灾难恢复的时候，主控服务器通过读取磁盘上的checkpoint文件，以及重演checkpoint之后的有限个日志文件就能够恢复系统。checkpoint文件以压缩B树的数据结构存储。&lt;/p&gt;</content><category term="Google"></category><category term="Distributed Systems"></category></entry><entry><title>深入理解Paxos算法</title><link href="www.subond.com/pages/2017/03/21/learn-paxos-in-distributed-system.html" rel="alternate"></link><published>2017-03-21T00:00:00+08:00</published><updated>2017-03-21T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-03-21:www.subond.com/pages/2017/03/21/learn-paxos-in-distributed-system.html</id><summary type="html">&lt;p&gt;Paxos算法是Leslie Lanmport(2013年获图灵奖)在1990年提出的一种基于消息传递的共识算法(也称为，一致性算法)，由于算法难以理解并没有被ACM TOCS发表。直到1998年，才引起人们的注意，Lanmport重新发表文章。为了便于人们通俗地理解Paxos算法，Lanmport于2001年简化原来的文章，发表了&lt;a href="http://on64c9tla.bkt.clouddn.com/2017A/paxos-simple-Copy.pdf"&gt;Paxos Made Simple&lt;/a&gt;，文章循序渐进地推导出了Paxos算法，并用数学归纳法进行了证明。在此基础上，本文结合Paxos Made Simple，与其他优秀的Paxos算法解读，重新描述Paxos协议，希望可以深入理解基本的Paxos算法理论。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.Paxos算法&lt;/h2&gt;
&lt;p&gt;Paxos算法是Leslie Lanmport(2013年获图灵奖)在1990年提出的一种基于消息传递的共识算法(也称为，一致性算法)，由于算法难以理解并没有被ACM TOCS发表。直到1998年，才引起人们的注意，Lanmport重新发表文章。为了便于人们通俗地理解Paxos算法，Lanmport于2001年简化原来的文章，发表了&lt;a href="http://on64c9tla.bkt.clouddn.com/2017A/paxos-simple-Copy.pdf"&gt;Paxos Made Simple&lt;/a&gt;，文章循序渐进地推导出了Paxos算法，并用数学归纳法进行了证明。在此基础上，本文结合Paxos Made Simple，与其他优秀的Paxos算法解读，重新描述Paxos协议，希望可以深入理解基本的Paxos算法理论。&lt;/p&gt;
&lt;p&gt;Paxos算法解决的问题是一个分布式系统中如何就某个值(或协议)达成一致。在一个分布式系统中，如果各节点的初始状态一致，每个节点都执行相同的操作，那么他们最后的得到的也是一个一致的状态。一个分布式系统中，通常包含一个主节点和多个备节点。为了保证每个节点执行相同的操作指令，需要每一条执行执行一个“一致性算法”来选举出主节点，进而保证每个节点得到的指令一致。这是一个分布式系统中的重要问题。&lt;/p&gt;
&lt;h2&gt;2.基本概念&lt;/h2&gt;
&lt;p&gt;Paxos算法中有三种角色：&lt;em&gt;Proposer&lt;/em&gt;, &lt;em&gt;Acceptor&lt;/em&gt;, &lt;em&gt;Learner&lt;/em&gt;。每个节点需要同时扮演 &lt;strong&gt;两种或两种以上的角色&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Proposal Value: 提议的值　　&lt;/li&gt;
&lt;li&gt;Proposal Number: 提议编号，并且要求提议编号不能冲突　　&lt;/li&gt;
&lt;li&gt;Proposal: 提议　=　提议编号 + 提议的值　　&lt;/li&gt;
&lt;li&gt;Proposer: 提议发起者　　&lt;/li&gt;
&lt;li&gt;Acceptors: 提议接受者　　&lt;/li&gt;
&lt;li&gt;Learners: 提议学习者　　&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，Proposer有两种行为，一个是向Acceptors发起Prepare请求，另一个是向Acceptors发起Accept请求。Acceptors则根据协议规则或(自身状态)对Proposers的请求做出应答。Learners根据Acceptors的状态，学习最终被确定的值。&lt;/p&gt;
&lt;h2&gt;3.两个原则&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1安全原则&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只能(而且必须)允许一个值被选定；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个节点只能学习已经被选定的值；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;2存活原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要多数节点存活，并且彼此可以通信，则会达成以下两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最终会选定某个提议的值　　&lt;/li&gt;
&lt;li&gt;一个被选定的值，其他节点最终会学习到这个值　　&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;4.算法过程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第一阶段A&lt;/strong&gt;，即Prepare阶段&lt;/p&gt;
&lt;p&gt;Proposer选择一个提议编号n，向所有的Acceptors发送(广播)Prepare(n)请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段B&lt;/strong&gt;，即Prepare阶段&lt;/p&gt;
&lt;p&gt;Acceptor接收到Prepare(n)请求后，若提议编号比之前接收的Prepare提议编号都要大，则做出如下承诺：即不会在接收比n小的提议，并携带之前Accept的提议中编号小于n的最大值的提议，否则不予理会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段A&lt;/strong&gt;，即Accept阶段&lt;/p&gt;
&lt;p&gt;Proposer接收到多数Acceptors的承诺后，如果没有一个Acceptor接受过这个值，则向所有的Acceptors的发起自己的值和提议编号，否则从接受过的值中选择对应的提议编号最大的那个值，作为提议的值，提议编号仍为n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段B&lt;/strong&gt;，即Accept阶段&lt;/p&gt;
&lt;p&gt;Acceptor接收到Accept请求后，如果该提议编号不违反自己的做过的承诺，则接受提议。&lt;/p&gt;
&lt;p&gt;&lt;img alt="paxos-protocolflow" src="http://on64c9tla.bkt.clouddn.com/2017A/paxos.png"&gt;&lt;/p&gt;
&lt;p&gt;需要说明是，Proposer发出Prepare请求后，得到多数派的应答，然后再选择一个多数派广播Accept请求，而不一定是将Accept请求发给有应答的Acceptor。这样做的原因是，Prepare阶段得到只是Proposal number 和 Proposal value，而一个值最终是否被选定，还需要Accept阶段的验证。&lt;/p&gt;
&lt;p&gt;当一个提议被多数接受后，这个提议的值就被选定choesn，一旦有一个值被选定，那么只有按协议的规则继续演进，后续被选定的值也是同一个值。这就是chosen的一致性问题。&lt;/p&gt;
&lt;h2&gt;5.算法证明&lt;/h2&gt;
&lt;p&gt;其实，Paxos算法是一个非常确定的数学问题，可以用数学语言表达，进而用严谨的数学逻辑进行证明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paxso算法原命题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个提议{n0,v0}被多数Acceptors所接受，那么不存在提议{n1,v1}被多数Acceptors接受，其中n0 &amp;lt; n1,v1 != v0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paxso算法原命题加强&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个提议{n0,v0}被多数Acceptors所接受，那么不存在Acceptors接受提议{n1,v1}，其中n0 &amp;lt; n1, v1 != v0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paxso算法原命题进一步加强&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个提议{n0,v0}被多数Acceptors所接受，那么不存在Proposer发出提议{n1,v1}，其中n0 &amp;lt; n1, v1 != v0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;归纳法证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设，提议{m, v}(简称m)被多数派接受，那么提议m到n(n &amp;gt;= m)，对应的值也是v。对n进行归纳假设。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;n = m时，显然结论成立。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设n = k时，结论成立，即如果提议(m, v)被多数派接受，则提议m到k对应的值为v。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当n = k + 1时，若提议k+1不存在，则结论成立。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，证明提议提议k+1不存问题。&lt;/p&gt;
&lt;p&gt;假设，提议k+1存在，对应的值为v1。因为提议m被多数派接受，又因为提议k+1的Prepare请求被承诺并返回结果。&lt;strong&gt;两个多数派必有交集&lt;/strong&gt;，那么提议k+1的第一阶段B必有提议带回来，那么v1就是从返回的提议中选择出来的，设v1对应的提议编号为t。根据第二阶段B可知，t是返回的提议编号最大的一个，因此t&amp;gt;=m。又因为第一阶段A，t&amp;lt;n。根据假设,t对应的值也是v，即v1 = v。所以，n=k成立时，n=k+1也成立。&lt;/p&gt;
&lt;h2&gt;6.示例演示&lt;/h2&gt;
&lt;p&gt;为了便于理解，记(n,v)为提议编号为n,提议的值为v的提议，(m,(n,v))为承诺了Prepare(m)请求，并接受了提议(n,v)。&lt;/p&gt;
&lt;p&gt;&lt;img alt="simple-paxos" src="http://on64c9tla.bkt.clouddn.com/2017A/simple-paxos.png"&gt;&lt;/p&gt;
&lt;h2&gt;7.小结&lt;/h2&gt;
&lt;p&gt;通过前面的讨论和学习，我们可以回顾一下协议的细节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为什么要被大多数接受？因为两个多数派必有交集，所以一般是奇数个(2n+1)Acceptors，然后允许最多n个Acceptors宕机，而保证算法仍然可以正常运行，最终得到一个确定的chosen值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么需要做一个承诺？首先，可以保证第二阶段A的Proposer的选择不受未来某个值的影响(因为对方已经给出了承诺)；其次，对于每一个Acceptors而言，承诺决定了它回应提议编号较大的Prepare请求，和接受提议编号较小的Accept请求的先后顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么第二阶段A要从返回的提议编号中选取最大的一个？这样选出来的提议编号一定不小于已经被多数派接受的提议编号，进而可以保证该提议编号对应的那个值是chosen的那个值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;"与其预测未来，不如限制未来"&lt;/strong&gt;,应该是Paxos协议的核心思想。——郑建军(微信工程师)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Leslie Lanmport:&lt;a href="http://on64c9tla.bkt.clouddn.com/2017A/paxos-simple-Copy.pdf"&gt;Paxos Made Simple&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Info架构师2017年1月刊:&lt;a href="http://www.infoq.com/cn/minibooks/architect-201701"&gt;微信PaxsoStore:深入浅出Paxos算法协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/zhengran/p/4212502.html"&gt;一步一步理解Paxos算法&lt;/a&gt;&lt;/p&gt;</content><category term="Algorithm"></category><category term="Distributed Systems"></category></entry><entry><title>读书写作那点事儿</title><link href="www.subond.com/pages/2017/02/21/reading_and_writing.html" rel="alternate"></link><published>2017-02-21T00:00:00+08:00</published><updated>2017-02-21T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2017-02-21:www.subond.com/pages/2017/02/21/reading_and_writing.html</id><summary type="html">&lt;p&gt;这是一篇关于读书写作的读书笔记，内容源自李笑来老师知乎Live的《我的读书经验》。&lt;/p&gt;</summary><content type="html">&lt;p&gt;这是一篇关于读书写作的读书笔记，内容源自李笑来老师知乎Live的《我的读书经验》。&lt;/p&gt;
&lt;h2&gt;关于读书路径&lt;/h2&gt;
&lt;p&gt;知识就是力量，从来都不是一句空话。获取知识的途径有很多，读书无疑是有效的方式之一。那么，有哪些较好的读书路径值得我们参考呢？笑来老师给出了以下几个方法：&lt;/p&gt;
&lt;p&gt;1) &lt;strong&gt;泛读，即广泛地阅读&lt;/strong&gt;。尤其是开始的时候，应尽得杂一点，漫无目的地读，慢慢地就会发现读书的乐趣，发现自己感兴趣的点，而后就可以着点而入，深入阅读。这是一个广散网，寻找点的过程。&lt;/p&gt;
&lt;p&gt;2) &lt;strong&gt;学会挑书，形成自己的书单&lt;/strong&gt;。总的来说，挑书应该有这样一个原则：能够帮助我们认清现实并思考未来，且具有 &lt;strong&gt;繁殖能力&lt;/strong&gt; 的书。能够帮组我们认清现实并有所思考的书多为非虚构类的书，这一类书可以往往能够就某一问题，或某一现象，甚至某个学科做较为深入的分析与探讨，是我们了解当下现实的基础，而书中关于这些问题的讨论有可以启发我们对未来的思考。具有繁殖能力的知识，往往是那些能够激发我们阅读欲望，探索问题解决之道；亦或与我们原有的知识形成冲突，或者形成补充的知识，这是一个不断发现其他点，形成星星之火的过程。&lt;/p&gt;
&lt;p&gt;3) &lt;strong&gt;建立检索书库，方便日后查询&lt;/strong&gt;。选择一款自己喜欢的笔记软件，不断地做好自己的阅读笔记。将阅读过程中发现的亮点和思考，以及相关的书目形成记录。如何做好阅读笔记，可以参考万维刚老师的&lt;a href="G01.md"&gt;什么是好的读书笔记&lt;/a&gt;。这是一个将点连接成线，进而形成一个面的过程。&lt;/p&gt;
&lt;p&gt;4) &lt;strong&gt;杂读，尽量涉及更多的领域和学科&lt;/strong&gt;。想要获得一些意外的收获，杂读就是一个很好的方法。用自己原有的专业知识及系统去接触一个相对陌生的领域和学科，往往可以碰撞出不一样的火花。这是一个发现其他面的过程，并产生面与面交集的过程。&lt;/p&gt;
&lt;h2&gt;读书的目的&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;读书，为了改变生活&lt;/strong&gt;。宋真宗赵恒在《励学篇》言道：安居不用架高楼，书中自有黄金屋；娶妻莫恨无良媒，书中自有颜如玉。虽说有些功利化，但读书就是可以改变我们的生活。这种改变往往并不是直接地改变我们一些什么，而是通过间接的方式。书，带给我们新的知识，新的思维，甚至新的思考方式；带给我们不曾认识或者不能正确认识的专业及领域，潜移默化地影响着我们的生活及工作，慢慢地某些东西就刻在了我们的骨子里，让我们终生受用。&lt;/p&gt;
&lt;h2&gt;升级阅读方法&lt;/h2&gt;
&lt;p&gt;通过前面的介绍，我们认识了读书路径，知道了读书的目的。那么，什么的阅读方法才算有效的阅读呢？关于这一点，以下原则值得参考：&lt;/p&gt;
&lt;p&gt;1) &lt;strong&gt;只字不差，反复阅读&lt;/strong&gt;。限于我们每个人不同的专业背景及知识阅历，也限于我们现有的水平，我们不太可能，甚至不可能了解所有的行业和学科，所以 &lt;strong&gt;一本书，只要必要，即便是读不懂，也要读完&lt;/strong&gt;。说不定哪一天，书中某个点就激发我们新的思考。&lt;/p&gt;
&lt;p&gt;2) &lt;strong&gt;翻看书评，以书会友&lt;/strong&gt;。莎士比亚曾言：There are a thousand Hamlets in a thousand people's eyes(一千个读者就有一千个哈姆雷特)。通过阅读他人关于一本书的思考，我们看到另一个角度的阐释。这份阐释也许跟我们自己的理解有所冲突，也许互为补充，也许高于我们的见识，也许低于我们的见识，这不正是读书的意义嘛。&lt;/p&gt;
&lt;p&gt;3) &lt;strong&gt;持续写作，有效输出&lt;/strong&gt;。写作，是提高阅读能力的有效工具。&lt;strong&gt;教，是最有效的学习&lt;/strong&gt;。当我们能够产生输出的时候，才算是内化到我们自己系统的东西。最初写作的时候，可能写得并不好，也没有那么完善，但是一定要保证它是完整的。之后，再通过不断地完善和补充，形成好的作品。另外，当我们写作的时候，才可以像作者一样阅读，明确自己的写作意图，梳理其中的逻辑关系，补充论据的支撑点。最后，还有更重要的一点：&lt;strong&gt;写作，目的只有一个——讲清楚一件事&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;关于现代阅读的&lt;/h3&gt;
&lt;p&gt;如何对待碎片化阅读？&lt;/p&gt;
&lt;p&gt;信息社会的发展，不断涌现的智能终端，几乎可以让我们随时随地地阅读；刷微博，刷微信，几乎也占据了我们大部分的闲暇时间，这样碎片化的信息对我们有多大意义呢？其实，意义不大。建议就是：&lt;strong&gt;形成固定的阅读时间&lt;/strong&gt;。在固定的时间里阅读，与书对话，充分享受思想的碰撞，知识的更新。&lt;/p&gt;
&lt;p&gt;读书带来的价值有多少？&lt;/p&gt;
&lt;p&gt;一个人的价值又有多大？李笑来给出这样一个公式：&lt;code&gt;一个人的价值＝有效集中注意力解决问题的时间×待解决问题被世界所需要的程度&lt;/code&gt;。其实，一本书的目的无非也是阐述一件事情而已。因此，我们可以大致用这样的一个公式来判断一本的价值：&lt;code&gt;一本书的价值＝有效解决问题的时间×对于待解决问题书中知识的重要程度&lt;/code&gt;。有效解决问题的时间可以理解成我们从书中获取有效知识或者方法，并进行有效应用的时间，所以查看阅读一些知识干货可以节省大量的时间，作为牺牲，我们也错失了从整体把握书的结构，系统，逻辑关系等等。书中知识的重要程度是指该类知识对于解决这类问题的有效程度。有这样一个事实我们不得不承认，那就是：&lt;strong&gt;对于某一特定的问题的解决方法不尽相同，所涉及的知识也不尽相同，那么找出其中至关重要的点，才是解决问题的根本。这些至关重要的点正是知识的重要程度&lt;/strong&gt;。一旦找到那个至关重要的点，问题也就迎刃而解了。&lt;/p&gt;
&lt;p&gt;那么，从工作实践的角度来讲，这种方法类似于采铜在《精进，如何成为一个很厉害的人》所讲的&lt;a href="G05.md"&gt;任务分解：让你的工作更高效&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;读书一定需要安静的地方吗？&lt;/p&gt;
&lt;p&gt;不是。阅读需要被锻炼的一个重要能力恰恰是：&lt;strong&gt;不被打扰的能力&lt;/strong&gt;。当处在嘈杂的环境时我们依然可以不被打扰的阅读，这样你就可以发现在火车上，在飞机上，在一切纷杂的地方依然可以保持自己的阅读。&lt;/p&gt;
&lt;p&gt;纸质书还是电子书？依据个人喜好，自行选择。&lt;/p&gt;
&lt;h2&gt;一点个人的分享&lt;/h2&gt;
&lt;p&gt;关于读书路径。&lt;strong&gt;可以适当地阅读自己感兴趣的书籍&lt;/strong&gt;。我第一次听到&lt;a href="http://baike.baidu.com/link?url=Rw3AuWewnKjf7ErRS6EHVrqjOn_HUVw5Y2u22jqxn4UOqnvIowi7hZhX_JSLpZkBhceAFGJpe0oULgLkmsCoFK-4u8dGwx7WysGjg9CX_URWjj5VUhVQjwyIU6FCkjFT"&gt;吴晓波&lt;/a&gt;的名字应该是在罗辑思维公众号，而恰巧自己对经济学也颇有兴趣。于是，利用寒假和开学的一段时间读完了吴晓波老师的《激荡三十年》，《历代经济变革得失》和《把生命浪费在美好的事物上》。其中的收获也很多，但是限于自己那个时候并没有良好的阅读写作习惯，没能及时梳理读书笔记，甚是遗憾，后续会整理出来。在我为数不多的阅读经历里，这算是一个有针对性的阅读体验，虽然跟自己本身的专业并不相关，但是读后的收获对一个人的帮助很大。去尝试那些跟自己不相关的领域，仅凭兴趣去阅读，就会发现不一样的世界。当你又一次类似的阅读体验时，你就会爱上它。真的。&lt;/p&gt;
&lt;p&gt;其次，&lt;strong&gt;适时地给自己一些随机性阅读&lt;/strong&gt;。2016年６月份，新世相(微信公众号：thefair2)发起了一场“新世相·图书馆”活动，其目的就是重拾阅读的乐趣。其活动规则是：一个月四本书，随机发送，读完并退回，退还押金。其中，给我印象最深的两本书是《股票大作手回忆录》和《黑客与画家》，让我深刻认识到原来钱还可以这么玩，黑客的精神一直都在。这次的随机阅读之旅也带来了意外的收获，有幸认识了一位优秀的博客作者&lt;a href="http://baike.baidu.com/link?url=PZ71FiEesaVkYuRGlUQwRqtQGhu0y6xqXI5LaXhuTXzpIR07c-Ho0qusoP0D_bxJ5SXbTLsFhSQK-UgNYquXh0M458T1jdz4qy3DPC185HODWbccJVE8PTqfYN9WBJSQ"&gt;池建强&lt;/a&gt;老师，并拜读了其所作的《MacTalk·人生元编程》和《MacTalk·跨越边界》，感受到技术与人文的魅力，也更加坚定了写作记录的想法。&lt;/p&gt;
&lt;p&gt;关于持续写作。从我最近的实践来看，写作确实可以很好地梳理文章的脉络，整理自己的思考。不过，初步写作也存在不少问题，主要集中在以下两点：&lt;em&gt;1) 用简洁的语言将一件事情说清楚并不是那么容易，能够准确地表达自己更不容易；2) 逻辑思维不够清晰&lt;/em&gt;。针对以上两点，我采取的策略是在读书的过程中多注意作者的语言组织及表述技巧，经常反复阅读自己的读书笔记，不断打磨。每一次读，你都会有不一样的发现。算是”复盘”自己的思路。&lt;/p&gt;</content><category term="life"></category><category term="reading"></category><category term="writing"></category></entry><entry><title>二十五六岁</title><link href="www.subond.com/pages/2016/12/15/the_middle_twenties.html" rel="alternate"></link><published>2016-12-15T00:00:00+08:00</published><updated>2016-12-15T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-12-15:www.subond.com/pages/2016/12/15/the_middle_twenties.html</id><summary type="html">&lt;p&gt;当一个人开始怀念少年时光的时候，他的少年时代就已经一去不复返了，此时此刻的他俨然成了一个有责任的青年人。&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;当一个人开始怀念少年时光的时候，他的少年时代就已经一去不复返了，此时此刻的他俨然成了一个有责任的青年人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面对未来，每个人都会或多或少地有些焦虑，尤其是年轻人。对未来既充满了幻想，也充满了渴望。未来，总是有无数的希望吸引着我们，去追逐，去靠近。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;焦虑是年轻人的普遍状态，有焦虑感的是很棒的，因为他们很清楚知道自己应该奔跑，只不过，暂时不知道自己应该选择哪一条跑到罢了。——吴慧超&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二十五六岁的我们，基本上刚刚告别学生时代，开始走上社会，像任何一个“刚上任”的新人一样，在一家公司，做着一些再普通不过的工作。总想获得更多，却又无力支付。&lt;strong&gt;欲望与贪婪太多，而自己无力支付&lt;/strong&gt;，这或许是最大的焦虑吧。&lt;/p&gt;
&lt;p&gt;作为一名农村出来的孩子，我出生在一个普通的家庭，没有任何背景可言，能够完整地接受高等教育，并进行一定程度地深造，已经非常幸运了。所以，在大学毕业的那一天，才忽然明白——&lt;strong&gt;从此，我的人生才算是完整的&lt;/strong&gt;。因为，并不是每个人都有机会能够接受教育，在这个美好的年纪。但是，也必须深刻认识到：&lt;strong&gt;在踏入社会的那一刻，“父母的庇护至此结束，未来的一切，都需要自己去挣”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在文章《一个人在二十五六岁时，该是什么状态》，作者吴慧超写一部分自己刚参加工作的经历，总结起来就是四个字：&lt;strong&gt;不负时光&lt;/strong&gt;。当我们回望自己过去的时候，如果觉得那些点点滴滴的进步与成长，正慢慢地让自己逐渐变得越来越独立，越自信，成为家人的依靠，成为一个肩负责任的人，那就叫不负时光。&lt;/p&gt;
&lt;p&gt;记得海明威有一句箴言：&lt;strong&gt;优于别人，并不高贵，真正的高贵是优于过去的自己&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="海明威1" src="http://on64c9tla.bkt.clouddn.com/Reads/Haimingwei.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="海明威2" src="http://on64c9tla.bkt.clouddn.com/Reads/Haimingwei2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;达尼·拉费里埃在《还乡之谜》中，写道：”前方总有太多的希望，身后总有太多的失望。生命是一条长长的带子，展开在延绵不断的时光中，展开在柔软的变幻迁移中，交替着希望与失望”。&lt;/p&gt;
&lt;p&gt;二十五六岁的年纪，就是撸起袖子加油干。写给自己，也写给每个为生活更美好而努力的人。&lt;/p&gt;</content><category term="life"></category><category term="work"></category><category term="essay"></category></entry><entry><title>初识Open Source MANO</title><link href="www.subond.com/pages/2016/12/03/introduction-about-osm.html" rel="alternate"></link><published>2016-12-03T00:00:00+08:00</published><updated>2016-12-03T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-12-03:www.subond.com/pages/2016/12/03/introduction-about-osm.html</id><summary type="html">&lt;p&gt;Open Source Management and Orchestration (MANO)，简称Open Source MANO,即OSM，是一个开源社区，旨在为NFV提供满足商用NFV网络需求的生产质量(production-quality)的MANO软件堆栈，具有创建商用公开发布信息的模型能力，适用于所有所有人，适用于所有的VNFs(虚拟网络功能)，而且更重要的是，小操作与VIM(Virtual Infrastructure Management,虚拟基础设施管理)无关。OSM与NFV ISG信息模型保持一致，同时能够根据其实施经验提供第一手的反馈。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.Open Source MANO&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://on64c9tla.bkt.clouddn.com/2016D/OSM-logo.png" align="left"&gt;Open Source Management and Orchestration (MANO)，简称Open Source MANO,即OSM，是一个开源社区，旨在为NFV提供满足商用NFV网络需求的生产质量(production-quality)的MANO软件堆栈，具有创建商用公开发布信息的模型能力，适用于所有所有人，适用于所有的VNFs(虚拟网络功能)，而且更重要的是，小操作与VIM(Virtual Infrastructure Management,虚拟基础设施管理)无关。OSM与NFV ISG信息模型保持一致，同时能够根据其实施经验提供第一手的反馈。&lt;/p&gt;
&lt;p&gt;MANO致力于“管理和编排”，是ETSI NFV定义的架构框架的功能模块的一部分。如图1-1所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="nfv-architecture" src="http://on64c9tla.bkt.clouddn.com/2016D/etsi_nfv_architecture.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;图1-1 ETSI NFV系统架构&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;如前所述，ETSI NFV架构框架的两个关键组件就是NFV Orchestrator和VNF Manager,称为NFV MANO。另外，对于管理人员来说，还需要其他层(比如服务编排)，才能够启动真正的NFV服务。开源软件可以促进ETSI对NFV架构的实现，向ETSI ISG NFV提供实用和基本的反馈，并增加NFV实现之间的互操作性和可能性。&lt;/p&gt;
&lt;p&gt;OSM Release ONE已经经过设计、测试和记录，可以实现快速安装，并创建一个可扩展和互操作的开放MANO环境。它极大地增强了与其他组件(VNFs,VIMs,SDN控制器)的互操作性，可以创建一个(plug-in)框架来进行平台维护和扩展，使得技术的提供和支持更加容易。此外，Release ONE提高了管理员和开发人员的在可用性和安装过程中体验，以及增强了NFV和网络服务的建模能力。为了符合OSI开源工程的目标，这种建模输出工作将会贡献到ETSI NFV中。Release ONE也提供了极其灵活的虚拟化网络功能(VNF)配置和高级网络管理，以及改进的故障排除功能和高级日志记录。白皮书中概括了OSM的主要框架，开发的新功能以及Release ONE部分开放内容。&lt;/p&gt;
&lt;p&gt;Open Source MANO白皮书地址&lt;a href="https://osm.etsi.org/images/OSM-Whitepaper-TechContent-ReleaseONE-FINAL.pdf"&gt;OSM-Whitepaper-TechContent-ReleaseONE-FINAL.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;安装OSM&lt;/h2&gt;
&lt;h3&gt;1.前期准备/系统要求&lt;/h3&gt;
&lt;p&gt;1) 8 CPUs, 16G RAM, 100GB硬盘以及可用的网络接口；&lt;br&gt;
2) Ubuntu 16.04系统，并配置LXD容器  &lt;/p&gt;
&lt;p&gt;LXD配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt update
sudo apt install zfs lxd
sudo newgrp lxd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来进行lxc初始化设置，使用命令&lt;code&gt;sudo lxd init&lt;/code&gt;,并进行如下设置：&lt;/p&gt;
&lt;p&gt;&lt;img alt="lxd_install" src="http://on64c9tla.bkt.clouddn.com/2016D/lxd_install.png"&gt;&lt;/p&gt;
&lt;p&gt;成功后，会出现以下信息。&lt;/p&gt;
&lt;p&gt;&lt;img alt="lxd_success" src="http://on64c9tla.bkt.clouddn.com/2016D/lxd_successfully.png"&gt;&lt;/p&gt;
&lt;h3&gt;2.从源安装OSM&lt;/h3&gt;
&lt;p&gt;安装之前，系统需要安装版本控制管理工具git，sudo apt install -y git；接下来，获取安装脚本，进行安装即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget https://osm-download.etsi.org/ftp/osm-1.0-one/install_from_source.sh
chmod +x install_from_source.sh
./install_from_source.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装过程中，需要进行LXD的相关配置，比较简单，可自行设置。我的部分设置如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="step3" src="http://on64c9tla.bkt.clouddn.com/2016D/step3.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step4" src="http://on64c9tla.bkt.clouddn.com/2016D/step4.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step5" src="http://on64c9tla.bkt.clouddn.com/2016D/step5.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step6" src="http://on64c9tla.bkt.clouddn.com/2016D/step6.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step7" src="http://on64c9tla.bkt.clouddn.com/2016D/step7.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step8" src="http://on64c9tla.bkt.clouddn.com/2016D/step8.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="step9" src="http://on64c9tla.bkt.clouddn.com/2016D/step9.png"&gt;&lt;/p&gt;
&lt;p&gt;安装成功后，会出现如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt="osm-success" src="http://on64c9tla.bkt.clouddn.com/2016D/lxd_successfully.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://osm.etsi.org/wikipub/index.php/LXD_configuration_for_OSM_release_1"&gt;LXD configuration for OSM release 1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://osm.etsi.org/wikipub/index.php/OSM_Release_ONE"&gt;OSM Release ONE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="OSM架构框图" src="http://on64c9tla.bkt.clouddn.com/2016D/OSMconnectivity1.png"&gt;&lt;/p&gt;</content><category term="NFV"></category><category term="Orchestration"></category><category term="juju"></category></entry><entry><title>读书写作那点事儿</title><link href="www.subond.com/pages/2016/11/15/something-about-reading-and-writing.html" rel="alternate"></link><published>2016-11-15T00:00:00+08:00</published><updated>2016-11-15T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-11-15:www.subond.com/pages/2016/11/15/something-about-reading-and-writing.html</id><summary type="html">&lt;p&gt;知识就是力量，从来都不是一句空话。获取知识的途径有很多，读书无疑是有效的方式之一。那么，有哪些较好的读书路径值得我们参考呢？李笑来老师给出了以下几个方法：1) &lt;strong&gt;泛读，即广泛地阅读&lt;/strong&gt;。尤其是开始的时候，应尽得杂一点，漫无目的地读，慢慢地就会发现读书的乐趣，发现自己感兴趣的点，而后就可以着点而入，深入阅读。这是一个广散网，寻找点的过程。2) &lt;strong&gt;学会挑书，形成自己的书单&lt;/strong&gt;。总的来说，挑书应该有这样一个原则：能够帮助我们认清现实并思考未来，且具有 &lt;strong&gt;繁殖能力&lt;/strong&gt; 的书。能够帮组我们认清现实并有所思考的书多为非虚构类的书，这一类书可以往往能够就某一问题，或某一现象，甚至某个学科做较为深入的分析与探讨，是我们了解当下现实的基础，而书中关于这些问题的讨论有可以启发我们对未来的思考。具有繁殖能力的知识，往往是那些能够激发我们阅读欲望，探索问题解决之道；亦或与我们原有的知识形成冲突，或者形成补充的知识，这是一个不断发现其他点，形成星星之火的过程。3) &lt;strong&gt;建立检索书库，方便日后查询&lt;/strong&gt;。选择一款自己喜欢的笔记软件，不断地做好自己的阅读笔记。将阅读过程中发现的亮点和思考，以及相关的书目形成记录。如何做好阅读笔记，这是一个将点连接成线，进而形成一个面的过程。4) &lt;strong&gt;杂读，尽量涉及更多的领域和学科&lt;/strong&gt;。想要获得一些意外的收获，杂读就是一个很好的方法。用自己原有的专业知识及系统去接触一个相对陌生的领域和学科，往往可以碰撞出不一样的火花。这是一个发现其他面的过程，并产生面与面交集的过程。&lt;/p&gt;</summary><content type="html">&lt;p&gt;这是一篇关于读书写作的读书笔记，内容源自李笑来老师知乎Live的《我的读书经验》。&lt;/p&gt;
&lt;h3&gt;关于读书路径&lt;/h3&gt;
&lt;p&gt;知识就是力量，从来都不是一句空话。获取知识的途径有很多，读书无疑是有效的方式之一。那么，有哪些较好的读书路径值得我们参考呢？李笑来老师给出了以下几个方法：&lt;/p&gt;
&lt;p&gt;1) &lt;strong&gt;泛读，即广泛地阅读&lt;/strong&gt;。尤其是开始的时候，应尽得杂一点，漫无目的地读，慢慢地就会发现读书的乐趣，发现自己感兴趣的点，而后就可以着点而入，深入阅读。这是一个广散网，寻找点的过程。&lt;/p&gt;
&lt;p&gt;2) &lt;strong&gt;学会挑书，形成自己的书单&lt;/strong&gt;。总的来说，挑书应该有这样一个原则：能够帮助我们认清现实并思考未来，且具有 &lt;strong&gt;繁殖能力&lt;/strong&gt; 的书。能够帮组我们认清现实并有所思考的书多为非虚构类的书，这一类书可以往往能够就某一问题，或某一现象，甚至某个学科做较为深入的分析与探讨，是我们了解当下现实的基础，而书中关于这些问题的讨论有可以启发我们对未来的思考。具有繁殖能力的知识，往往是那些能够激发我们阅读欲望，探索问题解决之道；亦或与我们原有的知识形成冲突，或者形成补充的知识，这是一个不断发现其他点，形成星星之火的过程。&lt;/p&gt;
&lt;p&gt;3) &lt;strong&gt;建立检索书库，方便日后查询&lt;/strong&gt;。选择一款自己喜欢的笔记软件，不断地做好自己的阅读笔记。将阅读过程中发现的亮点和思考，以及相关的书目形成记录。如何做好阅读笔记，这是一个将点连接成线，进而形成一个面的过程。&lt;/p&gt;
&lt;p&gt;4) &lt;strong&gt;杂读，尽量涉及更多的领域和学科&lt;/strong&gt;。想要获得一些意外的收获，杂读就是一个很好的方法。用自己原有的专业知识及系统去接触一个相对陌生的领域和学科，往往可以碰撞出不一样的火花。这是一个发现其他面的过程，并产生面与面交集的过程。&lt;/p&gt;
&lt;h3&gt;读书的目的&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;读书，为了改变生活&lt;/strong&gt;。宋真宗赵恒在《励学篇》言道：安居不用架高楼，书中自有黄金屋；娶妻莫恨无良媒，书中自有颜如玉。虽说有些功利化，但读书就是可以改变我们的生活。这种改变往往并不是直接地改变我们一些什么，而是通过间接的方式。书，带给我们新的知识，新的思维，甚至新的思考方式；带给我们不曾认识或者不能正确认识的专业及领域，潜移默化地影响着我们的生活及工作，慢慢地某些东西就刻在了我们的骨子里，让我们终生受用。&lt;/p&gt;
&lt;h3&gt;升级阅读方法&lt;/h3&gt;
&lt;p&gt;通过前面的介绍，我们认识了读书路径，知道了读书的目的。那么，什么的阅读方法才算有效的阅读呢？关于这一点，以下原则值得参考：&lt;/p&gt;
&lt;p&gt;1) &lt;strong&gt;只字不差，反复阅读&lt;/strong&gt;。限于我们每个人不同的专业背景及知识阅历，也限于我们现有的水平，我们不太可能，甚至不可能了解所有的行业和学科，所以 &lt;strong&gt;一本书，只要必要，即便是读不懂，也要读完&lt;/strong&gt;。说不定哪一天，书中某个点就激发我们新的思考。&lt;/p&gt;
&lt;p&gt;2) &lt;strong&gt;翻看书评，以书会友&lt;/strong&gt;。莎士比亚曾言：There are a thousand Hamlets in a thousand people's eyes(一千个读者就有一千个哈姆雷特)。通过阅读他人关于一本书的思考，我们看到另一个角度的阐释。这份阐释也许跟我们自己的理解有所冲突，也许互为补充，也许高于我们的见识，也许低于我们的见识，这不正是读书的意义嘛。&lt;/p&gt;
&lt;p&gt;3) &lt;strong&gt;持续写作，有效输出&lt;/strong&gt;。写作，是提高阅读能力的有效工具。&lt;strong&gt;教，是最有效的学习&lt;/strong&gt;。当我们能够产生输出的时候，才算是内化到我们自己系统的东西。最初写作的时候，可能写得并不好，也没有那么完善，但是一定要保证它是完整的。之后，再通过不断地完善和补充，形成好的作品。另外，当我们写作的时候，才可以像作者一样阅读，明确自己的写作意图，梳理其中的逻辑关系，补充论据的支撑点。最后，还有更重要的一点：&lt;strong&gt;写作，目的只有一个——讲清楚一件事&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;关于现代阅读的&lt;/h3&gt;
&lt;p&gt;如何对待碎片化阅读？&lt;/p&gt;
&lt;p&gt;信息社会的发展，不断涌现的智能终端，几乎可以让我们随时随地地阅读；刷微博，刷微信，几乎也占据了我们大部分的闲暇时间，这样碎片化的信息对我们有多大意义呢？其实，意义不大。建议就是：&lt;strong&gt;形成固定的阅读时间&lt;/strong&gt;。在固定的时间里阅读，与书对话，充分享受思想的碰撞，知识的更新。&lt;/p&gt;
&lt;p&gt;读书带来的价值有多少？&lt;/p&gt;
&lt;p&gt;一个人的价值又有多大？李笑来给出这样一个公式：&lt;code&gt;一个人的价值＝有效集中注意力解决问题的时间×待解决问题被世界所需要的程度&lt;/code&gt;。其实，一本书的目的无非也是阐述一件事情而已。因此，我们可以大致用这样的一个公式来判断一本的价值：&lt;code&gt;一本书的价值＝有效解决问题的时间×对于待解决问题书中知识的重要程度&lt;/code&gt;。有效解决问题的时间可以理解成我们从书中获取有效知识或者方法，并进行有效应用的时间，所以查看阅读一些知识干货可以节省大量的时间，作为牺牲，我们也错失了从整体把握书的结构，系统，逻辑关系等等。书中知识的重要程度是指该类知识对于解决这类问题的有效程度。有这样一个事实我们不得不承认，那就是：&lt;strong&gt;对于某一特定的问题的解决方法不尽相同，所涉及的知识也不尽相同，那么找出其中至关重要的点，才是解决问题的根本。这些至关重要的点正是知识的重要程度&lt;/strong&gt;。一旦找到那个至关重要的点，问题也就迎刃而解了。&lt;/p&gt;
&lt;p&gt;那么，从工作实践的角度来讲，这种方法类似于采铜在《精进，如何成为一个很厉害的人》所讲的&lt;a href="G05.md"&gt;任务分解：让你的工作更高效&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;读书一定需要安静的地方吗？&lt;/p&gt;
&lt;p&gt;不是。阅读需要被锻炼的一个重要能力恰恰是：&lt;strong&gt;不被打扰的能力&lt;/strong&gt;。当处在嘈杂的环境时我们依然可以不被打扰的阅读，这样你就可以发现在火车上，在飞机上，在一切纷杂的地方依然可以保持自己的阅读。&lt;/p&gt;
&lt;p&gt;纸质书还是电子书？依据个人喜好，自行选择。&lt;/p&gt;
&lt;h3&gt;一点个人的分享&lt;/h3&gt;
&lt;p&gt;关于读书路径。&lt;strong&gt;可以适当地阅读自己感兴趣的书籍&lt;/strong&gt;。我第一次听到&lt;a href="http://baike.baidu.com/link?url=Rw3AuWewnKjf7ErRS6EHVrqjOn_HUVw5Y2u22jqxn4UOqnvIowi7hZhX_JSLpZkBhceAFGJpe0oULgLkmsCoFK-4u8dGwx7WysGjg9CX_URWjj5VUhVQjwyIU6FCkjFT"&gt;吴晓波&lt;/a&gt;的名字应该是在罗辑思维公众号，而恰巧自己对经济学也颇有兴趣。于是，利用寒假和开学的一段时间读完了吴晓波老师的《激荡三十年》，《历代经济变革得失》和《把生命浪费在美好的事物上》。其中的收获也很多，但是限于自己那个时候并没有良好的阅读写作习惯，没能及时梳理读书笔记，甚是遗憾，后续会整理出来。在我为数不多的阅读经历里，这算是一个有针对性的阅读体验，虽然跟自己本身的专业并不相关，但是读后的收获对一个人的帮助很大。去尝试那些跟自己不相关的领域，仅凭兴趣去阅读，就会发现不一样的世界。当你又一次类似的阅读体验时，你就会爱上它。真的。&lt;/p&gt;
&lt;p&gt;其次，&lt;strong&gt;适时地给自己一些随机性阅读&lt;/strong&gt;。2016年６月份，新世相(微信公众号：thefair2)发起了一场“新世相·图书馆”活动，其目的就是重拾阅读的乐趣。其活动规则是：一个月四本书，随机发送，读完并退回，退还押金。其中，给我印象最深的两本书是《股票大作手回忆录》和《黑客与画家》，让我深刻认识到原来钱还可以这么玩，黑客的精神一直都在。这次的随机阅读之旅也带来了意外的收获，有幸认识了一位优秀的博客作者&lt;a href="http://baike.baidu.com/link?url=PZ71FiEesaVkYuRGlUQwRqtQGhu0y6xqXI5LaXhuTXzpIR07c-Ho0qusoP0D_bxJ5SXbTLsFhSQK-UgNYquXh0M458T1jdz4qy3DPC185HODWbccJVE8PTqfYN9WBJSQ"&gt;池建强&lt;/a&gt;老师，并拜读了其所作的《MacTalk·人生元编程》和《MacTalk·跨越边界》，感受到技术与人文的魅力，也更加坚定了写作记录的想法。&lt;/p&gt;
&lt;p&gt;关于持续写作。从我最近的实践来看，写作确实可以很好地梳理文章的脉络，整理自己的思考。不过，初步写作也存在不少问题，主要集中在以下两点：&lt;em&gt;1) 用简洁的语言将一件事情说清楚并不是那么容易，能够准确地表达自己更不容易；2) 逻辑思维不够清晰&lt;/em&gt;。针对以上两点，我采取的策略是在读书的过程中多注意作者的语言组织及表述技巧，经常反复阅读自己的读书笔记，不断打磨。每一次读，你都会有不一样的发现&lt;/p&gt;
&lt;p&gt;一点的个人分享，从读书路径的角度来说，也只能说是入门而已，还有很长的路要走。&lt;/p&gt;</content><category term="Life"></category><category term="Writing"></category><category term="Reading"></category></entry><entry><title>云端服务管理工具:Juju</title><link href="www.subond.com/pages/2016/11/10/juju-charm-mechanism.html" rel="alternate"></link><published>2016-11-10T00:00:00+08:00</published><updated>2016-11-10T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-11-10:www.subond.com/pages/2016/11/10/juju-charm-mechanism.html</id><summary type="html">&lt;p&gt;Juju是Canonical公司提供的服务编排工具。它是Ubuntu云套件的一部分，与Ubuntu服务器、OpenStack、用于裸机配置的MAAS 、以及用于系统管理和监控的Landscape一起组成Ubuntu云套件。同时，Juju也是 开源的，向用户提供一种面向服务的架构(service oriented architecture)和面向应用的部署(application oriented deployments)的通用模型。Juju可以对云端的服务进行快速可靠的部署，包括拓展云端业务，因此管理员可以很容易地部署Wordpress博客系统，MongoDB大系统管理系统、Mysql数据系统等。目前Juju具有1.25(稳定版)和2.0(升级版)，用户可以自行选择。关于Juju的安装比较简单， 可以参考官网教程。Juju为用户提供了命令行和图形化界面两种方式来进行业务部署，其图形化界面称为"juju-gui"(可利用juju部署到本地系统,juju deploy juju-gui)。&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1.Juju介绍&lt;/h3&gt;
&lt;p&gt;Juju是Canonical公司提供的服务编排工具。它是Ubuntu云套件的一部分，与Ubuntu服务器、OpenStack、用于裸机配置的MAAS 、以及用于系统管理和监控的Landscape一起组成Ubuntu云套件。同时，Juju也是 开源的，向用户提供一种面向服务的架构(service oriented architecture)和面向应用的部署(application oriented deployments)的通用模型。Juju可以对云端的服务进行快速可靠的部署，包括拓展云端业务，因此管理员可以很容易地部署Wordpress博客系统，MongoDB大系统管理系统、Mysql数据系统等。目前Juju具有1.25(稳定版)和2.0(升级版)，用户可以自行选择。关于Juju的安装比较简单， 可以参考官网教程&lt;/p&gt;
&lt;p&gt;Juju为用户提供了命令行和图形化界面两种方式来进行业务部署，其图形化界面称为"juju-gui"(可利用juju部署到本地系统,juju deploy juju-gui)。&lt;/p&gt;
&lt;h3&gt;2.Juju的运作方式&lt;/h3&gt;
&lt;p&gt;Juju进行运作要具备以下三个因素：
1) &lt;strong&gt;Juju Client&lt;/strong&gt;
Juju Client端在不同的平台都有(Ubuntu/OXS/Windows)，以Ubuntu为例，Juju Client套件名为juju-core。
2) &lt;strong&gt;Ubuntu Image环境(也成为Ubuntu Server,可根据需求设定)&lt;/strong&gt;
一般的公有云都可以提供这样的环境，例如OpenStack,Amazon EC2,Microsoft Azure。当然，也可以搭配Ubuntu MAAS环境进行搭建。
3) &lt;strong&gt;SSH key pair&lt;/strong&gt;
SSH key pair是用来控制Ubuntu Server，可利用一对SSH key pair登入至Ubuntu Server环境，并进行Service Orchestration操作。&lt;/p&gt;
&lt;h3&gt;3.Juju本地环境配置&lt;/h3&gt;
&lt;p&gt;Juju是为云端服务提供管理工具，但是作为初学者我们更多是使用自己的本地环境来学习Juju的相关操作和Charm的编写。下面介绍如何搭建自己的Juju本地环境，以kvm虚拟机为例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装Juju&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-add-repository ppa:juju/stable
sudo apt-get update &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo apt-get -y install juju-core
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;安装本地支持文件以及KVM/libvrt软件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install juju-local qemu-kvm libvirt-bin bridge-utils virt-manager qemu-system uvtool-libvirt uvtool
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;生成配置文件：其路径为:~/.juju/environment.yaml&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju generate-config
juju switch kvm
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;修改配置：在environment.yaml中找到local，进行如下修改：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;local:
      type: &lt;span class="nb"&gt;local&lt;/span&gt;
  kvm:
      type: &lt;span class="nb"&gt;local&lt;/span&gt;
      container: kvm
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;执行，&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju bootstrap
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即可生成本地环境。可使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju status --format tabular
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看状态信息。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="juju_status" src="http://on64c9tla.bkt.clouddn.com/20161110juju_status.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于Juju环境的其他操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="c1"&gt;# 查看环境列表&lt;/span&gt;
  juju env --list
  juju env  // 可查看当前环境名称
  &lt;span class="c1"&gt;# 销毁环境&lt;/span&gt;
  juju destory-environment &lt;span class="o"&gt;[&lt;/span&gt;env_name&lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="c1"&gt;# 设定environment中的VM版本&lt;/span&gt;
  juju set-env &lt;span class="s2"&gt;&amp;quot;default-series=trusty&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设定bootstrap环境&lt;/p&gt;
&lt;p&gt;juju bootstrap用来生成可运行charm的juju环境，可利用-e指定环境名称，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju bootstrap -e my_env
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来，简单说明juju client/juju bootstrap node/cloud provider三者之间的关系。&lt;/p&gt;
&lt;p&gt;1) juju client通过bootstrap指令，在cloud provider上产生一个可用来部署juju charms的bootstrap实例，即juju环境。&lt;/p&gt;
&lt;p&gt;2) juju client通过juju deploy指令，在bootstrap实例上安装指定的charms到cloud provider的VM中。&lt;/p&gt;
&lt;p&gt;3) cloud provider中，既有bootstrap实例，也有charms的实例。&lt;/p&gt;
&lt;p&gt;因此，三者的交互过程具有如下关系：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;juju client &amp;lt; ---- &amp;gt; juju bootstrap instance &amp;lt; ---- &amp;gt; cloud provider&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4.Juju服务编排&lt;/h3&gt;
&lt;p&gt;Juju利用部署服务(Deploy Services)的方式进行服务编排(Service Orchestration)。接下来，说明如何利用juju进行服务部署工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) 利用charm Store进行部署&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 利用charm store部署服务，以mysql为例&lt;/span&gt;
juju deploy mysql
&lt;span class="c1"&gt;# 指定serveice版本,格式为:/&lt;/span&gt;
juju deploy cs:precise/mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2) 利用本地charm(Local Charm Repository)部署&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# repository 指定本地charm路径，如/usr/mycharms&lt;/span&gt;
&lt;span class="c1"&gt;# repository name: local&lt;/span&gt;
&lt;span class="c1"&gt;# series: trusty&lt;/span&gt;
&lt;span class="c1"&gt;# service: mysql&lt;/span&gt;
juju deploy --repository&lt;span class="o"&gt;=&lt;/span&gt;/usr/mycharms local:trusty/mysql

&lt;span class="c1"&gt;# 如果预设juju repository的路径&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;JUJU_REPOSITORY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/mycharms/
juju deploy local:trusty/mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3) 利用配置文件进行多个service设定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Juju的配置文件以YAML格式进行撰写，可以在预先设定的配置文件中将charm的相关设定写好，再利用指定配置文件的方式，完成service的部署，从而避免部署指令过长。
例如，部署一个名称mywiki的服务，可预先进行如下设定(myconfig.yaml):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mywiki:
  name: jujuwiki
  skin: monobook
  admin: amdin:admin
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，使用如下指令进行部署：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju deploy --config myconfig.yaml mywiki
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3) 利用constraints个性化部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Juju指令中使用--constraints可在service部署时指定特定的VM规格(cpu, mem, etc)架构。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju deploy --constraints &lt;span class="s2"&gt;&amp;quot;cpu-cores=2 mem=4G&amp;quot;&lt;/span&gt; mysql
juju bootstrap --constraints &lt;span class="s2"&gt;&amp;quot;cpu-power=0 mem=512M&amp;quot;&lt;/span&gt;
juju bootstrap --constraints &lt;span class="s2"&gt;&amp;quot;arch=amd64&amp;quot;&lt;/span&gt;
juju set-constraints --service mysql &lt;span class="nv"&gt;mem&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2G cpu-cores&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;
&lt;span class="c1"&gt;# 获取constraints内容&lt;/span&gt;
juju get-constraints
juju get-constraints mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:每个由juju管理的node(无论实体，还是容器(container))都被视为unit。Unit之间的数据交互，可使用juju相关命令，常用的指令由如下几种：&lt;/p&gt;
&lt;p&gt;登录至某个特定的unit，可使用&lt;code&gt;juju ssh&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 通过unit id或者machine id进行登入&lt;/span&gt;
juju ssh mysql/2
&lt;span class="c1"&gt;# 直接查询某些信息或者执行某些脚本&lt;/span&gt;
juju ssh mysql/2 ifconfig
juju ssh mysql/2 bash /tmp/echo_ip.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件拷贝，可使用&lt;code&gt;juju scp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;juju scp&lt;/code&gt;可以将文件从service宿主的machine或者container中拷贝出来，也可以拷贝进去。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# juju scp中可使用service id，也可以使用machine id&lt;/span&gt;
&lt;span class="c1"&gt;# 将iptables.sh放到mysql服务中的/tmp路径下&lt;/span&gt;
juju scp iptables.sh mysql/2:/tmp
&lt;span class="c1"&gt;# 将mysql服务中的log拷贝至本机&lt;/span&gt;
juju scp -r mysql/2:/var/log/mysql/ mysql_log/
&lt;span class="c1"&gt;# 拷贝两个service中的文件，使用-v&lt;/span&gt;
juju scp -v ubuntu/0:/path/file1 ubuntu/1:/path/file2 backup/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行shell命令，可使用&lt;code&gt;juju run&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;juju run&lt;/code&gt;是以ssh的方式登入至service宿主中执行shell命令，但两者又有不同之处：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;juju run&lt;/strong&gt;:可以同时操控多台机器，可以通过指定machine/service/unit的方式指定机器，也可以使用--all参数指定所有机器或者container进行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;juju ssh&lt;/strong&gt;:可以通过指定machine/service的方式进行操作，但一次只能操作一台机器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 获取所有machine的kernel version&lt;/span&gt;
juju run &lt;span class="s2"&gt;&amp;quot;uname -a&amp;quot;&lt;/span&gt; --all
&lt;span class="c1"&gt;# 指定特定machine or service&lt;/span&gt;
juju run &lt;span class="s2"&gt;&amp;quot;uname -a&amp;quot;&lt;/span&gt; --machine&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;
juju run &lt;span class="s2"&gt;&amp;quot;uname -a&amp;quot;&lt;/span&gt; --service&lt;span class="o"&gt;=&lt;/span&gt;mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;5.Juju Charm的使用&lt;/h3&gt;
&lt;p&gt;Charm是Juju在部署服务/业务时所使用的工具，由一系列的脚本文件组成，用于部署服务单元以及建立服务单元之间的联系。对于用户而言，Charm是开源的，好多优秀的Charm都放在Charm Store上，一个 简单的命令&lt;code&gt;juju deploy mysql&lt;/code&gt;，就可以部署一个简单的数据库服务单元。当然，若是某些Charm不能够满足用户的特殊需求，用户也可以写自己的charm，写好后还可以放到charm Store供别人下载使用。&lt;/p&gt;
&lt;p&gt;Charm是事件驱动(event-driven)型脚本，通过读取/解析juju命令实现服务单元的建立，删除，关系建立等。一个完整的charm文件，包括文件：元数据(metadata.yaml),配置数据(config.yaml)以及与hooks相关的支持文件，如下图所示。&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;&lt;img src="http://on64c9tla.bkt.clouddn.com/20161110charm_tree.png" algin="left"&gt;&lt;/td&gt;
    &lt;td&gt;
      &lt;ul&gt;
        &lt;li&gt;/hooks&lt;/li&gt;
        &lt;p&gt;hooks是一个目录，里面包含可执行文件(脚本)，一般具有特定的名字(与metadata.yaml文件相关，后续介绍)。&lt;/p&gt;
        &lt;li&gt;/actions&lt;/li&gt;
        &lt;p&gt;actions是一个目录，里面包含可执行文件(脚本)，一般具有特定的名字(与juju系统调用相关)。&lt;/p&gt;
        &lt;li&gt;actions.yaml&lt;/li&gt;
        &lt;p&gt;actions.yaml是一个配置文件，当使用目录actions中的脚本时，需要配置actions.yaml文件。&lt;/p&gt;
        &lt;li&gt;config.yaml&lt;/li&gt;
        &lt;p&gt;config.yaml是一个配置文件，与服务配置相关(service/unit)。&lt;/p&gt;
        &lt;li&gt;icon.svg&lt;/li&gt;
        &lt;p&gt;icon.svg是GUI界面中用来识别charm的文件。&lt;/p&gt;
        &lt;li&gt;README&lt;/li&gt;
        &lt;p&gt;README文件主要介绍charm的主要功能，操作，用例等等。&lt;/p&gt;
      &lt;/ul&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;6.Charm之间的关联性&lt;/h3&gt;
&lt;p&gt;每个利用charm部署之后就是一个服务，而服务几乎没有独立运行的，需要不同服务之间的相互协作，建立联系。因此，charm之间的关联性尤为重要。&lt;/p&gt;
&lt;p&gt;juju使用juju add-relation建立服务之间的联系。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju add-relation mysql epc-hss
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至于，为何两个服务之间为何可以添加连接或者不可以添加连接，其实在charm中有所规定，详情可以参见下面的 &lt;em&gt;Charm文件详解&lt;/em&gt;。&lt;/p&gt;
&lt;h3&gt;7.Charm文件详解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;metadata.yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;metadata.yaml中定义了许多charm本身的元信息，位于charm的根目录，必须是有效的yaml文件，且至少要包含以下信息：&lt;/p&gt;
&lt;p&gt;&lt;font color="#ff000000"&gt;name&lt;/font&gt;:即charm的名字，用来标识一个特定的charm,方便从charm store中下载。name的命名只接受'a-z','0-9'以及'-',必须以'a-z'开头，不能以'-'结尾。&lt;/p&gt;
&lt;p&gt;&lt;font color="#ff000000"&gt;summary&lt;/font&gt;:即概要，用一句话描述自己的charm功能。&lt;/p&gt;
&lt;p&gt;&lt;font color="#ff000000"&gt;description&lt;/font&gt;:用来描述charm的功能，特性等，可在Juju GUI中显示。&lt;/p&gt;
&lt;p&gt;&lt;font color="#ff000000"&gt;tags&lt;/font&gt;:charm的标签，方便在charm store中搜索。&lt;/p&gt;
&lt;p&gt;&lt;img alt="metadata_yaml" src="http://on64c9tla.bkt.clouddn.com/20161110metadata_yaml.png"&gt;&lt;/p&gt;
&lt;h3&gt;8.常用功能&lt;/h3&gt;
&lt;p&gt;Juju具有服务扩展(Scaling Service)功能，尤其是在云端环境中，显得更加重要。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;juju add-unit -n &lt;span class="m"&gt;3&lt;/span&gt; mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;移除功能:不但可以移除servie，还可以移除machine，甚至是整个environment。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 移除service&lt;/span&gt;
juju remove-service
&lt;span class="c1"&gt;# 移除unit&lt;/span&gt;
juju remove-unit
&lt;span class="c1"&gt;# 移除machine&lt;/span&gt;
juju remove-machine
&lt;/pre&gt;&lt;/div&gt;</content><category term="Cloud"></category><category term="Orchestration"></category></entry><entry><title>Reply 1988: 人生是个迷啊</title><link href="www.subond.com/pages/2016/10/07/reply-1988.html" rel="alternate"></link><published>2016-10-07T00:00:00+08:00</published><updated>2016-10-07T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-10-07:www.subond.com/pages/2016/10/07/reply-1988.html</id><summary type="html">&lt;p&gt;人，之所以为人，是因为可以享受生命的意义，生活的乐趣。这是一篇关于韩剧《请回答1988》的观后感。这部剧发生在韩国首尔一个叫做“双门洞”的胡同，讲述了五家人的故事，细致生动地再现了80年代邻里街坊小市民的生活面貌。&lt;strong&gt;整部剧以生活为主线，贯穿亲情，友情，爱情以及邻里情，细致地刻画了那个永远回不去的青春岁月&lt;/strong&gt;。剧中的生活细节做的很足，处处都可以看到编剧和导演的良苦用心。其实，生活无非就是一日三餐，家长里短，却被演员们表现的淋漓尽致，主要集中在以下几个方面。&lt;/p&gt;</summary><content type="html">&lt;p&gt;人，之所以为人，是因为可以享受生命的意义，生活的乐趣。&lt;/p&gt;
&lt;p&gt;这是一篇关于韩剧《请回答1988》的观后感。&lt;/p&gt;
&lt;h2&gt;这部剧讲了啥？&lt;/h2&gt;
&lt;p&gt;&lt;img alt="reply-1988" src="http://on64c9tla.bkt.clouddn.com/2016D/TVN%27s_Reply_1988_poster.jpg"&gt;&lt;/p&gt;
&lt;p&gt;这部剧发生在韩国首尔一个叫做“双门洞”的胡同，讲述了五家人的故事，细致生动地再现了80年代邻里街坊小市民的生活面貌。&lt;strong&gt;整部剧以生活为主线，贯穿亲情，友情，爱情以及邻里情，细致地刻画了那个永远回不去的青春岁月&lt;/strong&gt;。剧中的生活细节做的很足，处处都可以看到编剧和导演的良苦用心。其实，生活无非就是一日三餐，家长里短，却被演员们表现的淋漓尽致，主要集中在以下几个方面：&lt;/p&gt;
&lt;h2&gt;关于亲情&lt;/h2&gt;
&lt;p&gt;剧中宝拉的父亲是一个善良，倔强，喜欢把话放在心里的父亲形象，像很多中国的父亲一样。在自己妈妈去世的那一段，宝拉的父亲白天笑脸招呼客人，晚上独自悲伤，静静地守在灵堂前。直到大哥回来，才好像找到了依靠，不必装作坚强，兄弟姐们四人终于忍不住哭了起来。”大人只是在忍，只是在忙着大人的事，只是在用故作坚强来承担年龄的重担。大人们，也会疼。”&lt;/p&gt;
&lt;p&gt;二十几岁的年龄，或多或少也开始意识并接触到周围亲人的年老，甚至离开。突然之间就发现，原来好多的称呼从此再也叫不出口，而关于那个人的记忆却永远地刻在记忆里。我的爷爷在我父亲18岁的时候，生病去世了。所以从小到大，我没有喊过一声"爷爷"，也从来没有体会过爷爷的爱是一种什么样的爱。小时候不懂事，还吵着向父亲母亲“要过”爷爷。现在想来，那时的父亲想必也是凄苦的。随着年龄的增长，那一声”所谓的称呼”也就越发显得弥足珍贵了，真是应了中国那句老话：喊一声，少一声。&lt;/p&gt;
&lt;p&gt;“上帝不能无处不在，因此他创造了母亲”是一句犹太谚语，是赞美母亲的。其实，父母真的就是子女的守护神。无论孩子在外面受了多大的委屈，只要回家就能感受到温暖，找到了依靠。挫折的时候，给我们鼓励与安慰；迷茫的时候，给我们指引与勇气；给我们追逐梦想的力量。每当我们取得一些成绩的时候，或是夸赞，或是小心翼翼地记录着我们的成长，像阿泽爸那样，把报纸上关于儿子的比赛报道一一剪下，做成册子，细数着儿子每一次的成绩。深沉的大地一样的爱，那是父亲的爱。&lt;/p&gt;
&lt;p&gt;剧中的三位母亲，也是那样的平凡而伟大。没有女儿的豹子夫人，却收获了比女儿还细心的"二女儿"金正焕。知道母亲不懂英文，细心地在母亲的护照上标上注音；知道母亲是操心的命，当发现母亲因为外出探亲而父子三人过得还不错而不免有些失落的时候，故意制造小麻烦，让母亲“回归”；知道父母的结婚照是合成的，精心地为二人准备婚礼。这些小小的细节，足见正焕的用心。90年代我国实行”计划生育”政策，导致我们90后这一代几乎都是独生女子，以至于作为儿子的我们，不得不又当儿子又当“闺女”。&lt;/p&gt;
&lt;p&gt;剧中印象很深的还有的阿泽爸爸和善宇妈妈，两人都有一个好儿子。作为单亲家庭的孩子都很懂事，两个儿子都知道父母亲的不容易，更明白人生的意义。&lt;strong&gt;人各有命，作为孩子尊重父亲，母亲的决定，作为父母也尊重孩子的想法&lt;/strong&gt;。渐渐地发现，生命中的每一个出现在身边的人都有存在的意义。有些话只能对固定的人讲，或者选择不说。丈夫，妻子，邻里，儿子，女儿，朋友···每个人扮演的角色不同，所承载的意义也不同。就像香港电台主持人梁继璋在给儿子的一封信中写到的那样：“亲人只有一次的缘分，无论这辈子我和你相处多久，也请好好珍惜共聚的时光，下辈子，无论爱与不爱，都不会再见”。&lt;strong&gt;今生有幸为家人是最大的幸福&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;关于爱情&lt;/h2&gt;
&lt;p&gt;剧中德善的爱情最引人关注。在不知道结局的时候，个人比较倾向于德善和阿泽这一对儿。原因很简单：&lt;strong&gt;没有所谓的时机，只有更恳切的心&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果今天，我没有被那该死的红绿灯拦住，我可能就会命运般站在她的面前。但是缘分，不是自动找上门的偶然，是带着恳切的盼望做出的无数选择。那家伙更恳切，搞怪的不是红绿灯，而是我数不清的犹豫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是正焕的独白，只可惜明白得太晚了。虽有些让人心疼，可是世事如此。既然喜欢，就要大大方方让对方知道。爱情里，没有尴尬。有些人，总是担心，本来是朋友说破了岂不是很尴尬。其实，今生若不能为爱人，为什么要保持那么亲密的朋友关系呢？为了爱人，失去一个好朋友又怎么样，何况还是异性。&lt;strong&gt;爱人，才是我们一生都要守护的那个人&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;关于友情&lt;/h2&gt;
&lt;p&gt;剧中正焕和阿泽同时喜欢德善，互为情敌。但是有一句台词我很喜欢：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然我和你爱着同一个女人，可是我仍然喜欢你，不愿意让任何不幸发生在你身上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没错，这就是友情。&lt;/p&gt;
&lt;h2&gt;关于人生&lt;/h2&gt;
&lt;p&gt;人生的话题好大，可是细说起来也就那么点。每个人都有自己的选择，都有需要自己独自去面对的时刻，为了不让我们孤单，才拥有了家人，朋友。人生更像是一场修行，能帮到你的也只有 &lt;strong&gt;我们自己&lt;/strong&gt;。善待生命中遇到的每一个人，他们看似无关，却与你有着千丝万缕的牵连，来到你的身边，请珍惜。&lt;/p&gt;
&lt;p&gt;剧中的正峰哥哥也是一个神奇的存在，说实话全剧95%的剧情中我都觉着这是一个多余，直到结尾才发现，这是导演的最后一步棋。正峰哥哥用了七年考大学，用了七年考司法考试，直到遇见真爱，才明白：活着，要做自己想做的事情。最终选择了做美食。&lt;strong&gt;一个人能够发现自己的擅长，并将其培养成自己的工作或者一生的事业，是多么的不容易！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人生最难的在于找到自己。&lt;/p&gt;</content><category term="Life"></category></entry><entry><title>工作中遇到的小技巧</title><link href="www.subond.com/pages/2016/07/12/tip-tools.html" rel="alternate"></link><published>2016-07-12T00:00:00+08:00</published><updated>2016-07-12T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-07-12:www.subond.com/pages/2016/07/12/tip-tools.html</id><summary type="html">&lt;h3&gt;Ubuntu彻底删除Mysql,重装Mysql&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 删除MySQL&lt;/span&gt;
sudo apt-get autoremove --purge mysql-server-5.0
sudo apt-get remove mysql-server
sudo apt-get autoremove mysql-server
sudo apt-get remove mysql-common  &lt;span class="c1"&gt;#很重要&lt;/span&gt;

&lt;span class="c1"&gt;# 清理残留数据&lt;/span&gt;
dpkg -l &lt;span class="p"&gt;|&lt;/span&gt; grep ^rc &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sudo xargs dpkg -P
&lt;span class="c1"&gt;# 安装mysql&lt;/span&gt;
sudo apt-get install mysql-server mysql-client php5-mysql
&lt;span class="c1"&gt;# 启动mysql&lt;/span&gt;
&lt;span class="c1"&gt;# sudo /etc/init.d/mysql restart&lt;/span&gt;
&lt;span class="c1"&gt;# 安装phpmyadmin&lt;/span&gt;
sudo …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h3&gt;Ubuntu彻底删除Mysql,重装Mysql&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 删除MySQL&lt;/span&gt;
sudo apt-get autoremove --purge mysql-server-5.0
sudo apt-get remove mysql-server
sudo apt-get autoremove mysql-server
sudo apt-get remove mysql-common  &lt;span class="c1"&gt;#很重要&lt;/span&gt;

&lt;span class="c1"&gt;# 清理残留数据&lt;/span&gt;
dpkg -l &lt;span class="p"&gt;|&lt;/span&gt; grep ^rc &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sudo xargs dpkg -P
&lt;span class="c1"&gt;# 安装mysql&lt;/span&gt;
sudo apt-get install mysql-server mysql-client php5-mysql
&lt;span class="c1"&gt;# 启动mysql&lt;/span&gt;
&lt;span class="c1"&gt;# sudo /etc/init.d/mysql restart&lt;/span&gt;
&lt;span class="c1"&gt;# 安装phpmyadmin&lt;/span&gt;
sudo apt-get install phpmyadmin
sudo ln -s /etc/phpmyadmin/apache.conf /etc/apache2.conf-available/phpmyadmin.conf
sudo a2enconf phpmyadmin
sudo /etc/init.d/apache2 reload
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Ubuntu启动问题以及Grub Rescue修复方法&lt;/h3&gt;
&lt;p&gt;在安装双系统时，或者不小心删除了启动引导项时，启动时系统将进入Grub Rescue模式。在rescue模式下，只用少量的命令可以使用，但是通过一定的操作可以让系统加载正常模块，然后进入正常启动模式，启动后修复grub启动项即可。&lt;/p&gt;
&lt;p&gt;rescue模式下可使用的命令有：set,ls(列出文件),insmod(插入启动模块),root(设置启动分区),prefix(设置启动路径)。&lt;/p&gt;
&lt;p&gt;解决方法如下：&lt;/p&gt;
&lt;pre&gt;
# 查看系统分区情况
grub rescue&gt;ls
# 罗列出所有的磁盘分区信息，比如说：
(hd0,msdos6) (hd0,msdos5) (hd0,msdos4) (hd0,msdos3)(hd0,msdos2)
# 查找曾经安装系统的磁盘分区，找到相应的grub
grub rescue&gt;ls (hd0,X)/        # 查看X磁盘分区/根路径的文件信息
grub rescue&gt;ls (hd0,X)/boot    # 查看X磁盘分区/boot路径的文件信息
grub rescue&gt;ls (hd0,X)/grub    # 查看X磁盘分区/grub路径的文件信息
# 假设找的(hd0,msdos3)时，显示了文件信息，则表明系统安装在这个分区，并记住相应的grub路径
# 接下来，设置系统的启动项，调用如下命令
grub rescue&gt;set root=(hd0,msdos3)
grub rescue&gt;set prefix=(hd0,msdos3)/grub  #这个路径为之前找到的启动项路径
grub rescue&gt;insmod normal
# 设置完成后，进行启动即可
grub rescue&gt;normal&lt;/pre&gt;

&lt;p&gt;经过以上操作，就可以显示丢失的grub菜单，然后进入自己想进入的系统即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果进行重启，问题依旧存在。所以最关键的一步就是对grub进行修复。&lt;/b&gt;进入系统后，使用以下命令对grub进行修复。&lt;/p&gt;
&lt;pre&gt;
sudo update-grub
sudo grub-install /dev/sda
# sda是磁盘号码，不是分区号码&lt;/pre&gt;

&lt;p&gt;grub修复成功后，重启测试即可。&lt;em&gt;说明一下，grub修复成功后，其启动项是由当前系统去引导另一系统启动。&lt;/em&gt;你也可以进入另一系统进行grub修复，修改启动引导顺序，或者修改文件/etc/default/grub设定默认启动项(GRUB_DEFAULT从0开始计算)。&lt;/p&gt;</content><category term="tools"></category></entry><entry><title>机器学习之Weka学习-Evaluation类介绍</title><link href="www.subond.com/pages/2016/07/03/machinelearning-about-weka-evaluation.html" rel="alternate"></link><published>2016-07-03T00:00:00+08:00</published><updated>2016-07-03T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-07-03:www.subond.com/pages/2016/07/03/machinelearning-about-weka-evaluation.html</id><summary type="html">&lt;p&gt;Evaluation类顾名思义，用来评价各种分类器（包括机器学习模型）的性能。Weka中有两个Evaluation类，分别位于weka.classifiers.evaluation.Evaluation和weka.classifiers.Evaluation 而且这两个类定义了同样的接口，其中evaluation包下的Evaluation类就是把所有的操作交给classifier包下的Evalution类来完成，也许为了能够适配旧版本已经编写的代码，就保留了classifier包下的 Evalution类，我们暂且不需要即可。下面我们就介绍weka.classifier.Evaluation类。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.Evalution类介绍&lt;/h2&gt;
&lt;p&gt;Evaluation类顾名思义，用来评价各种分类器（包括机器学习模型）的性能。Weka中有两个Evaluation类，分别位于weka.classifiers.evaluation.Evaluation和weka.classifiers.Evaluation 而且这两个类定义了同样的接口，其中evaluation包下的Evaluation类就是把所有的操作交给classifier包下的Evalution类来完成，也许为了能够适配旧版本已经编写的代码，就保留了classifier包下的 Evalution类，我们暂且不需要即可。下面我们就介绍weka.classifier.Evaluation类。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class　Evaluation
extends java.lang.Object
implemensts java.io.Serializable, Summarizable, RevisionHandler
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;2.构造函数&lt;/h2&gt;
&lt;p&gt;Evaluation类没有无参的构造函数，一般用Instances对象作为构造函数的参数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Evaluation eval = new Evaluation(data)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;data是训练集的数据，用来获取一些信息，并不用来评价分类器。&lt;/p&gt;
&lt;p&gt;&lt;img alt="evaluation-weka" src="http://on64c9tla.bkt.clouddn.com/2016C/Evaluation.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;3.主要成员变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;evaluationModel(Classifier classifier, Instances data)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果训练集和测试集是分开的，可以使用evaluationModel方法，方法中的参数为：第一个参数是训练过的分类器，第二个参数是测试集的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;crossValidationModel()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;crossValidationModel方法的四个参数为：第一个参数是分类器，第二个参数是测试集的数据，第三个参数是交叉检验的次数（比较常见的是10），第四个参数是一个随机数对象。&lt;/p&gt;
&lt;h2&gt;4.应用示例&lt;/h2&gt;
&lt;p&gt;下面这个小程序用同一数据测试了两类方法的评价结果，源码地址如下&lt;a href="https://github.com/yusubond/Machine-Learning/blob/master/Evaluation/Demo_evaluation.java"&gt;Demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="result-evaluationModel" src="http://on64c9tla.bkt.clouddn.com/2016C/evaluationModel.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="result-crossvalidateModel" src="http://on64c9tla.bkt.clouddn.com/2016C/crossvalidateModel.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官网资料：&lt;a href="http://10.103.14.28/weka-3-8-0/doc/"&gt;Instances类&lt;/a&gt;&lt;br&gt;
Weka开发[3]-Evaluation类：&lt;a href="http://quweiprotoss.blog.163.com/blog/static/408828832008103042734622/"&gt;http://quweiprotoss.blog.163.com/blog/static/408828832008103042734622/&lt;/a&gt;&lt;/p&gt;</content><category term="MachineLearning"></category><category term="AI"></category></entry><entry><title>机器学习之Weka学习-Instances类介绍</title><link href="www.subond.com/pages/2016/06/29/machinelearning-about-weka-instances.html" rel="alternate"></link><published>2016-06-29T00:00:00+08:00</published><updated>2016-06-29T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-29:www.subond.com/pages/2016/06/29/machinelearning-about-weka-instances.html</id><summary type="html">&lt;p&gt;Instances类是Weka中进行数据操作的对象，即需将所要处理的数据先存入并转化为Instances类的对象，然后进行其他操作。也就是说Instances类是继承AbstractList类而来，并实了Serializable,RevisionHandler接口。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.Intances类介绍&lt;/h2&gt;
&lt;p&gt;Instances类是Weka中进行数据操作的对象，即需将所要处理的数据先存入并转化为Instances类的对象，然后进行其他操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public class Instances
extends java.util.AbstractList&amp;lt;Instace&amp;gt;
implemensts java.io.Serializable, RevisionHandler
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是说Instances类是继承AbstractList类而来，并实现了Serializable,RevisionHandler接口。&lt;/p&gt;
&lt;h2&gt;2.构造函数&lt;/h2&gt;
&lt;p&gt;&lt;img alt="weka-instances" src="http://on64c9tla.bkt.clouddn.com/2016B/20160629instances-gouzao.jpg"&gt;&lt;/p&gt;
&lt;p&gt;其构造函数可以实现实例的完整或部分拷贝，也可以创建新的实例，值得注意的是，其读入的数据格式为arff。关于arff的数据格式后续会有介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要成员变量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;numAttributes():返回属性总量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setClassIndex(int):设置用于分类的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;instance(int):返回具体的实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;firstInstance():返回第一个实例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.应用实例&lt;/h2&gt;
&lt;p&gt;1.导入数据，设置分类属性，输出实例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.lang.String&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.converters.ConverterUtils.DataSource&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;DataSource&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;DataSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;filename&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Instances&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getDataSet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.示例程序 程序源码地址：&lt;a href="https://github.com/yusubond/Machine-Learning/blob/master/Instances/Demo_Instances.java"&gt;Instances小实例&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;weka01&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.converters.ConverterUtils.DataSource&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.Instances&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Demo_Instances&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;testInstances&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;DataSource&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;DataSource&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/home/subond/subond/weka-3-8-0/data/weather.numeric.arff&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;Instances&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDataSet&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

            &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setClassIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numAttributes&lt;/span&gt;&lt;span class="o"&gt;()-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

            &lt;span class="c1"&gt;//System.out.println(ins);&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the number of attributes:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numAttributes&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the number of instances:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numInstances&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the first instance:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;firstInstance&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the 3rd instance:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the last instances:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lastInstance&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the name of relation:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;relationName&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="c1"&gt;//将第一个实例加入到总实例的最后&lt;/span&gt;
            &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;firstInstance&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;



        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Demo_Instances&lt;/span&gt; &lt;span class="n"&gt;testIns&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Demo_Instances&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;testIns&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;testInstances&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官网资料：&lt;a href="http://10.103.14.28/weka-3-8-0/doc/"&gt;Intances类&lt;/a&gt;&lt;/p&gt;</content><category term="MachineLearning"></category><category term="AI"></category></entry><entry><title>机器学习之Weka学习-简单分类器</title><link href="www.subond.com/pages/2016/06/28/machinelearning-about-weka-classifier.html" rel="alternate"></link><published>2016-06-28T00:00:00+08:00</published><updated>2016-06-28T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-28:www.subond.com/pages/2016/06/28/machinelearning-about-weka-classifier.html</id><summary type="html">&lt;p&gt;Weka的全名是怀卡托智能分析环境（Waikato Environment for Knowledge Analysis），是一款免费的，非商业化的，基于JAVA环境下开源的机器学习（machine learning）以及数据挖掘（data mining）工具。 它和它的源代码可在其&lt;a href="http://www.cs.waikato.ac.nz/ml/weka/"&gt;官方网站&lt;/a&gt;下载。&lt;/p&gt;</summary><content type="html">&lt;p&gt;WEKA作为一个公开的数据挖掘工作平台，集合了大量能承担数据挖掘任务的机器学习算法，包括对数据进行预处理， 分类，回归、聚类、关联规则以及在新的交互式界面上的可视化。&lt;/p&gt;
&lt;h2&gt;1.Weka介绍&lt;/h2&gt;
&lt;p&gt;Weka的全名是怀卡托智能分析环境（Waikato Environment for Knowledge Analysis），是一款免费的，非商业化的，基于JAVA环境下开源的机器学习（machine learning）以及数据挖掘（data mining）工具。 它和它的源代码可在其&lt;a href="http://www.cs.waikato.ac.nz/ml/weka/"&gt;官方网站&lt;/a&gt;下载。
WEKA作为一个公开的数据挖掘工作平台，集合了大量能承担数据挖掘任务的机器学习算法，包括对数据进行预处理， 分类，回归、聚类、关联规则以及在新的交互式界面上的可视化。&lt;/p&gt;
&lt;p&gt;机器学习可以概括为“为使用正确的特征来构建正确的模型，以完成既定的任务”。任务，模型及特征是机器学习的三大”原料“。其工作流程一般如下：&lt;/p&gt;
&lt;p&gt;1.学习问题，即由训练数据结合学习算法构建正确的模型&lt;br&gt;
2.构建特征，即将原始数据根据所需构建特征，形成模型所识别的数据格式&lt;br&gt;
3.完成任务，即借助正确的模型，对数据进行处理，得到输出。  &lt;/p&gt;
&lt;h2&gt;2.简单分类器实例&lt;/h2&gt;
&lt;p&gt;该分类器的数据处理过程如下：
1)读入训练数据&lt;br&gt;
2)初始化分类器&lt;br&gt;
3)使用训练数据训练分类器&lt;br&gt;
4)使用测试样本测试分类器的学习效果&lt;br&gt;
5)打印分类结果  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;weka01&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.File&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.classifiers.Classifier&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.classifiers.Evaluation&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.Instance&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.Instances&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weka.core.converters.ArffLoader&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SimpleCluster&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Instances&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Classifier&lt;/span&gt; &lt;span class="n"&gt;cfs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *读入训练数据&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
      &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/home/subond/subond/weka-3-8-0/data/weather.numeric.arff&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;ArffLoader&lt;/span&gt; &lt;span class="n"&gt;loader&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ArffLoader&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;loader&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;ins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;loader&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDataSet&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *设置数据集的分类类别，即指定哪一列作为类别&lt;/span&gt;
&lt;span class="cm"&gt;      *注意：本例中设置最后一列作为类别&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setClassIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numAttributes&lt;/span&gt;&lt;span class="o"&gt;()-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *初始化分类器&lt;/span&gt;
&lt;span class="cm"&gt;      *具体使用哪一种特定的分类器可以在forName函数中指定&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;cfs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Classifier&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;forName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;weka.classifiers.bayes.NaiveBayes&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;newInstance&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *使用训练数据训练分类器&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;cfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;buildClassifier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *使用测试样本测试分类器的学习效果&lt;/span&gt;
&lt;span class="cm"&gt;      *注意：本实例中，为了方便将训练数据和测试数据置为同一个&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;Instance&lt;/span&gt; &lt;span class="n"&gt;testInst&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;Evaluation&lt;/span&gt; &lt;span class="n"&gt;testingEvaluation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Evaluation&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;numInstances&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt;
            &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;        *将每个测试样本都用来测试分类器的效果&lt;/span&gt;
&lt;span class="cm"&gt;        */&lt;/span&gt;
                &lt;span class="n"&gt;testInst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;testingEvaluation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;evaluateModelOnceAndRecordPrediction&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cfs&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testInst&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      *输出结果&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;分类器的正确率：&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;testingEvaluation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;errorRate&lt;/span&gt;&lt;span class="o"&gt;()));&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="MachineLearning"></category><category term="AI"></category></entry><entry><title>Linux中的线程管理</title><link href="www.subond.com/pages/2016/06/19/pthread2-management-in-linux.html" rel="alternate"></link><published>2016-06-19T00:00:00+08:00</published><updated>2016-06-19T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-19:www.subond.com/pages/2016/06/19/pthread2-management-in-linux.html</id><summary type="html">&lt;p&gt;线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1.线程&lt;/h3&gt;
&lt;p&gt;线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。&lt;/p&gt;
&lt;h3&gt;2.多线程模型&lt;/h3&gt;
&lt;p&gt;操作系统中有两种方法提供线程支持：用户层的 &lt;strong&gt;用户线程&lt;/strong&gt; 和 内核层的 &lt;strong&gt;内核线程&lt;/strong&gt;。用户线程受内核内核支持，而无需内核管理；内核线程由系统直接支持和管理。&lt;/p&gt;
&lt;p&gt;1）多对一模型：多个用户线程映射到一个内核线程&lt;/p&gt;
&lt;p&gt;特点：线程管理由线程库在用户空间进行，效率高；一个线程阻塞系统调用，整个进程阻塞；任意时刻，只有一个线程能访问内核(也就是，多线程不能并行运行在多处理器上)&lt;/p&gt;
&lt;p&gt;2）一对一模型：每个用户线程映射到一个内核线程&lt;/p&gt;
&lt;p&gt;特点：一个线程阻塞，其他线程不受影响，具有并发功能；允许多线程运行在多处理器上。&lt;/p&gt;
&lt;p&gt;3）多对多模型：即多路复用，许多用户线程映射到同等数量或较少数量的内核线程&lt;/p&gt;
&lt;p&gt;特点：结合多对一模型和一对一模型的优点，其对应的一个变形是 &lt;strong&gt;二级模型&lt;/strong&gt; (先允许一个用户线程绑定到一个内核线程上，然后，其他用户线程多路复用)&lt;/p&gt;
&lt;h3&gt;3.线程库&lt;/h3&gt;
&lt;p&gt;线程库为程序员提供创建和管理线程的API函数，主要有两种方法来实现线程库：&lt;b&gt;系统调用&lt;/b&gt;和&lt;b&gt;非系统调用&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;1）在用户空间提供没有内核支持的库，称为 &lt;strong&gt;非系统调用&lt;/strong&gt;；&lt;br&gt;
2）由系统支持的内核级库，称为 &lt;strong&gt;系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;系统调用fork()和exec()&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;exec():如果一个线程调用exec()，则其指定的程序替换整个进程，包括所有线程。&lt;br&gt;
fork(): 1）fork()之后立即调用exec()，则没有必要替换所有线程，因为exec()会替换所有线程；2）fork()之后没有调用exec()，则另一个进程复制所有线程。&lt;/p&gt;
&lt;h3&gt;4.线程取消&lt;/h3&gt;
&lt;p&gt;线程取消是在线程完成之前来终止线程的任务。要取消的线程称为 &lt;strong&gt;目标线程&lt;/strong&gt;。目标线程可以在两种情况下发生：&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;异步取消&lt;/strong&gt;: 一个线程立即终止目标线程。  (所有线程共享进程的数据，因为异步取消并不会使系统资源空闲)&lt;br&gt;
2）&lt;strong&gt;延迟取消&lt;/strong&gt;: 目标线程不断检查自己是否应该终止，让线程有机会有序结束自己。  (因为具有 &lt;strong&gt;取消点&lt;/strong&gt;，因此更安全)&lt;/p&gt;
&lt;h3&gt;5.信号处理&lt;/h3&gt;
&lt;p&gt;信号是用来通知进程某个事件已发生，可分为 &lt;strong&gt;异步接收&lt;/strong&gt; 和 &lt;strong&gt;同步接收&lt;/strong&gt;。所有的信号具有同样的模式：&lt;/p&gt;
&lt;p&gt;1）信号是由特定事件发生；2）信号发送至进程；3）一旦发送，信号必须加以处理。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步信号&lt;/strong&gt;: 指发送信号到执行操作的同一进程(例如，非法访问，被0除)&lt;br&gt;
&lt;strong&gt;异步信号&lt;/strong&gt;: 指信号由进程外事件产生，发送到另一个进程。(例如，特定键(ctrl+c))&lt;/p&gt;
&lt;p&gt;标准发送信号的函数:1) kill(pid_t id, int signal)指定信号的发送进程；2）pthread_kill(pthread_t id, int signal)允许信号被传送到一个指定的线程。&lt;/p&gt;
&lt;h3&gt;6.线程池&lt;/h3&gt;
&lt;p&gt;其思想是：进程开始时，创建一定数量的线程，放入线程池等待工作。其优点有，1）不必创建新线程，响应时间更快；2）可以限制线程数量，有效利用系统资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux系统中并不区分进程和线程，统称为 &lt;strong&gt;任务&lt;/strong&gt;。其系统调用包括：fork()和clone()。&lt;/p&gt;
&lt;p&gt;fork():传统复制进程——具备父任务的所有数据的副本&lt;br&gt;
clone()创建线程(子任务)——根据传递给clone()的标志位，子任务指向父任务的数据结构&lt;/p&gt;
&lt;h2&gt;线程小结&lt;/h2&gt;
&lt;p&gt;线程是进程内的控制流，多线程进程在同一地址空间内包括多个不同的控制流。用户线程对程序员是可见的，对内核来说却是未知的。操作系统支持和管理内核线程。有三种不同的模式将用户线程和内核线程关联起来：多对一模式，一对一模式和多对多模式。&lt;/p&gt;
&lt;h2&gt;一个小栗子&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;*Author:subond&lt;/span&gt;
&lt;span class="cm"&gt;* Time: 2016-06-19&lt;/span&gt;
&lt;span class="cm"&gt;* Function: 用户在命令行输入一个数字，然后创建一个独立线程来输出小于或等于输入数的所有素数&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;runner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;pthread_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enter a number(&amp;gt;= 0):&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;pthread_attr_t&lt;/span&gt; &lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;pthread_attr_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;runner&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Create pthread error&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;pthread_join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="process"></category><category term="pthread"></category></entry><entry><title>Linux中的进程管理</title><link href="www.subond.com/pages/2016/06/17/process-management-in-linux.html" rel="alternate"></link><published>2016-06-17T00:00:00+08:00</published><updated>2016-06-17T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-17:www.subond.com/pages/2016/06/17/process-management-in-linux.html</id><summary type="html">&lt;p&gt;进程是执行中的程序，是大多数系统的工作单元，是 &lt;strong&gt;活动实体&lt;/strong&gt;。一般，进程具有以下几种状态：新的，运行，等待，就绪，终止。每个进程在操作系统中用进程控制块(PCB)表示，其包含许多与一个特定进程相关的信息(进程状态，程序计数器，CPU寄存器，CPU调度信息，内存管理信息，记账信息，I/O状态信息等)。&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1.进程&lt;/h3&gt;
&lt;p&gt;进程是执行中的程序，是大多数系统的工作单元，是 &lt;strong&gt;活动实体&lt;/strong&gt;。一般，进程具有以下几种状态：新的，运行，等待，就绪，终止。每个进程在操作系统中用进程控制块(PCB)表示，其包含许多与一个特定进程相关的信息(进程状态，程序计数器，CPU寄存器，CPU调度信息，内存管理信息，记账信息，I/O状态信息等)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程调度是指选择一个可用的进程到CPU上执行的过程，由相应的 &lt;strong&gt;调度程序&lt;/strong&gt; 来执行。进程进入系统后，进入 &lt;strong&gt;作业队列&lt;/strong&gt; (包含系统中的所有队列)；驻留在内存中就绪，等待执行的进程位于 &lt;strong&gt;就绪队列&lt;/strong&gt;。就绪队列通常用链表实现，其头节点指向链表的第一个和最后一个PCB块的指针；每个PCB包括一个指向就绪队列的下一个的PCB的指针域。&lt;/p&gt;
&lt;p&gt;&lt;img alt="三种进程调度的区别" src="http://on64c9tla.bkt.clouddn.com/20160617process2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;调度程序分为 &lt;strong&gt;长期调度程序&lt;/strong&gt;, &lt;strong&gt;中期调度程序&lt;/strong&gt; 和 &lt;strong&gt;短期调度程序&lt;/strong&gt;。长期调度(高级调度)，又称为 &lt;strong&gt;作业调度&lt;/strong&gt;，是指从池中选择进程，并装入内存准备执行，其使用频率比较低，主要用来控制内存中进程的数量；中期调度(中级调度)，又称为 &lt;strong&gt;交换调度&lt;/strong&gt;，是指将进程中内存或CPU竞争中移出，从而降低多道程序设计的程度，之后进程被重新装入内存；短期调度(低级调度)，又称为 &lt;strong&gt;进程调度&lt;/strong&gt;，是指按照一定的策略和算法，将CPU分配给一个处于就绪的进程，分为 &lt;strong&gt;抢占式&lt;/strong&gt; 和 &lt;strong&gt;非抢占式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="三种进程调度的区别" src="http://on64c9tla.bkt.clouddn.com/20160617process.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文切换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将CPU切换找另一个进程需要保存当前进程的状态，并恢复另一个进程的状态，这个过程称为上下文切换。&lt;/p&gt;
&lt;h3&gt;2.进程操作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;进程创建&lt;/strong&gt; 和 &lt;strong&gt;进程终止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程创建新进程时，有两种执行可能：&lt;/p&gt;
&lt;p&gt;1）父进程与子进程并发执行；2）父进程等待，直到某个子进程或全部子进程执行完毕。&lt;/p&gt;
&lt;p&gt;同样，新进程的地址空间也有两种可能：&lt;/p&gt;
&lt;p&gt;1）子进程是父进程的复制品（具有父进程相同的程序和数据）；2）子进程装入一个新程序。&lt;/p&gt;
&lt;p&gt;在linux系统，使用fork()函数可以创建一个新进程，相关内容参考fork()函数。&lt;/p&gt;
&lt;p&gt;当进程完成执行最后的语句病使用系统调用exit()请求操作系统删除自身时，进程终止。进程终止时，可以返回状态值(整数)到父进程(通过系统调用wait())，所有进程资源将会被操作系统回收。&lt;/p&gt;
&lt;h3&gt;3.进程间通信&lt;/h3&gt;
&lt;p&gt;进程间通信(IPC)有两种基本模式：&lt;strong&gt;共享内存&lt;/strong&gt; 和 &lt;strong&gt;消息传递&lt;/strong&gt;。进程间通信可以调用send()和receive()来进行，其可分为 &lt;strong&gt;阻塞&lt;/strong&gt; 或 &lt;strong&gt;非阻塞&lt;/strong&gt;——也称为 &lt;strong&gt;同步&lt;/strong&gt; 和 &lt;strong&gt;异步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;阻塞send: 发送进程阻塞，直到消息被进程或邮箱所接收；&lt;br&gt;
非阻塞send: 发送进程发送消息并继续操作；&lt;br&gt;
阻塞receive: 接收进程阻塞，直到有消息可用；&lt;br&gt;
非阻塞receive: 接收进程接收到一个有用消息或空消息；&lt;/p&gt;
&lt;p&gt;值得注意的是，无论是直接通信还是间接通信，通信进程的消息的驻留在临时队列中。队列的实现有三种方式：零容量，有限容量，无限容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享内存实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建共享内存段shmget()&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//三个参数：标识符，字节数，读写模式&lt;/span&gt;
&lt;span class="c1"&gt;//函数返回整数标识值&lt;/span&gt;
&lt;span class="n"&gt;segment_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shmget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IPC_PRIVATE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;S_IRUSR&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;S_IWURS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//三个参数：共享内存段的ID，指针，读写模式&lt;/span&gt;
&lt;span class="c1"&gt;//返回初始位置的指针&lt;/span&gt;
&lt;span class="n"&gt;share_memory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;shmat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//删除共享内存段，释放指针&lt;/span&gt;
&lt;span class="n"&gt;shmdt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;share_memory&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;shmctl&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;消息传递&lt;/strong&gt;: Mach&lt;/p&gt;
&lt;p&gt;Mach系统主要为分布式系统设计。在Mach系统中，每个任务创建时，同时创建了两个特别的邮箱：&lt;strong&gt;内核邮箱&lt;/strong&gt; 和 &lt;strong&gt;通报邮箱&lt;/strong&gt;。内核使用内核邮箱与任务通信，使用通报邮箱发送事件发生的通知。&lt;/p&gt;
&lt;p&gt;消息传递使用三个系统调用：&lt;/p&gt;
&lt;p&gt;1）msg_send():发送数据；&lt;br&gt;
2）msg_receive():接收数据；&lt;br&gt;
3）msg_rpc():发送远程消息，并只等待来自发送者的一个返回消息；  &lt;/p&gt;
&lt;p&gt;值得注意的是，Mach可以确保来自同一个发送者额多个消息满足FIFO顺序排队，但不是绝对顺序。即两个发送者的消息可以任意排队。其次，Mach使用的是双重复制机制(发送者&amp;lt;--复制--&amp;gt;邮箱&amp;lt;--复制--&amp;gt;接收者)。若使用虚拟内存管理技术(即将发送者的地址空间映射到接收者的地址空间，但只适用与系统内部)，可以避免这种双重复制。&lt;/p&gt;
&lt;h2&gt;4.进程小结&lt;/h2&gt;
&lt;p&gt;进程是执行中的程序。随着程序的执行，它改变状态。进程状态由进程当前活动所定义。每个进程可处于：新的，就绪，执行，等待或终止状态。每个进程在操作系统内通过自己的进程控制块PCB来表示。当前不执行的进程放在某个等待队列中。操作系统有两种主要队列：&lt;strong&gt;I/O请求队列&lt;/strong&gt; 和 &lt;strong&gt;就绪队列&lt;/strong&gt;。就绪队列包括所有准备执行或等待CPU的进程。每个都有PCB，PCB链接起来就形成了就绪队列。长期调度通过选择进程来争用CPU。短期调度从就绪队列中选择进程。&lt;/p&gt;
&lt;p&gt;操作系统的执行进程可以是独立进程，也可以是协作进程。协作进程需要进程间有互相通信机制，主要有两种形式：共享内存和消息传递。&lt;strong&gt;共享内存&lt;/strong&gt; 方法通过要求通信进程共享一些变量，进程通过使用共享变量来交换信息；而 &lt;strong&gt;消息系统&lt;/strong&gt; 方法允许进程交换信息。&lt;/p&gt;</content><category term="linux"></category><category term="process"></category></entry><entry><title>Linux中的线程函数</title><link href="www.subond.com/pages/2016/06/14/pthread-management-in-linux.html" rel="alternate"></link><published>2016-06-14T00:00:00+08:00</published><updated>2016-06-14T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-06-14:www.subond.com/pages/2016/06/14/pthread-management-in-linux.html</id><summary type="html">&lt;p&gt;线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。本节主要介绍5个基本线程函数。&lt;/p&gt;</summary><content type="html">&lt;p&gt;线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。以下内容，主要介绍5个基本线程函数。&lt;/p&gt;
&lt;h3&gt;1.pthread_create()函数&lt;/h3&gt;
&lt;p&gt;当一个程序由exec启动执行时，称为初始线程或主线程的单个线程就创建了。其余线程则由pthread_create函数创建。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;pthread_attr_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回：成功为0，出错为正的Exxx值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;tid&lt;/strong&gt;:一个进程内的每个线程都有一个线程ID标识，其数据类型为pthread_t(unsigned long int,即％lu)。如果新的线程创建成功，其ID通过tid指针返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;attr&lt;/strong&gt;:属性，每个线程都有许多属性（优先级，初始栈大小，是否成为一个守护线程等等）。若采用默认设置，可置attr参数为空指针（NULL）。&lt;/p&gt;
&lt;p&gt;创建一个线程时最后指定的参数就是由该线程执行的函数func及其参数arg。&lt;strong&gt;注意&lt;/strong&gt; func和arg的声明。func所指函数作为参数接受一个通用指针 (void *)，又作为返回值返回一个通用指针(void *)。另外该函数的唯一调用参数是指针arg，如果需要给函数传递多个参数，可以打包成一个结构，然后将结构的地址作为单个参数传递给函数。&lt;/p&gt;
&lt;h3&gt;2.pthread_join()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;//返回：成功为0，出错为正的Exxx值。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该函数的功能是等待一个给定线程终止&lt;/p&gt;
&lt;h3&gt;3.pthread_self()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pthread_self&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//返回：调用线程的线程ID。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4.pthread_detach()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pthread_detach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pthread_t&lt;/span&gt; &lt;span class="n"&gt;tid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//返回：成功返回0，出错为正的Exxx值。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个线程或是可汇合的(joinable,默认值)，或是脱离的(detached)。当一个可汇合的线程终止时，它的线程ID和退出状态将留存到另一个线程对它的调用pthread_join。脱离的线程却像守护进程，当它们终止时，所有相关的资源 都被释放，我们不能等待它们终止。pthread_detach函数就是把指定的线程转变为脱离状态。&lt;/p&gt;
&lt;h3&gt;5.pthread_exit()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pthread_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//不返回&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用pthread_exit函数可使线程终止。&lt;/p&gt;
&lt;h2&gt;一个栗子&lt;/h2&gt;
&lt;p&gt;利用线程的方法，重新编写基本UDP套接字编程&lt;/p&gt;
&lt;p&gt;其服务端源码地址：&lt;a href="https://github.com/yusubond/Socket-Programming/blob/master/udp_demo/serverv0.3.c"&gt;https://github.com/yusubond/Socket-Programming/blob/master/udp_demo/serverv0.3.c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="udp-socket" src="http://on64c9tla.bkt.clouddn.com/20160614pthread_udp.png"&gt;&lt;/p&gt;</content><category term="linux"></category><category term="pthread"></category><category term="process"></category></entry><entry><title>Socket编程之基本UDP编程</title><link href="www.subond.com/pages/2016/05/24/socket-bian-cheng-udp.html" rel="alternate"></link><published>2016-05-24T00:00:00+08:00</published><updated>2016-05-24T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-05-24:www.subond.com/pages/2016/05/24/socket-bian-cheng-udp.html</id><summary type="html">&lt;p&gt;UDP套接字编程模型。TCP编写的应用程序和UDP编写的应用程序之间存在本质的差别，其原因在于两者在传输层之间的差异：UDP是无连接不可靠的数据包协议，而不同于TCP提供的面向连接的可靠字节流。使用UDP编写的常见应用程序有：DNS(域名系统)， NFS(网络文件系统)和SNMP(简单网络管理协议)。典型的UDP客户/服务器程序的函数调用如下图1-1所示。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;1.UDP套接字编程模型&lt;/h2&gt;
&lt;p&gt;TCP编写的应用程序和UDP编写的应用程序之间存在本质的差别，其原因在于两者在传输层之间的差异：UDP是无连接不可靠的数据包协议，而不同于TCP提供的面向连接的可靠字节流。使用UDP编写的常见应用程序有：DNS(域名系统)， NFS(网络文件系统)和SNMP(简单网络管理协议)。典型的UDP客户/服务器程序的函数调用如下图1-1所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="udp-socket" src="http://on64c9tla.bkt.clouddn.com/20160514udp-bian-cheng-mo-xing.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1-1 UDP客户/服务器程序所用的套接字函数&lt;/p&gt;
&lt;h2&gt;2.recvfrom()和sendto()函数&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#include&amp;lt;sys/socket.h&amp;gt;
ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen);
ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen);
//均返回：若成功返回读或写的字节数，出错返回-1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前三个参数sockfd,buff和nbytes为：描述符、指向读入或写出的缓冲区的指针和读写字节数。
flags一般置为0。&lt;/p&gt;
&lt;p&gt;sendto的to参数指向一个含有数据包接收者的协议地址的套接字地址结构，其大小由addrlen参数指定。recvfrom的from参数指向一个将由该函数在返回时填写数据报发送者的协议地址的套接字地址结构， 而在该套接字地址结构中填写的字节数则放在addrlen参数所所指的整数中返回给调用者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:sendto的最后一个参数是一个整数值，而recvfrom的最后一个参数是一个指向整数值的指针（即值-结果参数）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:recvfrom的最后两个参数类似accept的最后两个参数：返回时其中套接字地址结构的内容告诉我们是谁发送了数据报（UDP）或是谁发起了连接（TCP）。sendto的最后两个参数类似connect的最后两个参数： 调用时其中套接字地址结构被我们填入数据报发往（UDP）或预制建立连接（TCP）的协议地址。&lt;/p&gt;
&lt;h2&gt;3.消息回传程序示例&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;服务端程序&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;socket_includes.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;listenfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;lenserv&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;lencli&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;lenserv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;lencli&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;//创建套接字&lt;/span&gt;
  &lt;span class="c1"&gt;//listenfd = socket(AF_INET,SOCK_DGRAM, 0);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;listenfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Create socket fail!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;//绑定套接字&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8888&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                &lt;span class="c1"&gt;//主机字节序转网络字节序&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htonl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INADDR_ANY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;//绑定主机的所有网卡&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listenfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lenserv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bind socket error.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;rv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;recvfrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listenfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lencli&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;recvfrom error.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;inet_ntop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;size of buf_client: %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;client buf:%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;client IP: %s, Port: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listenfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lencli&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lencli&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;客户端程序&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;socket_includes.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello UDP!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ser&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ser&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;//sockfd = socket(AF_INET,SOCK_DGRAM, 0);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Create socket fail!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8888&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;inet_pton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;10.103.14.28&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;rv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;recvfrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_BUFFER_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ser&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;recvfr0m error!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;server buf_back:%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;read_buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中头文件均为socket_includes.h&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;netinet/in.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/shm.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;


&lt;span class="cp"&gt;#define MAX_LISTEN_QUE 5&lt;/span&gt;
&lt;span class="cp"&gt;#define SERV_PORT 8888&lt;/span&gt;
&lt;span class="cp"&gt;#define MAX_BUFFER_SIZE 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="socket"></category><category term="newtork programming"></category></entry><entry><title>Socket编程之函数学习篇</title><link href="www.subond.com/pages/2016/05/17/socket-bian-cheng-xue-xi.html" rel="alternate"></link><published>2016-05-17T00:00:00+08:00</published><updated>2016-05-17T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-05-17:www.subond.com/pages/2016/05/17/socket-bian-cheng-xue-xi.html</id><summary type="html">&lt;p&gt;Socket编程涉及多个函数，本篇主要介绍其相关函数。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Socket编程涉及多个函数，本篇主要介绍其相关函数。&lt;/p&gt;
&lt;h2&gt;基本API函数&lt;/h2&gt;
&lt;h3&gt;1.socket()函数-创建套接字&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//成功返回sockfd;出错返回-1.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;sockfd是一个socket描述符，它唯一标识一个socket。这个socket描述符跟其他文件描述符一样，后续的读写操作都需用到这个socket描述符。&lt;/p&gt;
&lt;p&gt;创建socket的时候，可以指定不同的参数创建不同的socket描述符，socket()函数的三个参数分别为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;domain:协议域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;协议域规定了socket的地址类型，在通信中必须采用对应的地址类型。AF_INET(IPv4协议),AF_INET6(IPv6协议),AF_LOCAL(Unix域协议),AF_ROUTE(路由套接口)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type:socket类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的socket类型有SOCK_STREAM(字节流套接口),SOCK_DGRAM(数据包套接口),SOCK_RAW(原始套接口),SOCK_PACKET,SOCK_SEQPACKET(有序分组套接口)等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;protocol:协议类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的通信协议有IPPROTO_TCP(TCP传输协议),IPPROTO_UDP(UDP传输协议),IPPROTO_SCTP(SCTP传输协议),IPPROTO_TIPC等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：type和protocol并不是可以随意组合的。一般情况下设置protocol为０，系统会自动选择type类型所对应的默认协议。&lt;/p&gt;
&lt;h3&gt;2.bind()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;addrlen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//返回:0-成功，-1-出错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;bind()函数涉及三个对象：套接口，地址和端口，负责把特定的地址和端口赋给socket描述符，即sockfd，是从进程到内核传递套接口地址结构的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sockfd&lt;/strong&gt;:socket描述符，即socket()函数创建的唯一标识一个socket。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addr&lt;/strong&gt;:一个const struct sockaddr * 指针,指向要绑定给sockfd的协议地址。其中ipv4地址对应如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct sockaddr_in{
    sa_family_t sin_family;
    in_port_t sin_port;       //port in network byte order
    struct in_addr sin_addr;
}
struct in_addr{
    uint32_t s_addr;  //address in network byte order
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;addrlen&lt;/strong&gt;:对应的是地址的长度。&lt;/p&gt;
&lt;p&gt;函数示例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct sockaddr_in serv;
bind(sockfd, (struct sockaddr *)&amp;amp;serv, sizeof(serv));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3.listen()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;listen()函数用于服务器端，服务器通过调用listen()函数来监听某个socket。其两个参数如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sockfd&lt;/strong&gt;:socket描述符，及socket()函数创建的唯一标识一个socket。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;backlog&lt;/strong&gt;:该sockfd可以允许的最大连接数。&lt;/p&gt;
&lt;h3&gt;4.connect()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;addrlen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回:0-成功，-1-出错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;connect()函数用在客户端，客户端通过这个函数连接服务器端，是从进程到内核传递套接口地址结构的函数。其各参数如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sockfd&lt;/strong&gt;:socket描述符，即socket()函数创建的唯一标识一个socket。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addr&lt;/strong&gt;:一个const struct sockaddr * 指针,指向要绑定给sockfd的协议地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addrlen&lt;/strong&gt;:对应的是地址的长度。&lt;/p&gt;
&lt;h3&gt;5.accept()函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addrlen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//返回连接connect_fd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;TCP服务器端依次调用&lt;font color="#ff0000"&gt;socket(),bind(),listen()&lt;/font&gt;之后，进入监听状态，并监听制定的socket地址。TCP客户端依次调用socket(),connect()之后，开始向TCP服务器端发送一个连接请求。TCP服务器端 监听到这个请求后，调用accept()函数接受请求，这样连接就建立好了。accept()函数是从内核到进程传递套接口地址结构的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;sockfd&lt;/strong&gt;:socket描述符，及socket()函数创建的唯一标识一个socket。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;addr&lt;/strong&gt;:一个结果参数，用来接受一个返回值，指向客户端的地址。若对客户的地址不感兴趣，可设这个值为NULL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;addrlen&lt;/strong&gt;:一个结果参数，用来接受上addr的结构的大小，可以设置为NULL。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6.网络I/O函数&lt;/h3&gt;
&lt;p&gt;常见的网络I/O函数有read()/write(),recv()/send(),readv()/writev(),recvmsg()/sendmsg()和recvfrom()/sendto()。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;recvmsg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;msghdr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;sendmsg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;msghdr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回：成功返回读入/写出的字节数，出错为-1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中函数的大部分参数封装到一个msghdr结构中，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct msghdr{
    void          *msg_name;       /*protocol address*/
    socklen_t     msg_namelen;     /*size of protocol address*/
    struct iovec  *msg_iovlen;     /*scatter/gather array*/
    int           msg_iovlen;      /*  elements in msg_iov*/
    void          *msg_control;    /*ancillary data*/
    socklen_t     msg_controllen;  /*length of ancillary data*/
    int           msg_flags;       /*flags returned by recvmsg*/
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="socket"></category><category term="newtork programming"></category></entry><entry><title>Socket编程之基础篇</title><link href="www.subond.com/pages/2016/05/14/socket-bian-cheng-ji-chu.html" rel="alternate"></link><published>2016-05-14T00:00:00+08:00</published><updated>2016-05-14T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-05-14:www.subond.com/pages/2016/05/14/socket-bian-cheng-ji-chu.html</id><summary type="html">&lt;p&gt;Socket，又称为“套接字”，是进程间进行通信的一种方式，即通过网络库的API函数实现分布在不同主机的相关进程间的数据交换。在TCP/IP网络应用中，通信的两个进程的主要模式是客户/服务器模式， 即客户向服务器发送服务请求，服务器接收到请求后，提供相应的服务。Socket编程接口是指从顶上三层（网际协议的应用层）进入传输层的接口，涉及两个方向上的传递：从进程到内核和从内核到进程，如图1-1所示。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Socket，又称为“套接字”，是进程间进行通信的一种方式，即通过网络库的API函数实现分布在不同主机的相关进程间的数据交换。在TCP/IP网络应用中，通信的两个进程的主要模式是客户/服务器模式， 即客户向服务器发送服务请求，服务器接收到请求后，提供相应的服务。Socket编程接口是指从顶上三层（网际协议的应用层）进入传输层的接口，涉及两个方向上的传递：从进程到内核和从内核到进程，如图1-1所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="tcp-ip-stack" src="http://on64c9tla.bkt.clouddn.com/20160514socket-yu-xie-yi-ge-ceng.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;套接字地址结构&lt;/h2&gt;
&lt;p&gt;学习套接字编程，首先要知道套接字的地址结构，大多数套接字函数都需要一个指向套接字的地址结构的指针作为参数。每个协议族都有自己的套接字地址结构， 均以sockaddr_开头，并以对应的每个协议族的唯一后缀结尾。&lt;/p&gt;
&lt;h3&gt;1.IPv4套接字地址结构&lt;/h3&gt;
&lt;p&gt;IPv4套接字地址结构以sockaddr_in命名，定义在&amp;lt;netinet/in.h&amp;amp;mt头文件中，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;in_addr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;in_addr_t&lt;/span&gt; &lt;span class="n"&gt;s_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="cm"&gt;/*32-bit IPv4 address;network byte ordered*/&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_in&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;uint8_t&lt;/span&gt;            &lt;span class="n"&gt;sin_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;sa_family_t&lt;/span&gt;        &lt;span class="n"&gt;sin_family&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/*AF_INET*/&lt;/span&gt;
        &lt;span class="n"&gt;in_port_t&lt;/span&gt;          &lt;span class="n"&gt;sin_port&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt; &lt;span class="n"&gt;TCP&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;UDP&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;network&lt;/span&gt; &lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;ordered&lt;/span&gt;&lt;span class="err"&gt;*/&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;in_addr&lt;/span&gt;     &lt;span class="n"&gt;in_addr&lt;/span&gt; &lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/*32-bit IPv4 address;network byte ordered*/&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt;               &lt;span class="n"&gt;sin_zero&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="cm"&gt;/*unused*/&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;: 一般情况下，我们只使用这个结构中的3个字段：sin_family,sin_addr和sin_port，其分别对应套接字地址结构的协议族、IP地址和端口号。套接字地址结构仅在给定主机上使用 其结构中的某些字段用在不同主机间的通信，但结构本身不在主机之间传递。&lt;/p&gt;
&lt;h3&gt;2.IPv6套接字地址结构&lt;/h3&gt;
&lt;p&gt;IPv4套接字地址结构以sockaddr_in6命名，定义在&amp;lt;netinet/in.h&amp;amp;mt头文件中，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;in6_addr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;uninet8_t&lt;/span&gt; &lt;span class="n"&gt;s6_addr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="cm"&gt;/*128-bit IPv4 address;network byte ordered*/&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sockaddr_in&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kt"&gt;uint8_t&lt;/span&gt;          &lt;span class="n"&gt;sin6_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;sa_family_t&lt;/span&gt;      &lt;span class="n"&gt;sin6_family&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/*AF_INET6*/&lt;/span&gt;
      &lt;span class="n"&gt;in_port_t&lt;/span&gt;        &lt;span class="n"&gt;sin6_port&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/*transport layer port;network byte ordered*/&lt;/span&gt;
      &lt;span class="kt"&gt;uint32_t&lt;/span&gt;         &lt;span class="n"&gt;sin6_flowinfo&lt;/span&gt;       &lt;span class="cm"&gt;/*flow information,undefined*/&lt;/span&gt;
      &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;in6_addr&lt;/span&gt;  &lt;span class="n"&gt;sin6_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/*128-bit IPv6 address;network byte ordered*/&lt;/span&gt;
      &lt;span class="kt"&gt;uint32_t&lt;/span&gt;         &lt;span class="n"&gt;sin6_zero&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="cm"&gt;/*unused*/&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3.值-结果参数&lt;/h3&gt;
&lt;p&gt;当往一个套接字函数传递一个套接字地址结构时，结构以引用形式来传递，也就是说传递的是指向该结构的一个指针，该结构的长度作为一个参数来传递，其传递方向取决于传递方向：是内核到进程，还是进程到内核。&lt;/p&gt;
&lt;p&gt;(1)从进程到内核传递套接字地址结构的函数有3个：bind(),connet()和sendto()。这些函数的一个参数是指向某个套接字地址结构的指针，一个参数是该结构的整数大小，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(2)从内核到进程传递套接字地址结构的函数有4个：accept(),recvfrom(),getsockname()和getpeername()。这4个函数其中的两个参数是指向某个套接字地址结构的指针和指向该地址结构大小的整数变量指针，如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4.字节排序函数&lt;/h3&gt;
&lt;p&gt;简单来说，主机和网络存储整形数据的字节顺序一般是不一样的，我们将他们称之为主机字节序和网络字节序，分别对应内核处理和进程处理。两种字节序之间的互转使用以下4个函数，其对应套接字地址结构（IP地址＋端口号）的字节序的转换。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;netinet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="nf"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;host16bitvalue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;htonl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;host32bitvalue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//返回：网络字节序的值&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="nf"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;host16bitvalue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;host32bitvalue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//返回：主机字节序的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;5.地址转换函数&lt;/h3&gt;
&lt;p&gt;地址转换函数可以在ASCII字符串与网络字节序的二进制值之间转换网际地址。常用的地址转换函数有inet_pton()和inet_ntop()，其中p代表表达（presentation），n代表数值（numeric）。地址的表达格式通常是ASCII字符串，数值格式是存放到 套接字地址结构中的二进制值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;inet_pton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;family&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;strptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addrptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回：1-成功；0-输入不是有效表达式；-1-出错。&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;inet_ntop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;family&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addrptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;strptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//返回：成功则为指向结果的指针，出错为NULL。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;6.字节操作函数&lt;/h3&gt;
&lt;p&gt;字节操作函数用于处理多字节字段，例如bzero()函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;strings.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;bzero&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nbytes&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="socket"></category><category term="newtork programming"></category></entry><entry><title>LTE系统网络架构</title><link href="www.subond.com/pages/2016/05/10/lte-xi-tong-wang-luo-jia-gou.html" rel="alternate"></link><published>2016-05-10T00:00:00+08:00</published><updated>2016-05-10T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-05-10:www.subond.com/pages/2016/05/10/lte-xi-tong-wang-luo-jia-gou.html</id><summary type="html">&lt;p&gt;整个LTE网络是由核心网（EPC,Evolved Packet Core）和接入网（E-UTRAN）组成，如图1-1所示。核心网由许多逻辑节点组成，而接入网只有一个节点，即与用户终端（UE）相连的eNodeB。所有网元都通过接口相互连接，通过对接口的标准化，可以满足众多供应商产品间的互操作性。&lt;/p&gt;</summary><content type="html">&lt;p&gt;整个LTE网络是由核心网（EPC,Evolved Packet Core）和接入网（E-UTRAN）组成，如图1-1所示。核心网由许多逻辑节点组成，而接入网只有一个节点，即与用户终端（UE）相连的eNodeB。所有网元都通过接口相互连接，通过对接口的标准化，可以满足众多供应商产品间的互操作性。&lt;/p&gt;
&lt;p&gt;&lt;img alt="lte-xitong" src="http://on64c9tla.bkt.clouddn.com/20160510lte-xitong.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1-1&amp;nbsp;LTE系统网络架构示意图&lt;/p&gt;
&lt;p&gt;与3G系统相比，LTE系统重新定义了系统网络架构，核心网和接入网之间的功能划分也随之有所变化，针对LTE系统架构，网络功能划分如图1-2所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="lte-xieyi" src="http://on64c9tla.bkt.clouddn.com/20160510lte-xitong-gongneng-xieyi.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1-2&amp;nbsp;LTE系统功能实体划分、协议架构示意图&lt;/p&gt;
&lt;h3&gt;1.接入网&lt;/h3&gt;
&lt;p&gt;LTE接入网E-UTRAN仅由eNodeB组成，网络架构中节点数量减少，网络架构更加趋于扁平化，这种扁平化的网络架构可以有效地降低呼叫时延以及用户数据传输时延。E-UTRAN系统提供用户平面和控制平面的协议，用户平面用户平面包括分组数据汇聚协议（PDCP,Packet Data Convergence Protocol）层、 无线链路层控制（RLC,Radio Link Control）层、媒体接入层（MAC,Medium Access Control）层；控制平面包括无线资源控制（RRC,Radio Resource Control）层。eNodeB之间通过X2接口进行连接，通过S1接口与EPC连接，具体来说就是，通过S1-MME接口连接到MME，通过S1-U接口连接到S-GW。eNodeB与UE间的协议为接入层（AS）协议。&lt;/p&gt;
&lt;p&gt;eNodeB具有如下功能：&lt;/p&gt;
&lt;p&gt;（1）无线资源管理相关的功能，如无线资源承载控制、接纳控制、连接移动性管理、上/下行动态资源分配/调度等；&lt;br&gt;
（2）IP头压缩与用户数据流的加密；&lt;br&gt;
（3）UE附着时的MME选择。由于eNodeB可以与 多个MME/S-GW之间存在S1接口相连，因此，UE初始接入到网络时，需要选择一个MME进行附着;&lt;br&gt;
（4）寻呼信息的调度和传输；&lt;br&gt;
（5）广播信息的调度和传输；&lt;br&gt;
（6）用于移动和调度的测量和测量报告的配置。  &lt;/p&gt;
&lt;h3&gt;2.核心网&lt;/h3&gt;
&lt;p&gt;核心网负责对用户终端的全面控制和有关承载的建立。EPC的主要逻辑节点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分组数据网关（P-GW,Packet Data Network Gateway）  &lt;/li&gt;
&lt;li&gt;服务网关（S-GW,Serving Gateway）  &lt;/li&gt;
&lt;li&gt;移动性管理实体（MME, Mobility Management Entity）  &lt;/li&gt;
&lt;li&gt;归属签约用户服务器（HSS,Home Subscriber Server）  &lt;/li&gt;
&lt;li&gt;策略及计费规则功能（RCPF,Policy and Charging Rules Function）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EPC逻辑主要节点的功能，下面详细介绍。&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;P-GW：分组数据网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;P-GW提供与外部分组数据网络的连接，是主要的移动性处理节点。P-GW负责用户IP地址分配和QoS保证，并根据PCRF规则进行基于流量的计费。一个UE可能和多个P-GW相连 ，P-GW同时负责UE IP地址的分配。P-GW为保证比特率承载提供QoS保证。另外，P-GW可以通过一系列不同的接口，成为其他3GPP网络或非3GPP网络。&lt;/p&gt;
&lt;p&gt;(2) &lt;strong&gt;S-GW：服务网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;S-GW通过S1-U接口来实现用户数据包的路由和转发。实现的功能主要有数据通道、IP头压缩处理、用户数据流加密、针对移动性的用户面的切换、寻呼时用户面数据包的终止。当用户在eNodeB之间移动时，S-GW作为数据承载的本地移动性管理实体。当用户处于空闲状态时， S-GW将保留承载信息并临时把下行数据存储在缓存区里，以便当MME开始寻呼UE时重新建立承载。同时，在与其他3GPP技术如GPRS和UMTS等交互工作时，它可以作为“&lt;strong&gt;移动性管理锚点&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;(3) &lt;strong&gt;MME：移动性管理实体&lt;/strong&gt;
MME是处理UE和核心网络信令交互的控制节点。在UE和核心网络间所执行的协议栈成为非接入层协议（NAS）。MME具有如下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寻呼信息分发。MME负责将寻呼信息按照一定的原则分发到相关的eNodeB;    &lt;/li&gt;
&lt;li&gt;安全控制;  &lt;/li&gt;
&lt;li&gt;空闲状态的移动性管理;  &lt;/li&gt;
&lt;li&gt;SAE（系统架构演进）承载控制;  &lt;/li&gt;
&lt;li&gt;非接入层信令的加密和完整性保护。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(4) &lt;strong&gt;HSS：归属签约用户服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HSS作为用户的集中签约管理数据库，存放了用户的EPS网络签约信息，并完成对UE的位置登记管理，以及结合AUC（鉴权中心）网元完成用户鉴权参数管理，并通过S6a接口下发给 MME完成对UE的鉴权即安全功能。&lt;/p&gt;
&lt;p&gt;(5) &lt;strong&gt;PCRF：策略及计费规则功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PCRF网元是SAE架构中提供集中策略和计费控制的网元。PCRF主要完成策略控制的决定功能及基于不同IP流的计费控制功能。因此，PCRF要结合PCEE（Policy and Charging Enforcement Function）网元 检测后上报的不同业务类型来进行QoS及计费策略方面的决策，并通过Ｇx接口将策略下发给PCEF网元去执行。&lt;/p&gt;
&lt;h3&gt;3.主要业务接口&lt;/h3&gt;
&lt;h3&gt;S1接口&lt;/h3&gt;
&lt;p&gt;S1接口是MME/S-G网关和eNodeB之间的接口。S1接口又可以分为两个接口，一个用于用户平面S1-U，一个用于控制平面S1-MME。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户平面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;S1-U接口用于提供eNodeB与S-GW网元之间用户数据传输功能，其协议栈如图3-1所示。S1-U的传输网络层基于IP传输，UDP/IP协议之上采用GTP-U（GPRS Tunnelling Protocol for User Plane：GPRS用户平面隧道协议）来传输S-GW与eNodeB之间的用户平面PDU。&lt;/p&gt;
&lt;p&gt;&lt;img alt="s1-u" src="http://on64c9tla.bkt.clouddn.com/20160510s1-u-xie-yi-zhan.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图3-1&amp;nbsp;S1-U接口协议栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制平面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;S1-MME也是基于IP传输的，不同的是控制平面在IP层的上面采用SCTP（Stream Control Transmission Protocol：流控制传输协议），为无线网络层信令消息提供可靠的传输，其协议栈如图3-2所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="s1-mme" src="http://on64c9tla.bkt.clouddn.com/20160510s1-mme-xie-yi-zhan.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图3-2&amp;nbsp;S1-MME接口协议栈&lt;/p&gt;
&lt;h3&gt;X2接口&lt;/h3&gt;
&lt;p&gt;X2接口是eNodeB与eNodeB之间的接口，采用了与S1接口一致的原则，其用户平面协议接口与控制平面协议接口均与S1接口类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户平面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;X2接口是eNodeB与eNodeB之间的接口，采用了与S1接口一致的原则，其用户平面协议接口与控制平面协议接口均与S1接口类似。&lt;/p&gt;</content><category term="architecture"></category><category term="lte"></category></entry><entry><title>Git学习手记</title><link href="www.subond.com/pages/2016/04/29/git-xue-xi-shou-ji.html" rel="alternate"></link><published>2016-04-29T00:00:00+08:00</published><updated>2016-04-29T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-04-29:www.subond.com/pages/2016/04/29/git-xue-xi-shou-ji.html</id><summary type="html">&lt;p&gt;Git版本控制功能很强大，作为程序猿必修掌握。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;一、基础篇&lt;/h2&gt;
&lt;h3&gt;指令介绍&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git config --global user.name &lt;span class="s2"&gt;&amp;quot;username&amp;quot;&lt;/span&gt;      &lt;span class="c1"&gt;#配置仓库参数，作为一个标志&lt;/span&gt;
$ git config --global user.email &lt;span class="s2"&gt;&amp;quot;useremail&amp;quot;&lt;/span&gt;    &lt;span class="c1"&gt;#配置仓库参数，作为一个标志&lt;/span&gt;
$ git init                      &lt;span class="c1"&gt;#把当前目录变成git可管理的仓库&lt;/span&gt;
$ git add files          &lt;span class="c1"&gt;#添加文件到暂存区&lt;/span&gt;
$ git diff file          &lt;span class="c1"&gt;#查看文件的修改内容&lt;/span&gt;
$ git commit -m &lt;span class="s2"&gt;&amp;quot;提交说明信息&amp;quot;&lt;/span&gt;   &lt;span class="c1"&gt;#提交文件到仓库&lt;/span&gt;
$ git status                    &lt;span class="c1"&gt;#获取当前仓库中文档的状态&lt;/span&gt;
$ git log                       &lt;span class="c1"&gt;#查看历史记录&lt;/span&gt;
$ git log -pretty&lt;span class="o"&gt;=&lt;/span&gt;oneline       &lt;span class="c1"&gt;#单行显示历史信息&lt;/span&gt;
$ git reflog                    &lt;span class="c1"&gt;#显示版本号&lt;/span&gt;
$ git checkout -- file          &lt;span class="c1"&gt;#取出文件&lt;/span&gt;
$ git remote add origin &amp;lt;仓库地址&amp;gt;    &lt;span class="c1"&gt;#添加远程仓库地址&lt;/span&gt;
$ git push origin &amp;lt;分支名1&amp;gt;          &lt;span class="c1"&gt;#推送本地内容到远程仓库分支1&lt;/span&gt;
$ git pull origin &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
                                  &lt;span class="c1"&gt;#取回远程主机某个分支，并与本地指定分支合并&lt;/span&gt;
$ git clone &amp;lt;仓库地址&amp;gt;               &lt;span class="c1"&gt;#克隆远程仓库到本地仓库&lt;/span&gt;
$ git remote            &lt;span class="c1"&gt;#查看远程仓库信息&lt;/span&gt;
$ git remote -v         &lt;span class="c1"&gt;#查看远程仓库详细信息&lt;/span&gt;
$ git remote add origin &amp;lt;仓库地址&amp;gt;    &lt;span class="c1"&gt;#添加远程仓库地址&lt;/span&gt;
&lt;span class="c1"&gt;# 如果需要修改远程仓库地址，先删除地址，再添加&lt;/span&gt;
$ git remote rm origin
$ git remote add origin &amp;lt;your_url&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;版本回退&lt;/h3&gt;
&lt;p&gt;git reset --hard 版本号(即commit_id)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git reset --hard HEAD^      &lt;span class="c1"&gt;#回退至上一版本&lt;/span&gt;
$ git reset --hard HEAD^^     &lt;span class="c1"&gt;#回退至上上版本&lt;/span&gt;
$ git reset --hard HEAD~10    &lt;span class="c1"&gt;#回退至前10个版本&lt;/span&gt;
$ git reset --hard commit_id  &lt;span class="c1"&gt;#结合git reflog;git log使用&lt;/span&gt;
                            &lt;span class="c1"&gt;#git log可以查看提交历史，以便确定回退到哪个版本;&lt;/span&gt;
                            &lt;span class="c1"&gt;#git reflog可以查看命令历史，以便确定回到未来的哪个版本&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;分支操作&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git branch                &lt;span class="c1"&gt;#查看分支&lt;/span&gt;
$ git checkout &amp;lt;分支名1&amp;gt;       &lt;span class="c1"&gt;#切换至分支名1&lt;/span&gt;
$ git checkout -b &amp;lt;分支名1&amp;gt;  &lt;span class="c1"&gt;#创建并切换至分支名1&lt;/span&gt;
$ git merge &amp;lt;分支名1&amp;gt;        &lt;span class="c1"&gt;#合并分支名1至当前分支&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;提交文件步骤&lt;/h3&gt;
&lt;p&gt;第一步：&lt;code&gt;git add file_name&lt;/code&gt;,提交文件到暂存区(Index)&lt;/p&gt;
&lt;p&gt;第二步：&lt;code&gt;git commit -m "message about file"&lt;/code&gt;,提交文件到本地仓库(Repository)&lt;/p&gt;
&lt;p&gt;第三步：&lt;code&gt;git push origin master&lt;/code&gt;,提交文件到远程仓库master分支(Remote)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 第一次推送至master分支，需要使用-u参数，即&lt;code&gt;git push -u origin master&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="git-mechism" src="http://on64c9tla.bkt.clouddn.com/20160429gitcaozuo.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1 Git基本操作示意图&lt;/p&gt;
&lt;p&gt;几个名词解释：&lt;/p&gt;
&lt;p&gt;Workspace:工作区&lt;br&gt;
Index：暂存区&lt;br&gt;
Repository：仓库区(本地仓库)&lt;br&gt;
Remote：远程仓库  &lt;/p&gt;
&lt;h2&gt;二、进阶篇&lt;/h2&gt;
&lt;h3&gt;分支管理&lt;/h3&gt;
&lt;p&gt;一般而言，主分支master分支是非常稳定的版本，可以用来直接发布，一般情况下不允许直接在上面进行修改。一般都是新建一个dev分支，在dev分支上进行修改操作，工作完成后可合并到主分支master上。其流程一般如下：
1.创建一个dev分支；&lt;br&gt;
2.修改文件内容；&lt;br&gt;
3.添加到暂存区；&lt;br&gt;
4.切换至主分支(msater)； &lt;br&gt;
5.合并dev分支；&lt;br&gt;
6.查看历史记录。  &lt;/p&gt;
&lt;p&gt;注意:合并分支时，git一般使用“Fast Forward”模式，在这种模式下，删除分支后，会丢掉分支信息。为了保证可以随时查看分支信息，合并时可使用命令git merge -no-ff -m "注释信息" dev&lt;/p&gt;
&lt;h3&gt;Stach功能介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;工作过程中，我们一般在自己的分支上修改和调试代码，如果临时接到通知需要修改某个BUG问题，而且自己的工作还需要一段时间才能完成， 而修复BUG问题可能只需要一点时间，此时我们就需要使stash功能。”git stash“通俗地讲就是把当前的工作现场”隐藏起来“，待现场回复后可继续 工作。具体来说就是先使用’git stash'将当前未提交到本地（或服务器）的代码推入git的栈中，这时我们的工作区和上一次提交的内容是一样，所以可以放心的修复BUG问题，等到 修复完成并提交到服务器之后，再使用'git stash apply'将以前的工作应用回来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git stash       &lt;span class="c1"&gt;#备份当前分支的工作区内容，保证工作区内容和上一次提交的内容一致，同时，将当前的工作内容压入git栈中&lt;/span&gt;
$ git pop         &lt;span class="c1"&gt;#从git栈中读取最近一次保存的内容，恢复工作区的相关内容&lt;/span&gt;
$ git stash list  &lt;span class="c1"&gt;#显示git栈中所有备份，可以利用列表选择从哪恢复内容&lt;/span&gt;
$ git stash apply &amp;lt;版本号&amp;gt;   &lt;span class="c1"&gt;#将制定版本号的内容恢复至当前工作区，配合git stash list使用&lt;/span&gt;
$ git stash clear           &lt;span class="c1"&gt;#清空git栈&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;三、gitbook使用指南&lt;/h2&gt;
&lt;p&gt;gitbook的使用方法和git基本类似，其修改记录，发布版本等相关操作均可参考上面的git指令，略有不同，下面详细介绍：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 初始化书记目录&lt;/span&gt;
$ gitbook init
&lt;span class="c1"&gt;# 编译图书，可在本地查看&lt;/span&gt;
$ gitbook serve
&lt;span class="c1"&gt;# 克隆远程图书到本地&lt;/span&gt;
$ git clone https://git.gitbook.com/user_name/book_name.git
&lt;span class="c1"&gt;# 添加文件&lt;/span&gt;
$ git add file_name
&lt;span class="c1"&gt;# 提交修改记录&lt;/span&gt;
$ git commit -m &lt;span class="s2"&gt;&amp;quot;sth about your changes&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# 添加图书的远程地址&lt;/span&gt;
$ git remote add gitbook https://git.gitbook.com/user_name/book_name.git
&lt;span class="c1"&gt;# 发布图书至远程仓库&lt;/span&gt;
$ git push -u gitbook master  &lt;span class="c1"&gt;#第一次使用-u参数，之后可以不用加-u参数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="git"></category><category term="gitbook"></category></entry><entry><title>利用Pelican+Github pages搭建个人博客</title><link href="www.subond.com/pages/2016/04/24/pelican-github-chuang-jian-blog.html" rel="alternate"></link><published>2016-04-24T00:00:00+08:00</published><updated>2016-04-24T00:00:00+08:00</updated><author><name>subond</name></author><id>tag:None,2016-04-24:www.subond.com/pages/2016/04/24/pelican-github-chuang-jian-blog.html</id><summary type="html">&lt;p&gt;本教程基于pelican博客引擎和github page的功能，实现个人博客搭建。&lt;/p&gt;</summary><content type="html">&lt;p&gt;说明：本教程使用的系统平台为ubuntu16.04。&lt;/p&gt;
&lt;h2&gt;Github pages&lt;/h2&gt;
&lt;p&gt;注册Github，并创建一个名为username.github.io的版本库。注意username为自己的用户名。&lt;/p&gt;
&lt;h2&gt;配置本地环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安装Pelican和Markdown&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pelican是一套开源的使用Python编写的博客静态生成，可以添加文章和创建页面，可使用Markdown，reStructuredText和AsiiDoc的格式来书写，同时使用Disqus评论系统，支持 RSS和Atom输出，插件，主题，代码高亮等功能。&lt;/p&gt;
&lt;p&gt;安装Pelican有很多方法，一般采用python的包管理器pip进行安装。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo apt-get install python-pip
$ sudo pip install pelican
$ sudo pip install markdow
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;创建博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建博客目录，然后使用快速生成，具体如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mkdir blog
$ &lt;span class="nb"&gt;cd&lt;/span&gt; blog
$ pelican-quickstart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行pelican-quicstart命令后，会提示博客的配置选项，根据提示操作即可，除必填项之外，其他选择默认即可。如果有需要可以在之后的pelicanconf.py文件进行修改。完成之后，会出现Pelican框架，如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bolg
&lt;span class="p"&gt;|&lt;/span&gt;__content             &lt;span class="c1"&gt;#存放输入的Markdown文件&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__output              &lt;span class="c1"&gt;#存放最终生成的静态博客网页文件&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__develop_server.sh   &lt;span class="c1"&gt;#本地测试服务器文件&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__Makefile            &lt;span class="c1"&gt;#管理博客的Makefile&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__pelicanconf.py      &lt;span class="c1"&gt;#博客配置文件&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;__publishconf.py      &lt;span class="c1"&gt;#发布文件，可删除&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;撰写博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成博客主题搭建后，使用Markdown语法书写博客，完成后保存在content目录下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;     &lt;span class="c1"&gt;//文章名字&lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2016&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;04&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;
&lt;span class="n"&gt;Category&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Python&lt;/span&gt;          &lt;span class="c1"&gt;//文章分类&lt;/span&gt;
&lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;publishing&lt;/span&gt; &lt;span class="c1"&gt;//文章标签&lt;/span&gt;
&lt;span class="n"&gt;Slug&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt;       &lt;span class="c1"&gt;//html文件名&lt;/span&gt;
&lt;span class="n"&gt;Author&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Alexis&lt;/span&gt; &lt;span class="n"&gt;Metaireau&lt;/span&gt;  &lt;span class="c1"&gt;//作者信息&lt;/span&gt;
&lt;span class="n"&gt;Summary&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Short&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;feeds&lt;/span&gt;  &lt;span class="c1"&gt;//文章摘要&lt;/span&gt;

&lt;span class="c1"&gt;//文章正文&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成之后，在blog目录下，执行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ make html
$ ./develop_server.sh start &lt;span class="m"&gt;8000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之后，在浏览器中输入http://localhost:8000 即可看到博客效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发布博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前我们已经在Github上创建了仓库，现在我们就将本地文件搬到远程仓库中，进入output目录下，具体指令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git init
$ git add .
$ git remote add origin https://github.com/username/username.github.io
$ git pull origin master
$ git commit -m &lt;span class="s2"&gt;&amp;quot;First update&amp;quot;&lt;/span&gt;
$ git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成博客发布后，访问http://username.github.io 即可。&lt;/p&gt;
&lt;h2&gt;附：Git简易教程&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git init                    &lt;span class="c1"&gt;#把当前目录变成git可管理的repository&lt;/span&gt;
$ git add &amp;lt;files&amp;gt;             &lt;span class="c1"&gt;#添加文件至缓存区&lt;/span&gt;
$ git commit -m &lt;span class="s2"&gt;&amp;quot;message&amp;quot;&lt;/span&gt;     &lt;span class="c1"&gt;#提交文件&lt;/span&gt;
$ git remote add origin &amp;lt;server&amp;gt;       &lt;span class="c1"&gt;#添加远程服务器&lt;/span&gt;
$ git remote set-url origin &amp;lt;server&amp;gt;   &lt;span class="c1"&gt;#修改远程服务器地址&lt;/span&gt;
$ git push origin master      &lt;span class="c1"&gt;#推送到远程服务器&lt;/span&gt;
$ git status    &lt;span class="c1"&gt;#查看当前各文件状态&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Pelican的几点说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;pelican-theme&lt;/code&gt;命令可以安装不同的博客主题风格，&lt;code&gt;-v&lt;/code&gt;可查看安装路径；使用&lt;code&gt;pelican-theme&lt;/code&gt;生成主题后，会在博客目录下生成一个&lt;code&gt;theme&lt;/code&gt;的文件夹(这是依据你所选的主题风格生成的文件，无需修改)。若要修改某个特定主题，需在主题的默认安装路径中进行修改，修改后重新导入主题即可。&lt;/li&gt;
&lt;/ol&gt;</content><category term="pelican"></category><category term="blog"></category></entry></feed>