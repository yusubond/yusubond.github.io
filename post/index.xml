<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on subond&#39;s blog</title>
    <link>http://www.subond.com/post/</link>
    <description>Recent content in Posts on subond&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 11 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://www.subond.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2023, 启航</title>
      <link>http://www.subond.com/post/01letter/</link>
      <pubDate>Sat, 11 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/01letter/</guid>
      <description>你好，我是 Kevin，见字如面，这是为你寄来的第 1 封信。
新年新开始 22年6月份我重拾了几年前的博客和写作，23年为了更好地将写作这件事做下去，重新找回了自己的公众号「一个人的活法」，并正式更名为「凯文的生活随想」。新的一年，我准备在这里书写自己对于生活，阅读，学习，工作以及理财的思考和实践。
古时候，鸿雁作为传递书信的使者，取其含义，我把这部分写作命名为「鸿雁传书」，本质上就是 Newsletter。
为什么是它 答案是为了更好的表达和思考。写作可以说是普通人锻炼思考和逻辑的最好方式，当然还有很多其他益处，后面我会单独写一篇，今天先按下不表。
今天主要讲一下书写的形式和内容。没有一种形式适合所有人，找到适合自己的才是最好的。
我的核心诉求就是表达，提高文字组织能力，所以选择了 Newsletter 的这种形式，每周一篇。
书信内容主要围绕生活展开，以我感兴趣的领域方向为主，书写自己的所思所想。这样既可以督促自己保证一定的输入和输出，同时又可以兼顾生活和工作，不会有很大压力。
其次，对于需要长篇阐述的话题，我依然会写作长文，只是不定期更新。
鸿雁传书会发布哪些内容 对生活，工作，技术的思考和成长 对投资理财的学习时间，尤其是家庭理财 对运动，身体健康的探索 我读过的好书和文章推荐 我在其他社交媒体上的有意义的输出 总之，鸿雁传书就是以自己的视角去发现和认识这个世界，不求深刻和全面，但求有所思考和收获。
谢谢你的关注，让我们以书信会友。
如何订阅 「鸿雁传书」每周一发布，同步更新在微信公众号和博客。
本周日常 上周休假在家，这周才正式复工，到公司第一件事就是深度清理键盘，作为程序员，上战场必须擦亮自己的武器🎉
编程创造美好未来~
对了，文章的排版采用也树开发的一款极简公众号排版工具，欢迎体验使用~</description>
    </item>
    
    <item>
      <title>互斥锁与读写锁的性能对比</title>
      <link>http://www.subond.com/post/005_golang_mutex/</link>
      <pubDate>Thu, 29 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/005_golang_mutex/</guid>
      <description>互斥锁与读写锁 Go 语言标准包 sync 中提供了两种锁，互斥锁 Mutex 和读写锁 RWMutex ，那两者有什么样的区别和差异呢？
互斥锁（sync.Mutex) 互斥意味着加锁的多个代码块不可能同时执行。只有抢到锁的 goroutine 才可以执行，其他 goroutine 只能等待（阻塞在 Lock()方法）锁释放后，获得互斥锁才能继续执行。
互斥锁提供了两种操作：
Lock()，即上锁 Unlock()，即解锁 通常我们将Unlock() 放到 defer函数中执行，确保退出代码块时一定会解锁。
读写锁（sync.RWMutex） 读写锁是为了解决这样的场景：只要保证写操作安全就可，读操作可以并行执行，从而提高读的效率。
读写锁也称为 多读单写锁，它包括读锁和写锁，读写可以同时执行，但是写锁是互斥的。通常有下面三中场景：
在没有写锁的情况下，读锁是不互斥的，允许多个同时执行 写锁之间是互斥的，只能一个写锁工作，其他写锁阻塞 读锁和写锁是互斥的，如果存在读锁，写锁阻塞；如果存在写锁，读锁阻塞 从这三种场景可以看到，读写锁主要是为了解决读多写少的性能问题。</description>
    </item>
    
    <item>
      <title>go defer的调用顺序</title>
      <link>http://www.subond.com/post/golang_defer/</link>
      <pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/golang_defer/</guid>
      <description>Golang Defer的调用顺序 1、在defer语句声明时进行估值 我们都知道go中defer是延时调用，一般在return语句结束后调用。但是如果defer语句中包含变量呢，那变量该如何计算？
看这样一个例子
1 2 3 4 5 6 7 8 9 10 11 12 13 14 type ( su struct {} ) func (s *su) add(i int) *su { fmt.</description>
    </item>
    
    <item>
      <title>Go字符串拼接性能对比</title>
      <link>http://www.subond.com/post/006_golang_string_join/</link>
      <pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/006_golang_string_join/</guid>
      <description>Go字符串拼接性能对比 Go 语言中提供了基础数据结构类型 string，在实际使用中我们经常遇到将字符串拼接的问题，即需要将多个字符串拼接在一起，形成新的字符串。那么 go 语言有哪些方式可以完成字符串拼接，以及它们的性能如何，我们一起研究下。
1. 操作符+ 最简单的一种方式就是通过操作符+来完成拼接，例如下面这段小代码，字符串 s3 就是直接将s1和s2拼接在一起，其值等于foobar
1 2 3 s1 := &amp;#34;foo&amp;#34; s2 := &amp;#34;bar&amp;#34; s3 := s1 + s2 2. 通过strings.join函数 strings 库中的strings.join 函数可以拼接多个字符串，并且还能指定字符串之间的分隔符。</description>
    </item>
    
    <item>
      <title>First Post</title>
      <link>http://www.subond.com/post/first-post/</link>
      <pubDate>Tue, 13 Sep 2022 17:34:32 +0800</pubDate>
      
      <guid>http://www.subond.com/post/first-post/</guid>
      <description>Hi is subond~</description>
    </item>
    
    <item>
      <title>Go Slice性能与技巧</title>
      <link>http://www.subond.com/post/003_golang_array_and_slice/</link>
      <pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/003_golang_array_and_slice/</guid>
      <description>Go中Slice性能与技巧 一个数组中的所有元素均存放在此数组的直接部分，一个切片的所有元素均存放在此切片的间接部分。
slice是Go语言中一个重要的数据类型，而且很好用，但是也有一些坑，需要我们对slice有深入的理解。
slice跟数组array很类似，可以使用下标进行访问，如果越界则会产生panic。
1、slice到底是个啥 为了更好地理解切片类型和和切片值，我们需要对切片内部结构有一个基本的认识。在Go语言中，切片类型的内部定义大致如下：
1 2 3 4 5 6 // runtime/slice.go type slice struct { array unsafe.Pointer // 引用着底层存储在间接部分上的元素 len int // 长度 cap int // 容量 } 通过定义我们可以看到slice有三个属性，分别：</description>
    </item>
    
    <item>
      <title>Go 空struct的使用技巧</title>
      <link>http://www.subond.com/post/002_golang_struct_skill/</link>
      <pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/002_golang_struct_skill/</guid>
      <description>Go 空struct的使用技巧 1、空struct{}不占用内存空间 Go语言中，使用unsafe.Sizeof()可以计算一个数据类型实例所占用的字节数。
1 2 3 4 5 6 7 8 9 10 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { fmt.Printf(&amp;#34;struct{} %d\n&amp;#34;, unsafe.Sizeof(struct {}{})) // struct{} 0 } 通过上面的结果可以看到，Go中空结构体struct{}是不占用内存空间。</description>
    </item>
    
    <item>
      <title>Go Struct内存对齐</title>
      <link>http://www.subond.com/post/001_golang_struct_memory_alignment/</link>
      <pubDate>Wed, 07 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/001_golang_struct_memory_alignment/</guid>
      <description>Go Struct内存对齐 1 为什么需要考虑内存对齐 CPU访问内存时，并不是逐个字节访问，而是以字长来访问。字长是指在同一时间内处理二进制数的位数。32位系统的字长为32位，即4字节，64位系统的字长为64位，即8字节。
CPU以字长访问内存，可以减少访问次数，增加吞吐量。以32位系统为例，访问一个8字节的数据，一次读取4个字节，只需要访问2次。
2 如何计算结构体的内存空间 在Go中，可以使用unsafe.Sizeof()来计算一个数据类型实例所占用的内存大小。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Person struct { name string age int address string } func main() { var s1 int var str string var f1 float64 var p Person fmt.</description>
    </item>
    
    <item>
      <title>25岁应该学到的25堂课</title>
      <link>http://www.subond.com/post/25lessonsbefore25/</link>
      <pubDate>Sat, 08 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/25lessonsbefore25/</guid>
      <description>作者：Andrew Ferebee
原文：25 Lessons I Wish I Had Learned Before 25
几个月前我才30岁。我简直不敢相信我写的那个&amp;hellip;&amp;hellip;
回顾我的20年代，我希望我能学到无数的课程，这样就可以让我拯救我多年的痛苦，心痛与沮丧。对于今天的我，我十分感激，但这并不能改变我过去十年的生活。但是，如果我重新做一遍，知道我今天所知道的，我会告诉20岁的自己(my 20-year-old self)有成千上万的事情。
以下是我希望自己25岁之前应该学到的25堂课：
1. 自力更生[Be Self Reliant ] 学会在没有他人的帮助下，自己帮助自己并追求自己想要的东西。这才是真正力量的所在。没有人会来拯救你。你必须接管自己的风帆，掌握自己的命运。
没有人会来拯救你，越早掌握自己的命运，你就能越早完全按照你想要的方式生活。你的父母，朋友和政府都不会给你你想要的生活。
如果你想按照自己的意愿生活，那么就要自力更生并实现目标。
2. 照顾好自己的健康[Take Care of Your Health] 如果你在20岁时养成良好的健康习惯，你的余生将会更加容易。我知道很多30岁的人看起来像40岁，因为他们没有照顾好自己。我很幸运能够在20多岁的时候接受运动疗法和全食物饮食，但是我也在深夜，因为过量饮酒和缺乏运动而浪费了很多年。</description>
    </item>
    
    <item>
      <title>高创造性人士的7个习惯</title>
      <link>http://www.subond.com/post/create_habits/</link>
      <pubDate>Fri, 03 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/create_habits/</guid>
      <description>古希腊人认为，创造力就是这种神圣的伴随精神，它源于一些遥远而不可知的原因。他们称这些灵魂守护进程。罗马人也有类似的想法，但称精神是天才。
几个世纪后，没有太大变化。唯一的区别是我们不再将创造力归功于神圣的灵魂，而是归于特殊的个体。我们认为只有贝多芬，毕加索和莫扎特才具有创造性的天才。
事实上这不是真的。
今天，我们解构和分析这个最难以捉摸的过程。我们逐渐明白，任何人都可以使用特定的行为和心态来达到预期的结果。
以下是高创造性人士的七种习惯。
1.像艺术家一样偷窃[Steal Like An Artist] 有抱负的创意人必须首先认识到这一事实。我们只需要转向Austin Kleon的书《Steal Like a Artist 》来学习：
“一个好的艺术家理解的是，没有任何东西来自任何地方。所有创造性工作都建立在以前的基础上。没有什么是完全原创的。”
人们必须意识到，一件作品的想法和灵感来自许多地方。每个新想法都只是混搭或以前想法的混合。这就是为什么Kleon写道，“当人们称之为&amp;rsquo;原创&amp;rsquo;时，&amp;lsquo;十之八九，他们只是不知道参考文献或涉及的原始资料。”
这位优秀的艺术家尽可能地模仿他人的风格。伟大的艺术家从他人的作品中选择元素，并将其融入他自己的影响中。他非常有品位，知道正确的融合会创造出独特的东西，虽然不是完全原创的。
所以学会像艺术家一样偷窃，整个世界都在争夺。
2.永远在研究[Always Be Researching] 要找到值得偷窃的东西，必须找到合适的地方。
输入有助于输出，不能绕过那个。消耗的信息质量决定了人们将要生产的工作质量。在噪声经常淹没信号的世界中，找到最好的想法通常很困难。
有两种方法可以解决这个问题。第一个是Kleon所谓的分支，这对于探索一个想法的变化很有用。
“嚼一个思想家。研究有关该思想家的所有知识。然后找三个他爱的人，找出他们的一切。尽可能多地重复此操作。尽可能地爬上树的最顶端。“
这不是筛选有价值想法的唯一方法。创意源于创造以前从未见过的东西。这就是为什么畅销书作家Ryan Holiday在他怀疑时会转向经典。
经典作品是之所以称为“经典”的原因之一就是——他们经受住了时间的考验。斯多葛主义的哲学可以追溯到古希腊人，但是Ryan Holiday在他的书《 Ego Is The Enemy 》和《 the Obstacle is the Way》中展示了这些想法是如何相关的。他没有提出这些想法; 他应用了它们。</description>
    </item>
    
    <item>
      <title>年轻的自信与成熟的笃定</title>
      <link>http://www.subond.com/post/confiden_and_certainty/</link>
      <pubDate>Sun, 19 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/confiden_and_certainty/</guid>
      <description>当一个年轻人开始逐渐摆脱盲目自信的时候，脚步更加坚定的时候，他迎来的是更加成熟的笃定。
今天吴晓波频道（微信号公众号：wuxiaobopd）推送了一篇文章，叫做《月入2万，95后还觉得自己活得不如狗？》，文中提到极光大数据发布的《95后群体画像研究报告》，于是便找来看了一番。其中，让我感兴趣的部分是如何看待比自己早生/晚生10年的一代人。
数据表明，相比其他年龄群体，95后对85后的评价普遍偏低，同样对“晚辈”（05后）的评价也不高，但是对于自己的评价，42.7%的人认为自己重诚信，尊老爱幼，乐于助人、爱国、孝顺、有礼貌的爱国青年。
这种种数据表明，95后是自信的一代。当然，这并不是没有任何理由。作为90后，我们生活在长期和平的年代，1978年改革开放后，无论是城市还是农村，生活水平都有不同程度的提高。我们的父母都是改革开放的见证者，等到我们出生的时候，温饱问题基本上解决了（除了少数偏远山村）。与此同时，90s年代，又是信息技术发展的快速时期，使我们这一代从小就接触到电脑，互联网。这样良好的成长环境使我们更加自信，
但是，我想说的是，自信并不属于95后，而是属于年轻人。纳什·沃夏尔·硕得提出的&amp;quot;社会三定律&amp;quot;讲的就是这个道理：
一，任何比我早出生10年及以上的人都是裹步不前的老顽固。
二，任何出生时间和我相差10年以内的人都是这个社会的精英，中流砥柱。
三，任何比我晚出生10年及以上的人都是无可救药垮掉的一代。 ​​​​
所以，自信永远属于年轻人，自命不凡的年轻人。年少无知，无知即无畏。初生牛犊不怕虎，说的正是年轻人。
正如，当一个人开始怀念少年时光的时候，他的少年时代就已经一去不复返了，此时此刻的他俨然成了一个有责任的青年人。同样，当一个年轻人开始逐渐摆脱盲目自信的时候，脚步更加坚定的时候，他迎来的是更加成熟的笃定。</description>
    </item>
    
    <item>
      <title>关于找工作的两个基本事实</title>
      <link>http://www.subond.com/post/two_fundamental_truths/</link>
      <pubDate>Wed, 08 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/two_fundamental_truths/</guid>
      <description>对于应届毕业生而言，由于缺乏工作经验，对工作环境缺少了解，往往不能够很快地进入工作状态。这时候，如果能够获得一份不错的实习机会，对今后的工作可以说是大有裨益。
一份良好的实习不仅可以帮助我们了解真实的工作环境和氛围，而且可以帮助我们调整自己的心态，逐步从校园生活过渡到社会生活。同时，如果在实习工作中培养了自己良好的工作习惯和职业操守，对于技术类实习生而言，还能够提高自己的技术水平，那自然是更好的事情了。
那么，对于找实习，甚至是找工作来说，我觉着有两个基本事实需要求职者明白，并做好的相应的应对措施。
事实一：工作机会总是有的，只是合适人却不常有。
作为接受过高等教育的应届生，社会上的工作机会总是有的，所以，不要担心工作问题，一定要注意自己作为求职者的自信。除了没有工作经验，你没有比任何人差，甚至有些时候，没有工作经验还是好事。没有工作经验，在工作中往往更有利于发挥你的创新能力，也更有职业的可塑性的可能。
“千里马常有，而伯乐不常有”。对于工作，也是同样的道理。几乎没有人能够完全匹配一项工作。对于某些关键岗位来说，合适的人就更加少了，为了找的这样的人，公司也往往不惜花费重金。
因此，与其找工作，不如让工作来找你，让自己成为那个最合适的人选，做到主动择业。
事实二：好的工作机会是有限的，就像社会资源有限一样。
那么，什么是好的工作机会？我想应该具备以下两个特征：
工作内容具有一定程度的挑战性。作为求职者，求职过程中我们往往寻找那些与我们能力相匹配的工作岗位。但是，事实却是具有一定挑战性的工作往往更容易激发我们的工作热情，发掘个人的工作能力。不然，一份工作就变成毫无意义的 重复性劳动。 一份好的工作，应该是下一份工作的基础。现代社会的发展非常迅速，几乎没有人能够一生只在一个岗位上工作。既然是这样，那么现在的工作应该而且必须成为我们下一次择业的基础。因此，设想自己3-5年后的工作，然后反推。即如果自己想要获取那样的工作，应该具备什么的工作能力，专业素质等，并依次为依据作为这次工作应该着重培养的能力。如果，这份工作能够满足未来的期望，那么它就是一个好工作。这样想来，好工作就是有限的资源。 对于公司而言，面向应届生招聘也往往看重应届生对基础知识的把握。而对应届生而言，大多数人所具备的专业知识又是相对同质化的，而且，简单的30分钟左右的面试，也不能很好地评估一个人所具备的能力。所以说，一份你能胜任的好工作，意味着你的同学也同样可以胜任。但是，好机会的名额却是有限的。那么，想要获得这样的好工作，就要抢占先机，尽早地拿到这个名额。所以，有些时候，并不是你不适合这个工作，而是你来晚了。对这一点，你要有心理准备。</description>
    </item>
    
    <item>
      <title>初入职场</title>
      <link>http://www.subond.com/post/starting_jog/</link>
      <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/starting_jog/</guid>
      <description>“如何有机会让现在的你遇到刚毕业初入职场的你，你会对他说什么？”这是一个知乎上的问题，以下的回答部门节选自冯大辉。
能力的提升比薪资更重要，尽管现在的你比较缺钱。【这个观点与吴军老师的观点不谋而合。初入职场，重要的是提升自己的能力，培养良好的工作习惯。因为，现阶段的薪资就基本上是挣多少花多少，而能力的提升与培养才能够让你有机会在3-5年后拿到同龄人3-5倍的薪酬。】
注意仪表仪容，尽管你是一个工程师。【没有人会通过一个邋遢的外表去关注一个有趣的灵魂。】
你的同事不是笨蛋，你的客户也不是白痴，你自己才是蠢货。【遇事多找自身原因，摆脱学生时代的依赖，学会自己去处理任何事情。】
做好每一个小事，处理好每一件小事的细节；如果做不好的地方多总结，找出原因并改进。
培养一个好习惯。比如每天工作记录，每天回顾自己，每天Review代码。一段时间之后你就会发现，好习惯可以秒杀一部分人；如果能够多培养几个好习惯，你就会变得优秀，甚至卓越。
提高沟通能力，注意写作。适应跟不同风格的人协作；能够把一件事情讲清楚，写清楚。
锻炼身体，这是_革命的本钱_。
靠谱就是三件事：“凡事有交代，件件有着落，事事有回音”。——罗振宇</description>
    </item>
    
    <item>
      <title>Vagrant使用案例</title>
      <link>http://www.subond.com/post/vagrant_usage/</link>
      <pubDate>Mon, 15 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/vagrant_usage/</guid>
      <description>1.单机配置 配置一个centos7系统，要求使用私有网络地址192.168.10.10，hostname为dbserver。 1 2 3 4 5 Vagrant.configure(&amp;#34;2&amp;#34;) do |dbserver| dbserver.vm.box = &amp;#34;centos/7&amp;#34; dbserver.vm.network &amp;#34;private_network&amp;#34;, ip: &amp;#34;192.168.10.10&amp;#34; dbserver.vm.hostname = &amp;#34;dbserver&amp;#34; end 需要说明的是：使用私有地址，vm的私有ip只能在各vm间互访，而不能访问Internet，即HOST_ONLY模式；使用公有地址，vm的公有地址将于主机某个网卡(启动vm时需指定)的地址同一网段，vm能够使用该地址访问Internet。
配置一个ubuntu xenial64系统，并将工程目录下的data目录同步到vm中，目录为/vagrant/project_data；同时将vm的80端口映射到主机的8080端口。 1 2 3 4 5 Vagrant.configure(&amp;#34;2&amp;#34;) do |ubuntu16| ubuntu16.</description>
    </item>
    
    <item>
      <title>Vagrant的快速使用</title>
      <link>http://www.subond.com/post/vagrant_startup/</link>
      <pubDate>Wed, 10 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/vagrant_startup/</guid>
      <description>Vagrant是为了方便的实现虚拟化环境而设计的，使用Ruby语言开发，基于VirtualBox等虚拟机管理软件的接口，提供了一个可配置、轻量级的便携式虚拟开发环境。使用Vagrant可以很方便的就建立起来一个虚拟环境，而且可以模拟多台虚拟机，形成分布式系统。
其次，Vagrant还可以实现文件共享，即用于主机和虚拟之间共享文件，方便开发人员在主机上写程序，再往虚拟里拷贝的麻烦。而且，Vagrant的package功能还可以将完整的开发环境进行打包，供其他人使用，极大地提高了工作效率。
1.Vagrant安装 Vagrant只是一个方便创建，管理虚拟的便携式工具，底层支持由VirtualBox、VMware等虚拟机系统支持。本文以VirtualBox为例，主机系统为Mac OSX。
VirtualBox安装 这是Virtual官网链接https://www.virtualbox.org/wiki/Downloads，可以依据自己的系统选择合适的安装包进行安装。
Vagrant安装 Vagrant官网https://www.vagrantup.com/downloads.html，同样需要依据自己的系统选择合适的安装包进行安装。
2.Vagrant配置 Vagrant配置主要在Vagrantfile文件中，通过vagrant init命令可以获得。
1 2 3 $ mkdir MyHost $ cd MyHost $ vagrant init 在MyHost文件夹下就会出现Vagrantfile文件，该文件是配置虚机的主要的文件。例如，我们想要创建一个Ubuntu Xenial 64位的虚机，并设置虚机的hostname为ubuntu64，则Vagrantfile中进行如下修改：
1 2 config.vm.box = &amp;#34;ubuntu/xenial64&amp;#34; config.</description>
    </item>
    
    <item>
      <title>Docker进阶：服务配置</title>
      <link>http://www.subond.com/post/docker_swarm5/</link>
      <pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/docker_swarm5/</guid>
      <description>当使用Docker Swarm模式时，我们可以通过命令docker service create向Swarm集群部署应用服务。Swarm集群中的管理节点将服务描述视为应用服务所需的状态。其次，所有服务相关的命令，即docker service，一定要在管理节点上运行(管理节点负责Swarm集群中的服务管理和任务编排)。
本文目录：
创建服务 配置服务 创建服务 Swarm集群中最简单创建服务的方式就是指定所要创建的服务镜像就可以，即命令docker service create &amp;lt;IMAGE&amp;gt;。当执行创建服务命令后，Swarm编排器则向可用节点分派服务任务。一个任务其实就是一个基于指定镜像生成的容器。比如，创建一个nginx web服务。
# 在管理节点上 # --name参数用于指定服务的名称 $ docker service create --name myweb nginx l3w3x4df6tnia8qql64mkdm1s # 查看Swarm集群中的服务 $ docker service ls ID NAME MODE REPLICAS IMAGE l3w3x4df6tni myweb replicated 1/1 nginx:latest 当然，我们也可以在部署服务时指定容器中将要运行的指令，其命令为docker service create &amp;lt;IMAGE&amp;gt; &amp;lt;COMMAND&amp;gt;。</description>
    </item>
    
    <item>
      <title>Docker进阶：以Swarm模式运行Docker引擎</title>
      <link>http://www.subond.com/post/docker_swarm4/</link>
      <pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/docker_swarm4/</guid>
      <description>Docker Engine 1.12及后续版本支持Swarm模式，我们可以通过以下两种方式开始Swarm模式：
创建一个Swarm集群 加入一个已有的Swarm集群 本文目录：
创建Swarm 加入Swarm 节点管理 创建Swarm 当我们使用命令行创建一个Swarm集群时，Docker引擎将启用Swarm模式。当执行docker swarm init命令时，Docker引擎将启动一个Swarm集群，主要过程如下：
将当前的模式切换至Swarm模式，并创建一个名为default的Swarm 指定当前节点为Swarm的管理节点，并以当前主机名命名当前节点 配置网络监听端口，端口号为2377 将当前节点设置为Active状态，意味着该节点可以接收调度器分派的任务 启动一个全局分布式数据中心，存储并维护Swarm信息和服务信息 默认情况下，为Swarm集群生成自签名根CA 默认情况下，生成工作节点和管理节点的token(令牌)，用于其他节点加入该Swarm 创建一个名为ingress的overlay网络，用于对外发布服务端口 # 创建一个swarm $ docker swarm init 配置通告地址
管理节点通过通告地址(advertise address)来允许Swarm集群中的其他节点访问Swarmkit API和覆盖网络。Swarm集群上的其他节点必须能够访问其通告地址(Ip地址)上的管理节点。</description>
    </item>
    
    <item>
      <title>Docker集群：工作原理</title>
      <link>http://www.subond.com/post/docker_swarm3/</link>
      <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/docker_swarm3/</guid>
      <description>一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。
本文目录：
节点的工作原理 服务的工作原理 PKI工作原理 节点的工作原理 Docker1.12及其以后版本中引入的Swarm模式，即允许创建一个Docker集群。一个Swarm集群包含一个或多个节点，既可以是物理节点，也可以是虚拟节点。但是，需要保证的是节点上要安装Docker1.12或高于1.12的Docker引擎。
Swarm模式下节点分为两种：管理节点 和 工作节点。
管理节点
管理节点负责集群的管理任务：
维护集群状态信息 服务调度 处理Swarm模式下的API请求 通过Raft原理，管理节点负责维护整个Swarm集群的内部一致状态以及其上运行的所有服务。为了测试其功能，我们可以运行单个管理节点的Swarm集群。为了保证服务的正常运行，如果单个管理节点的Swarm集群失败，则需要创建一个新的Swarm集群来接管原来的服务。
为了很好的利用Swarm集群的容错功能，Docker建议部署奇数个节点以保证整个Swarm集群的高可用性。与此同时，当采用多个管理节点时，Swarm系统可以保证管理节点的故障恢复，而不会导致服务停机。
一个具有三个管理节点的Swarm集群，最多可允许一个管理节点出现故障。 一个具有五个管理节点的Swarm集群，最多可允许两个管理节点出现故障。 一个具有N个管理节点的Swarm集群，最多可允许(N-1)/2个管理节点出现故障。 在一个Swarm集群中，Docker推荐最多部署七个管理节点。因为，更多的管理节点并不一定意味着高可用性和高伸缩性，有时恰恰相反。
工作节点
工作节点也是Docker引擎的实例，主要负责运行容器实例。工作节点不参与Raft分布式状态维护，调度决策的制定以及服务Swarm模式下的API请求。我们可以创建单个管理节点的Swarm集群，但却不能创建具有单个工作节点的Swarm集群。模式情况下，所有的管理节点也是工作节点。当然，也可以通过配置，让管理节点仅负责“管理功能”。
为了防止服务调度器在具有多个节点的Swarm集群中，将任务布置到管理节点上，可以将管理节点的可用性设置为Drain。这样，服务调度器就不会将任务部署到Drain状态的节点上，而只将任务分派到Active状态的节点。
角色转换
Docker Swarm模式中，允许我们将工作节点提升为管理节点以保证整个Swarm集群的正常运行，尤其是在管理节点出现故障时。相关命令可以参考docker node promote。
同样的道理，我们也可以将管理节点变为工作节点。相关命令可以参考docker node demote。</description>
    </item>
    
    <item>
      <title>Docker集群：服务回滚</title>
      <link>http://www.subond.com/post/docker_swarm2/</link>
      <pubDate>Mon, 24 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/docker_swarm2/</guid>
      <description>一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。
本文目录：
服务更新与回滚 路由网络 服务更新与回滚 Docker Swarm集群管理中支持服务的版本更新及回滚操作，具体演示如下：
所使用的系统环境环境如下：
三个节点(manager, worker1, worker2)均为Ubuntu16.04，即xenial64系统 节点的IP分布，manager(172.28.128.3), worker1(172.28.128.4), worker2(172.28.128.5) 首先，我们将Redis 3.0.6版本部署到Swarm集群中，并指定10s的更新时延。
# 在manger节点上 $ docker service create --replicas 3 --name redis --update-delay 10s redis:3.0.6 # --update-delay参数配置服务任务或任务集的更新的时延 # 其格式为T1hT2mT3s，即T1小时T2分钟T3秒 # 默认情况下，更新调度程序一次更新一个任务。但是，可以配置--update-parallelism参数指定同时更新的最大服务任数 # 默认情况下，当一个任务更新并返回RUNNING状态后，更新调度程序才调度另一个任务进行更新，直到所有的任务更新完成。 # 如果某个任务更新返回FAILED状态，更新调度程序则停止更新。 # 当然，也可以通过配置--update-failure-action参数指定服务创建和更新，例如： # --update-failure-action docker service create # --update-failure-action docker service update # 接下来，我们更新redis的镜像 $ docker service update --image redis:3.</description>
    </item>
    
    <item>
      <title>Docker集群：服务部署</title>
      <link>http://www.subond.com/post/docker_swarm/</link>
      <pubDate>Sat, 22 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/docker_swarm/</guid>
      <description>一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。
本文目录：
核心概念 搭建Swarm集群 核心概念 Swarm
一个Swarm是一组Docker引擎或节点的集群，并在这个集群之上部署服务和应用。我们可以使用Docker命令行工具或者API管理集群中的节点，并且还可以通过Swarm部署和编排相应的服务。当我们没有使用Swarm模式的时候，我们只是简单地对容器进行操作；而在Swarm模式下，我们就可以对服务进行编排。值得注意的是，在同一个Docker实例上既可以运行Swarm的服务，也可以运行独立的容器。
节点
一个节点即是参与Swarm集群的Docker引擎实例。我们可以将其理解为一个Docker节点。虽然，我们可以在同一物理主机或云服务上运行一个或多个节点，但是典型的Swarm生产环境则是在分布式的物理主机或云服务上部署多个Docker节点。
当部署一个服务到Swarm集群中时，我们需要率先在 管理节点 上注册该服务。然后，管理节点将该服务（称之为 任务）分派给各个 工作节点。
管理节点(Swarm Manager)负责服务编排和集群管理以保证整个集群的正常运行，并负责选出一个leader进行任务编排工作。
工作节点(Swarm Agent)负责接收并执行管理节点派发下来的任务。默认情况下，管理节点同时扮演工作节点的角色，即接收并执行任务。当然，我们也可以通过配置让管理节点只负责任务管理的功能，使之成为“只具备管理”的节点。Agent在每个工作节点上运行，并报告分派给它的任务。工作节点向管理节点报告其分派到的任务的当前状态，以便管理节点可以维护每个工作节点所需的状态。
服务和任务
一个服务是指运行在工作节点上任务的定义。它是Swarm系统的中心结构，也是用户与Swarm交互的主要根据。当创建一个服务时，我们需要指定容器即将使用的镜像以及容器中要执行的命令。在服务分派模型中，Swarm的管理节点根据我们在所需状态下设置的比例，在工作节点中分配特定数量的任务副本。对于全局服务，Swarm在集群中的每个可用工作节点上为服务运行一个任务。
一个任务带有一个Docker容器和在容器中执行的命令。任务是Swarm进行服务管理的原子调度单元。管理节点根据服务规模中设置的副本数量将任务分派给工作节点。一旦一个任务分派给某个节点，任务就不能移动到另一个节点，它只能在分配的节点上运行或者失败，这即是任务的原子性。
负载均衡
Swarm集群管理使用的是 入口负载均衡 策略来暴露想要从外部访问的服务。Swarm的管理节点可以自动地给服务分配一个PublishedPort，也可以为该服务自行配置一个PublishedPort。如果不指定端口，Swarm管理节点将分配30000-32767之间的某个端口。
外部组件，像云端负载均衡，可以访问集群中任何一个节点的PublishedPort，无论这个节点当前是否在运行某个服务的任务。Swarm路由中的所有节点都将连接到正在运行任务实例的节点上。
Swarm中还有一个内部DNS组件，可自动为集群中的每个服务分配DNS条目。Swarm管理节点使用内部负载均衡，根据服务的DNS名称在集群内部的服务之间分配请求。
搭建Swarm集群 搭建Swarm集群过程中，所使用的系统环境环境如下：
三个节点(manager, worker1, worker2)均为xenial64系统 节点的IP分布，manager(172.</description>
    </item>
    
    <item>
      <title>Docker技术：快速上手教程</title>
      <link>http://www.subond.com/post/docker_quickstart/</link>
      <pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/docker_quickstart/</guid>
      <description>本文目录：
1.构建容器-Containers 2.组合服务-Compose 3.集群管理-Swarm 4.应用协作-Stacks 1.构建容器-Containers Dockerfile将定义容器中环境的内容。通过将访问资源（例如，网络接口和磁盘驱动器）进行虚拟化处理，实现与宿主机系统的隔离。为此，我们需要将端口映射到外部宿主系统环境中，并说明将要把那些文件“复制”到隔离的环境中，即容器。这样之后，我们就可以期望在Dockerfile中定义的应用程序可以在任何地方运行。
Dockerfile
创建一个新的空目录，在目录下创建名为Dockerfile的文件，并写入以下内容。
# Use an official Python runtime as a base image FROM python:2.7-slim # Set the working directory to /app WORKDIR /app # Copy the current directory contents into the container at /app ADD .</description>
    </item>
    
    <item>
      <title>Docker技术：Dockerfile的定义与使用</title>
      <link>http://www.subond.com/post/docker_dockerfile/</link>
      <pubDate>Tue, 18 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/docker_dockerfile/</guid>
      <description>本文目录：
Dockerfile的使用 Dockerfile指令 Dockerfile是Docker用来构建镜像的文本文件，包括自定义指令和格式。命令docker build可以与Dockerfile文件中构建我们自己需要的镜像。
Dockerfile的使用 Dockerfile文件描述了构建镜像的步骤，其中每条指定都是单独执行的。除了FROM指令，其他每条指令都会在上一条指令所生成镜像的基础上执行，执行完成后生成一个新的镜像层。新的镜像层覆盖在原来的镜像之上，进而形成新的镜像。Dockerfile文件所生成的最终镜像是在基础镜像上叠加一层层的镜像形成的。
值得注意的是，Docker引擎在构建镜像的过程中会缓存中间镜像。当从一个已经存在的基础镜像开始构建新镜像时，则将Dockerfile中的下一个指令和基础镜像的所有子镜像进行比较，如果有一个子镜像是由相同的指令生成的，则命中缓存，直接使用该镜像。
Dockerfile指令 Dockerfile的基本格式如下：
# 注释信息 INSTRUCTION arguments Dockerfile指令不区分大小写，但是建议使用大写，方便区分；#开头的表示注释行。根据指令的作用可以分分为两种：构建指令和设置指令。构建指令用于构建镜像，其指定的操作不会运行在镜像的容器上；而设置指令用于设置镜像的属性，其指定的操作运行在镜像的容器上。
FROM 格式：FROM 或FROM :
分类：构建指令
FROM指令指定基础镜像，一个有效的Dockerfile文件必须以FROM作为第一条非注释指令。后续的指令都依赖于该指令指定的image。FROM指令指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。
MAINTAINER 格式：MAINTAINER 分类：构建指令
用于将image的制作者相关的信息写入到image中。当我们对该image执行docker inspect命令时，输出中有相应的字段记录该信息。
RUN 格式：RUN &amp;lt;shell_cmd&amp;gt; # shell格式</description>
    </item>
    
    <item>
      <title>Docker技术：Docker系统架构</title>
      <link>http://www.subond.com/post/docker_docker_arch/</link>
      <pubDate>Sun, 16 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/docker_docker_arch/</guid>
      <description>本文目录：
[Docker Engine](#Docker Engine) Docker交付内容 Docker系统架构 Docker Engine Docker Engine主要包含三个组件，如下图所示：
Docker Server：一个长时间运行的守护进程。 REST API：指定程序可以用来与守护进程通信的接口。 Client：命令行CLI客户端。 CLI利用脚本或直接输入命令的方式，通过REST API与Docker Daemon(守护进程)进行通信，并完成相关操作。Docker Damemon是负责容器对象的主体，例如镜像，容器实例，网络管理以及数据卷等。
Docker交付内容 快速，一致地交付应用程序 Docker允许开发人员通过提供本地容器标准化环境，从而简化应用程序和服务的开发生命周期。容器可以适用于连续集成和持续开发的工作流程。Docker的便携性和轻量级性质使得轻松实现动态管理工作负载，按照业务需求来实现扩展或拆除应用程序和服务
在同一硬件上可允许多个工作流程 Docker重量轻，速度快。它为基于虚拟机管理程序的虚拟机提供了可行的，具有成本效益的替代方案，因此可以使用更多的计算能力来实现业务目标。Docker是高密度环境和中小型部署的理想选择，您需要用更少的资源来做更多的事情。
Docker系统架构 Docker采用Client/Server架构模式，其系统架构如下图所示。
Docker客户端与守护进程既可以运行在同一台主机，也运行在不同的主机上，两者利用Unix Socket或网络接口，通过REST API进行通信。
Docker Daemon监听Docker API来相应客户端的请求，完成Docker对象的管理。</description>
    </item>
    
    <item>
      <title>Docker技术：认识Docker</title>
      <link>http://www.subond.com/post/docker_docker/</link>
      <pubDate>Fri, 14 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/docker_docker/</guid>
      <description>Docker和传统虚拟化方式的不同如下图所示。传统虚拟化技术是虚拟出一套硬件，在其上运行一个完整操作系统，再在该系统之上再运行所需的应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。
本文目录：
1.什么是Docker 2.Docker基本概念 3.Docker安装 4.Docker网络 1.什么是Docker Docker是使用Go语言进行开发实现，基于Linux内核的cgroup, namespace, 以及AUFS类的Union FS等技术，对 进程 进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他隔离的进程，因此成为容器。
Docker和传统虚拟化方式的不同如下图所示。传统虚拟化技术是虚拟出一套硬件，在其上运行一个完整操作系统，再在该系统之上再运行所需的应用进程；而容器内的 应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。
2.Docker基本概念 Docker包括三个基本概念：镜像、容器、仓库。
1 镜像(Image)
众所周知，操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像，就相当于一个root文件系统。
Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件，也包含一些为应用运行时准备的配置参数。镜像不包含任何动态数据，其内容在构建之后也不会被改变。
分层存储
镜像在构建时，一层层构建，前一层是后一层的基础。每一层构建完成后就不会再发生改变，后一层上的任何改变值发生在自己这一层。当我们使用命令docker pull ubuntu:14.04获取ubuntu14.04镜像时，可以看到每一层的镜像，及其相互依赖关系。
# 获取DockerHub中的ubuntu14.04镜像 $ docker pull ubuntu:16.</description>
    </item>
    
    <item>
      <title>深入理解Paxos算法</title>
      <link>http://www.subond.com/post/learn_paxos/</link>
      <pubDate>Tue, 21 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/learn_paxos/</guid>
      <description>1.Paxos算法 Paxos算法是Leslie Lanmport(2013年获图灵奖)在1990年提出的一种基于消息传递的共识算法(也称为，一致性算法)，由于算法难以理解并没有被ACM TOCS发表。直到1998年，才引起人们的注意，Lanmport重新发表文章。为了便于人们通俗地理解Paxos算法，Lanmport于2001年简化原来的文章，发表了Paxos Made Simple，文章循序渐进地推导出了Paxos算法，并用数学归纳法进行了证明。在此基础上，本文结合Paxos Made Simple，与其他优秀的Paxos算法解读，重新描述Paxos协议，希望可以深入理解基本的Paxos算法理论。
Paxos算法解决的问题是一个分布式系统中如何就某个值(或协议)达成一致。在一个分布式系统中，如果各节点的初始状态一致，每个节点都执行相同的操作，那么他们最后的得到的也是一个一致的状态。一个分布式系统中，通常包含一个主节点和多个备节点。为了保证每个节点执行相同的操作指令，需要每一条执行执行一个“一致性算法”来选举出主节点，进而保证每个节点得到的指令一致。这是一个分布式系统中的重要问题。
2.基本概念 Paxos算法中有三种角色：Proposer, Acceptor, Learner。每个节点需要同时扮演 两种或两种以上的角色。
Proposal Value: 提议的值　Proposal Number: 提议编号，并且要求提议编号不能冲突　Proposal: 提议　=　提议编号 + 提议的值　Proposer: 提议发起者　Acceptors: 提议接受者　Learners: 提议学习者　需要说明的是，Proposer有两种行为，一个是向Acceptors发起Prepare请求，另一个是向Acceptors发起Accept请求。Acceptors则根据协议规则或(自身状态)对Proposers的请求做出应答。Learners根据Acceptors的状态，学习最终被确定的值。</description>
    </item>
    
    <item>
      <title>读书写作那点事儿</title>
      <link>http://www.subond.com/post/reading_and_writing/</link>
      <pubDate>Tue, 21 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/reading_and_writing/</guid>
      <description>这是一篇关于读书写作的读书笔记，内容源自李笑来老师知乎Live的《我的读书经验》。
关于读书路径 知识就是力量，从来都不是一句空话。获取知识的途径有很多，读书无疑是有效的方式之一。那么，有哪些较好的读书路径值得我们参考呢？笑来老师给出了以下几个方法：
泛读，即广泛地阅读。尤其是开始的时候，应尽得杂一点，漫无目的地读，慢慢地就会发现读书的乐趣，发现自己感兴趣的点，而后就可以着点而入，深入阅读。这是一个广散网，寻找点的过程。
学会挑书，形成自己的书单。总的来说，挑书应该有这样一个原则：能够帮助我们认清现实并思考未来，且具有 繁殖能力 的书。能够帮组我们认清现实并有所思考的书多为非虚构类的书，这一类书可以往往能够就某一问题，或某一现象，甚至某个学科做较为深入的分析与探讨，是我们了解当下现实的基础，而书中关于这些问题的讨论有可以启发我们对未来的思考。具有繁殖能力的知识，往往是那些能够激发我们阅读欲望，探索问题解决之道；亦或与我们原有的知识形成冲突，或者形成补充的知识，这是一个不断发现其他点，形成星星之火的过程。
建立检索书库，方便日后查询。选择一款自己喜欢的笔记软件，不断地做好自己的阅读笔记。将阅读过程中发现的亮点和思考，以及相关的书目形成记录。如何做好阅读笔记，可以参考万维刚老师的什么是好的读书笔记。这是一个将点连接成线，进而形成一个面的过程。
杂读，尽量涉及更多的领域和学科。想要获得一些意外的收获，杂读就是一个很好的方法。用自己原有的专业知识及系统去接触一个相对陌生的领域和学科，往往可以碰撞出不一样的火花。这是一个发现其他面的过程，并产生面与面交集的过程。
读书的目的 读书，为了改变生活。宋真宗赵恒在《励学篇》言道：安居不用架高楼，书中自有黄金屋；娶妻莫恨无良媒，书中自有颜如玉。虽说有些功利化，但读书就是可以改变我们的生活。这种改变往往并不是直接地改变我们一些什么，而是通过间接的方式。书，带给我们新的知识，新的思维，甚至新的思考方式；带给我们不曾认识或者不能正确认识的专业及领域，潜移默化地影响着我们的生活及工作，慢慢地某些东西就刻在了我们的骨子里，让我们终生受用。
升级阅读方法 通过前面的介绍，我们认识了读书路径，知道了读书的目的。那么，什么的阅读方法才算有效的阅读呢？关于这一点，以下原则值得参考：
只字不差，反复阅读。限于我们每个人不同的专业背景及知识阅历，也限于我们现有的水平，我们不太可能，甚至不可能了解所有的行业和学科，所以 一本书，只要必要，即便是读不懂，也要读完。说不定哪一天，书中某个点就激发我们新的思考。
翻看书评，以书会友。莎士比亚曾言：There are a thousand Hamlets in a thousand people&amp;rsquo;s eyes(一千个读者就有一千个哈姆雷特)。通过阅读他人关于一本书的思考，我们看到另一个角度的阐释。这份阐释也许跟我们自己的理解有所冲突，也许互为补充，也许高于我们的见识，也许低于我们的见识，这不正是读书的意义嘛。
持续写作，有效输出。写作，是提高阅读能力的有效工具。教，是最有效的学习。当我们能够产生输出的时候，才算是内化到我们自己系统的东西。最初写作的时候，可能写得并不好，也没有那么完善，但是一定要保证它是完整的。之后，再通过不断地完善和补充，形成好的作品。另外，当我们写作的时候，才可以像作者一样阅读，明确自己的写作意图，梳理其中的逻辑关系，补充论据的支撑点。最后，还有更重要的一点：写作，目的只有一个——讲清楚一件事。
###关于现代阅读的
如何对待碎片化阅读？
信息社会的发展，不断涌现的智能终端，几乎可以让我们随时随地地阅读；刷微博，刷微信，几乎也占据了我们大部分的闲暇时间，这样碎片化的信息对我们有多大意义呢？其实，意义不大。建议就是：形成固定的阅读时间。在固定的时间里阅读，与书对话，充分享受思想的碰撞，知识的更新。
读书带来的价值有多少？</description>
    </item>
    
    <item>
      <title>二十五六岁</title>
      <link>http://www.subond.com/post/the_middle_twenties/</link>
      <pubDate>Thu, 15 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/the_middle_twenties/</guid>
      <description>当一个人开始怀念少年时光的时候，他的少年时代就已经一去不复返了，此时此刻的他俨然成了一个有责任的青年人。
面对未来，每个人都会或多或少地有些焦虑，尤其是年轻人。对未来既充满了幻想，也充满了渴望。未来，总是有无数的希望吸引着我们，去追逐，去靠近。
焦虑是年轻人的普遍状态，有焦虑感的是很棒的，因为他们很清楚知道自己应该奔跑，只不过，暂时不知道自己应该选择哪一条跑到罢了。——吴慧超
二十五六岁的我们，基本上刚刚告别学生时代，开始走上社会，像任何一个“刚上任”的新人一样，在一家公司，做着一些再普通不过的工作。总想获得更多，却又无力支付。欲望与贪婪太多，而自己无力支付，这或许是最大的焦虑吧。
作为一名农村出来的孩子，我出生在一个普通的家庭，没有任何背景可言，能够完整地接受高等教育，并进行一定程度地深造，已经非常幸运了。所以，在大学毕业的那一天，才忽然明白——从此，我的人生才算是完整的。因为，并不是每个人都有机会能够接受教育，在这个美好的年纪。但是，也必须深刻认识到：在踏入社会的那一刻，“父母的庇护至此结束，未来的一切，都需要自己去挣”。
在文章《一个人在二十五六岁时，该是什么状态》，作者吴慧超写一部分自己刚参加工作的经历，总结起来就是四个字：不负时光。当我们回望自己过去的时候，如果觉得那些点点滴滴的进步与成长，正慢慢地让自己逐渐变得越来越独立，越自信，成为家人的依靠，成为一个肩负责任的人，那就叫不负时光。
记得海明威有一句箴言：优于别人，并不高贵，真正的高贵是优于过去的自己。
达尼·拉费里埃在《还乡之谜》中，写道：”前方总有太多的希望，身后总有太多的失望。生命是一条长长的带子，展开在延绵不断的时光中，展开在柔软的变幻迁移中，交替着希望与失望”。
二十五六岁的年纪，就是撸起袖子加油干。写给自己，也写给每个为生活更美好而努力的人。</description>
    </item>
    
    <item>
      <title>Reply 1988: 人生是个迷啊</title>
      <link>http://www.subond.com/post/reply-1988/</link>
      <pubDate>Fri, 07 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/reply-1988/</guid>
      <description>人，之所以为人，是因为可以享受生命的意义，生活的乐趣。
这是一篇关于韩剧《请回答1988》的观后感。
这部剧讲了啥？ 这部剧发生在韩国首尔一个叫做“双门洞”的胡同，讲述了五家人的故事，细致生动地再现了80年代邻里街坊小市民的生活面貌。整部剧以生活为主线，贯穿亲情，友情，爱情以及邻里情，细致地刻画了那个永远回不去的青春岁月。剧中的生活细节做的很足，处处都可以看到编剧和导演的良苦用心。其实，生活无非就是一日三餐，家长里短，却被演员们表现的淋漓尽致，主要集中在以下几个方面：
关于亲情 剧中宝拉的父亲是一个善良，倔强，喜欢把话放在心里的父亲形象，像很多中国的父亲一样。在自己妈妈去世的那一段，宝拉的父亲白天笑脸招呼客人，晚上独自悲伤，静静地守在灵堂前。直到大哥回来，才好像找到了依靠，不必装作坚强，兄弟姐们四人终于忍不住哭了起来。”大人只是在忍，只是在忙着大人的事，只是在用故作坚强来承担年龄的重担。大人们，也会疼。”
二十几岁的年龄，或多或少也开始意识并接触到周围亲人的年老，甚至离开。突然之间就发现，原来好多的称呼从此再也叫不出口，而关于那个人的记忆却永远地刻在记忆里。我的爷爷在我父亲18岁的时候，生病去世了。所以从小到大，我没有喊过一声&amp;quot;爷爷&amp;quot;，也从来没有体会过爷爷的爱是一种什么样的爱。小时候不懂事，还吵着向父亲母亲“要过”爷爷。现在想来，那时的父亲想必也是凄苦的。随着年龄的增长，那一声”所谓的称呼”也就越发显得弥足珍贵了，真是应了中国那句老话：喊一声，少一声。
“上帝不能无处不在，因此他创造了母亲”是一句犹太谚语，是赞美母亲的。其实，父母真的就是子女的守护神。无论孩子在外面受了多大的委屈，只要回家就能感受到温暖，找到了依靠。挫折的时候，给我们鼓励与安慰；迷茫的时候，给我们指引与勇气；给我们追逐梦想的力量。每当我们取得一些成绩的时候，或是夸赞，或是小心翼翼地记录着我们的成长，像阿泽爸那样，把报纸上关于儿子的比赛报道一一剪下，做成册子，细数着儿子每一次的成绩。深沉的大地一样的爱，那是父亲的爱。
剧中的三位母亲，也是那样的平凡而伟大。没有女儿的豹子夫人，却收获了比女儿还细心的&amp;quot;二女儿&amp;quot;金正焕。知道母亲不懂英文，细心地在母亲的护照上标上注音；知道母亲是操心的命，当发现母亲因为外出探亲而父子三人过得还不错而不免有些失落的时候，故意制造小麻烦，让母亲“回归”；知道父母的结婚照是合成的，精心地为二人准备婚礼。这些小小的细节，足见正焕的用心。90年代我国实行”计划生育”政策，导致我们90后这一代几乎都是独生女子，以至于作为儿子的我们，不得不又当儿子又当“闺女”。
剧中印象很深的还有的阿泽爸爸和善宇妈妈，两人都有一个好儿子。作为单亲家庭的孩子都很懂事，两个儿子都知道父母亲的不容易，更明白人生的意义。人各有命，作为孩子尊重父亲，母亲的决定，作为父母也尊重孩子的想法。渐渐地发现，生命中的每一个出现在身边的人都有存在的意义。有些话只能对固定的人讲，或者选择不说。丈夫，妻子，邻里，儿子，女儿，朋友···每个人扮演的角色不同，所承载的意义也不同。就像香港电台主持人梁继璋在给儿子的一封信中写到的那样：“亲人只有一次的缘分，无论这辈子我和你相处多久，也请好好珍惜共聚的时光，下辈子，无论爱与不爱，都不会再见”。今生有幸为家人是最大的幸福。
关于爱情 剧中德善的爱情最引人关注。在不知道结局的时候，个人比较倾向于德善和阿泽这一对儿。原因很简单：没有所谓的时机，只有更恳切的心。
如果今天，我没有被那该死的红绿灯拦住，我可能就会命运般站在她的面前。但是缘分，不是自动找上门的偶然，是带着恳切的盼望做出的无数选择。那家伙更恳切，搞怪的不是红绿灯，而是我数不清的犹豫。
这是正焕的独白，只可惜明白得太晚了。虽有些让人心疼，可是世事如此。既然喜欢，就要大大方方让对方知道。爱情里，没有尴尬。有些人，总是担心，本来是朋友说破了岂不是很尴尬。其实，今生若不能为爱人，为什么要保持那么亲密的朋友关系呢？为了爱人，失去一个好朋友又怎么样，何况还是异性。爱人，才是我们一生都要守护的那个人。
关于友情 剧中正焕和阿泽同时喜欢德善，互为情敌。但是有一句台词我很喜欢：
虽然我和你爱着同一个女人，可是我仍然喜欢你，不愿意让任何不幸发生在你身上。
没错，这就是友情。
关于人生 人生的话题好大，可是细说起来也就那么点。每个人都有自己的选择，都有需要自己独自去面对的时刻，为了不让我们孤单，才拥有了家人，朋友。人生更像是一场修行，能帮到你的也只有 我们自己。善待生命中遇到的每一个人，他们看似无关，却与你有着千丝万缕的牵连，来到你的身边，请珍惜。
剧中的正峰哥哥也是一个神奇的存在，说实话全剧95%的剧情中我都觉着这是一个多余，直到结尾才发现，这是导演的最后一步棋。正峰哥哥用了七年考大学，用了七年考司法考试，直到遇见真爱，才明白：活着，要做自己想做的事情。最终选择了做美食。一个人能够发现自己的擅长，并将其培养成自己的工作或者一生的事业，是多么的不容易！
人生最难的在于找到自己。</description>
    </item>
    
    <item>
      <title>Linux中的线程管理</title>
      <link>http://www.subond.com/post/linux_process2/</link>
      <pubDate>Sun, 19 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/linux_process2/</guid>
      <description>1.线程 线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。
2.多线程模型 操作系统中有两种方法提供线程支持：用户层的 用户线程 和 内核层的 内核线程。用户线程受内核内核支持，而无需内核管理；内核线程由系统直接支持和管理。
1）多对一模型：多个用户线程映射到一个内核线程
特点：线程管理由线程库在用户空间进行，效率高；一个线程阻塞系统调用，整个进程阻塞；任意时刻，只有一个线程能访问内核(也就是，多线程不能并行运行在多处理器上)
2）一对一模型：每个用户线程映射到一个内核线程
特点：一个线程阻塞，其他线程不受影响，具有并发功能；允许多线程运行在多处理器上。
3）多对多模型：即多路复用，许多用户线程映射到同等数量或较少数量的内核线程
特点：结合多对一模型和一对一模型的优点，其对应的一个变形是 二级模型 (先允许一个用户线程绑定到一个内核线程上，然后，其他用户线程多路复用)
3.线程库 线程库为程序员提供创建和管理线程的API函数，主要有两种方法来实现线程库：系统调用和非系统调用
1）在用户空间提供没有内核支持的库，称为 非系统调用；
2）由系统支持的内核级库，称为 系统调用
系统调用fork()和exec()
exec():如果一个线程调用exec()，则其指定的程序替换整个进程，包括所有线程。
fork(): 1）fork()之后立即调用exec()，则没有必要替换所有线程，因为exec()会替换所有线程；2）fork()之后没有调用exec()，则另一个进程复制所有线程。
4.线程取消 线程取消是在线程完成之前来终止线程的任务。要取消的线程称为 目标线程。目标线程可以在两种情况下发生：
1）异步取消: 一个线程立即终止目标线程。 (所有线程共享进程的数据，因为异步取消并不会使系统资源空闲)</description>
    </item>
    
    <item>
      <title>Linux中的进程管理</title>
      <link>http://www.subond.com/post/linux_process/</link>
      <pubDate>Fri, 17 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/linux_process/</guid>
      <description>1.进程 进程是执行中的程序，是大多数系统的工作单元，是 活动实体。一般，进程具有以下几种状态：新的，运行，等待，就绪，终止。每个进程在操作系统中用进程控制块(PCB)表示，其包含许多与一个特定进程相关的信息(进程状态，程序计数器，CPU寄存器，CPU调度信息，内存管理信息，记账信息，I/O状态信息等)。
进程调度
进程调度是指选择一个可用的进程到CPU上执行的过程，由相应的 调度程序 来执行。进程进入系统后，进入 作业队列 (包含系统中的所有队列)；驻留在内存中就绪，等待执行的进程位于 就绪队列。就绪队列通常用链表实现，其头节点指向链表的第一个和最后一个PCB块的指针；每个PCB包括一个指向就绪队列的下一个的PCB的指针域。
调度程序分为 长期调度程序, 中期调度程序 和 短期调度程序。长期调度(高级调度)，又称为 作业调度，是指从池中选择进程，并装入内存准备执行，其使用频率比较低，主要用来控制内存中进程的数量；中期调度(中级调度)，又称为 交换调度，是指将进程中内存或CPU竞争中移出，从而降低多道程序设计的程度，之后进程被重新装入内存；短期调度(低级调度)，又称为 进程调度，是指按照一定的策略和算法，将CPU分配给一个处于就绪的进程，分为 抢占式 和 非抢占式。
上下文切换
将CPU切换找另一个进程需要保存当前进程的状态，并恢复另一个进程的状态，这个过程称为上下文切换。
2.进程操作 进程创建 和 进程终止
进程创建新进程时，有两种执行可能：
1）父进程与子进程并发执行；2）父进程等待，直到某个子进程或全部子进程执行完毕。
同样，新进程的地址空间也有两种可能：</description>
    </item>
    
    <item>
      <title>Linux中的线程函数</title>
      <link>http://www.subond.com/post/linux_pthread/</link>
      <pubDate>Tue, 14 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/linux_pthread/</guid>
      <description>线程是CPU使用的基本单元，由线程ID，程序计数器，寄存器和栈组成。同属一个进程的所有线程共享代码数据，系统资源。多线程具有如下优点：响应度高，资源共享，更经济(较进程)，充分利用多处理器系统的结构。以下内容，主要介绍5个基本线程函数。
1.pthread_create()函数 当一个程序由exec启动执行时，称为初始线程或主线程的单个线程就创建了。其余线程则由pthread_create函数创建。
#include &amp;lt;pthread.h&amp;gt; int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg); //返回：成功为0，出错为正的Exxx值 tid:一个进程内的每个线程都有一个线程ID标识，其数据类型为pthread_t(unsigned long int,即％lu)。如果新的线程创建成功，其ID通过tid指针返回。
attr:属性，每个线程都有许多属性（优先级，初始栈大小，是否成为一个守护线程等等）。若采用默认设置，可置attr参数为空指针（NULL）。
创建一个线程时最后指定的参数就是由该线程执行的函数func及其参数arg。注意 func和arg的声明。func所指函数作为参数接受一个通用指针 (void *)，又作为返回值返回一个通用指针(void *)。另外该函数的唯一调用参数是指针arg，如果需要给函数传递多个参数，可以打包成一个结构，然后将结构的地址作为单个参数传递给函数。
2.pthread_join()函数 #include &amp;lt;pthread.h&amp;gt; int pthread_join(pthread_t *tid, void **status); //返回：成功为0，出错为正的Exxx值。 该函数的功能是等待一个给定线程终止</description>
    </item>
    
    <item>
      <title>Git学习手记</title>
      <link>http://www.subond.com/post/gitxuexi/</link>
      <pubDate>Fri, 29 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/gitxuexi/</guid>
      <description>一、基础篇 指令介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 $ git config --global user.</description>
    </item>
    
    <item>
      <title>Go逃逸分析与性能</title>
      <link>http://www.subond.com/post/004_golang_stack_or_heap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.subond.com/post/004_golang_stack_or_heap/</guid>
      <description>Go 逃逸分析与性能 1、变量与内存 通常每种编程语言都有自己的内存模型，每个变量，常量都存储在内存的某个物理位置上，并通过内存指针来访问。
我们都知道，程序运行时所使用的的内存分为两个区：堆和栈。那我们怎么知道变量是分配在堆还是栈上呢？Go 语言实现了垃圾回收机制，其内存是自动管理的，所以通常作为开发者并不需要关心内存分配在栈还堆上。但是站在性能的角度，在栈上分配内存和堆上分配内存，两者的性能却非常大。因为分配在栈上的内存，函数直接结束就能自动回收；而分配在堆上的内存，需要等待垃圾回收才能被回收释放。
在 Go 官网的FAQ上有个变量分配的问题如下：
如何知道变量是分配在堆上还是栈上？
从正确性的角度来看，你不需要知道。只要有对它的引用，Go 中的每个变量就存在，而且变量选择的存储位置与语言的语义无关。
存储位置确实对程序性能有影响。如果可能，Go 编译器将在函数的栈上分配该函数的本地变量。但是，如果函数返回后无法保证该变量不再被引用，那么编译器必须在垃圾回收的堆上分配该变量以避免悬空指针错误。此外，如果局部变量非常大，将其存储在堆上而不是栈上可能更有意义。
在当前的编译器中，如果一个变量的地址被占用，那么该变量就是在堆上分配的候选者。但是，基本的逃逸分析会识别某些情况，将函数返回后不再存活的变量分配在栈上。
由此我们可以发现，变量逃逸一般发生在以下几种情况：
函数返回地址 函数返回引用 函数返回值类型不确定，或者说不确定其大小 变量过大 变量大小不确定 那么，知道变量逃逸的原因后，我们就可以有意识地将变量控制在栈上，减少堆变量的分配，降低GC成本，提高程序性能。
2、逃逸分析 Go 语言内存分配是由编译器决定的，编译器会跨越函数和包的边界进行全局的分析，检查是否需要在堆上为一个变量分配内存，还是在栈本身的内存对其进行管理，这个过程称为逃逸分析(escape analysis)。
2.1 变量大小逃逸 举个例子，我们模拟一个变量大小不确定的情况：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main func main() { num := 10 s1 := make([]int, 0, num) for i := 0; i &amp;lt; num; i++ { s1 = append(s1, i) } s2 := make([]int, 0, 10) for i := 0; i &amp;lt; num; i++ { s2 = append(s2, i) } } 编译时，指定编译参数-gcflags=&amp;quot;-m&amp;quot;可以查看逃逸分析，结果如下：</description>
    </item>
    
  </channel>
</rss>
